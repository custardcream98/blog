[{"slug":"블로그에 검색 기능을 구현해보자 1","title":"블로그에 검색 기능을 구현해보자 1","date":"2022-11-26T04:09:00+09:00","content":"점점 포스트 수가 많아져서 뿌듯하긴 한데, 가끔 제가 쓴 글을 찾기가 어렵더라고요. 그래서 이번엔 검색 기능을 직접 구현해보기로 했습니다. 어떻게 개발할까 husky pre-commit hook으로 커밋할 때 자동으로 캐시를 생성Next.js에 검색용 API 엔드포인트 추가 (Fuzzy 검색 간단하게 적용해보기)검색바 구현 (디바운싱과 쓰로틀링 비교해보기) 가장 좋은 방법은 아닐순 있어도 우선 목표를 달성하고, 추후 조금씩 최적화하면 될 것 같습니다. 캐시를 생성하자! 제 블로그는 아래의 순서로 포스트를 렌더링합니다. 마크다운 파일을 읽어옵니다.읽어온 내용을 HTML로 파싱합니다. (remark를 활용합니다) 이 때, 파싱의 결과는 string입니다.파싱한 내용을 마크다운용 스타일이 적용된 styled-component에 dangerouslySetInnerHTML로 넣습니다. 검색 기능을 구현하려면 모든 포스트에 대한 내용을 가지고 있는 일종의 캐시가 필요합니다. 저는 이 캐시를 매 커밋 직전에 자동으로 생성하고자 합니다. 이를 위해 아래의 파일을 생성했습니다. 우선 파일 내용을 읽어와야 합니다. 저는 이미 마크다운을 읽고 HTML로 파싱하는 함수를 만들어 쓰고 있었으므로, 해당 함수들을 활용해 HTML로 파싱된 내용을 불러옵니다. 그렇게 파싱된 HTML string은 18번째 줄에서 Document Object로 파싱됩니다. 노드 환경에서 DOM API를 사용하기 위해 jsdom 모듈을 활용했습니다. 그 후, 필요한 요소를 querySelectorAll()로 가져오고, 각 요소를 돌며 textContent를 추출해 postsCache에 담습니다. 15번째 줄에 보시면 마크다운 string으로부터 HTML string을 생성하는 markdownToHtmlForCache()가 비동기 함수이므로 postsData.map()을 Promise.all()로 감싸줍니다. 마지막으로 postsCache를 cache.json에 저장합니다. 이 다음 개발할 API에서 이 json 파일을 캐시로 사용하려고 합니다. Top-level await를 썼으면 더 보기 좋았겠지만 Next.js와는 독립적으로 동작할 부분 때문에 전체 프로젝트의 설정을 바꾸고 싶지는 않아 즉시 실행 함수로 작성했습니다. 이제 이 cache.ts를 실행하는 명령어를 pre-commit 훅으로 추가해주면 됩니다. cache.ts 실행을 위해 tsx를 devDependency로 추가했습니다. 검색용 엔드포인트를 만들자 우선, 검색용 API를 개발하기 앞서서 한가지 생각해볼 문제가 있습니다. 많은 서비스들이 검색시 '대충 입력해도 원하는걸 찾아 보여주는' 자동완성 기능을 제공합니다. 저는 이것처럼 사용자의 입력값이 완벽하지 않아도 찾고있을 가능성이 있는 글을 보여주는 기능을 붙이고 싶습니다. Fuzzy 간단하게 적용해보기 참고한 태곤님 블로그 포스트 Fuzzy 알고리즘은 이를 구현할 때 쓸 수 있는 방법중 하나입니다. 두 문자열의 유사성을 파악해서 유사도가 높은지 여부를 판단하는 식입니다. 관련해서 복잡한 알고리즘 이론들이 많이 나와있지만 저는 최대한 간단하게 접근하면서 제가 직접 바꿀 수 있도록 태곤님 블로그에 나온 방법을 적용, 일부 코드를 조금 수정했습니다. (대소문자 둘 다 대응할 수 있도록, title과 content 두가지를 기준으로 찾을 수 있도록) 태곤님 포스트는 꼭 읽어보세요! 간단하면서도 흥미롭더라고요😁 다만 마지막에 longestDistance가 긴 순으로 정렬하는것이 좋은 반응을 얻었다는 의견을 소개해주셨는데, 왜 그런지 궁금하긴 했습니다. 저는 짧은 순으로 쓰기로 했습니다. 아래는 제가 수정한 코드입니다. 프론트엔드단에서 match된 string에 따로 스타일을 줄 수 있도록 배열로 분리하고, 어느 부분이 match된건지를 알리는 matchedOne 프로퍼티를 넣었습니다. 태곤님의 로직을 그대로 적용하면 longestDistance에 제한이 없어 content같이 긴 문구에서는 아주 길게도 match를 찾는 이슈가 발생해 해당 부분도 예외처리를 추가했습니다. 엔드포인트 실제 엔드포인트 구현 부분은 fuzzy.ts에서 모든 로직을 수행하고 있어 매우 간단했습니다. API 데모 (query = \"next\") 다음 포스트에선 이렇게 개발한 API를 활용해 실제 블로그에 적용해보겠습니다. "},{"slug":"개인 프로젝트 Share it!의 성능 최적화하기","title":"개인 프로젝트 Share it!의 성능 최적화하기","date":"2022-11-23","content":"\"코드를 서로 나누고 피드백을 주고받는 공간이 있었으면 좋겠다!\"는 생각으로 Share it! 이라는 커뮤니티를 개발했는데, 어떻게 하면 더 빠른 로드 시간을 달성할 수 있을지 고민했습니다. Share it! 서비스 링크 코드를 자유롭게 나누고 리뷰와 질문을 남기는 공간이 있으면 좋겠다는 생각에 개발한 간단한 커뮤니티입니다. TypeScript, React, styled-components 등을 기술 스택으로 사용했습니다. React Helmet 모듈을 사용해 SEO도 최대한 챙겨보고자 했습니다. 백엔드는 Firebase와 Express로 개발했습니다. (댓글을 남기면 글 작성자에게 메일을 보내는 기능을 위해 Express를 사용했습니다. node-mailer 모듈을 썼습니다.) 배포는 간편하게 Vercel로 했습니다. 테스트를 해봤는데요 개발한건 좋은데, 페이지 로드가 빠르지 않다는 느낌이 들었습니다. 가장 처음 배포했던 버전 링크 성능을 객관적으로 측정해보고 어느 부분이 문제일지 확인하기 위해 Lighthouse로 검사해봤습니다. 외부의 영향을 최소화하기 위해 크롬 시크릿 모드에서 테스트를 진행했습니다.  보시다시피 성능 점수가 개선이 필요하다고 평가되는 점수대인 70점대를 기록하고 있었습니다. 보고서의 내용을 자세히 보니 이런 문제가 있었습니다.  성능 점수가 90점보다 높으면 '좋음' 평가를 받습니다. 이를 목표로 조금씩 개선해봤습니다. Time to Interactive 말 그대로 사용자가 웹페이지와 상호 작용이 가능한 시점까지 걸린 시간을 의미합니다. TTI 시간이 0.36초로 보통 수준이 나왔습니다. TTI에 특히 큰 영향을 미칠 수 있는 한 가지 개선 사항은 불필요한 JavaScript 작업을 연기하거나 제거하는 것입니다. JavaScript를 최적화할 수 있는 기회를 찾아보세요. 특히, 코드 분할로 JavaScript 페이로드를 줄이고 PRPL 패턴을 적용하는 방법을 고려하세요. 타사 JavaScript를 최적화해도 일부 사이트에서 상당한 개선이 이루어집니다. - Web.dev 상호 작용까지의 시간 내용중 발췌 이를 개선하기 위해서는 코드 분할을 활용해 JS 페이로드를 줄여야 합니다.  보고서에서도 이 방법을 추천해주고 있습니다. Lazy Loading 이를 위해 저는 React에서 제공하는 React.lazy를 사용하기로 했습니다. 리액트 18부터 정식 런칭된 기능으로, 다이나믹 import를 일반적인 컴포넌트처럼 쓸 수 있도록 해줍니다. 공식 문서에 있는 샘플 코드입니다. 이렇게 하면 해당 컴포넌트가 필요할 때가 돼서야 그 컴포넌트가 사용하는 코드를 로드하기 때문에 최초 접속 시의 로드 시간을 줄일 수 있습니다. (자세한 내용은 공식 문서의 내용을 참고해주세요.) 이를 활용해 아주 간편하게 lazy loading을 구현할 수 있었습니다. Router에서 아래처럼 사용했습니다. 개선 결과 Lazy Load 적용 후 배포 버전 링크 개선된 부분 성능 점수가 향상되었습니다. (77점 => 82점)TTI가 20% 개선되었습니다. (3.1s => 2.5s)Largest Contentful Paint 시간이 17% 감소했습니다. (3.6s => 3.0s)메인 코드의 크기가 32% 감소했습니다. (286.5KiB => 196.0KiB)Total Blocking Time이 20% 감소했습니다. (100ms => 80ms) Tradeoff 스크립트 요청 수가 1개에서 3개로 늘었습니다. 한 번에 받았던 스크립트 파일을 여러 파일로 나눠 받고 있는 것입니다. Largest Contentful Paint 개선할 점이 아직 남았습니다. Largest Contentful Paint가 3초를 기록했습니다. LCP는 Lighthouse에서 25%라는 큰 가중치를 주는 항목인데, 로드 시작 시점부터 페이지의 메인 콘텐츠가 로드됐을 가능성이 있을 때까지 걸린 시간을 말합니다. 즉 LCP는 사용자가 실질적으로 페이지를 사용할 수 있는 시점까지 얼마나 걸리는지를 측정하는 요소입니다. Lighthouse의 연구에 따르면 2.5초 ~ 4초는 중간 등급인 '개선 필요함'에 해당합니다. Share it!은 그럼 어디에서 페이지의 로드를 방해하고 있을까요? 보고서를 보니 이 부분들이 눈에 띄었습니다.    CSS는 Render Blocking Resource입니다. Share it!은 Pretendard라는 웹 폰트를 불러와 쓰고있는데, 이 폰트의 사이즈가 너무 크기에 폰트를 로드하는 CSS의 동작 시간이 길어졌고, 이게 브라우저가 화면을 그릴(paint) 때 필요한 CSSOM의 생성을 늦춘 것입니다. 개선하려면 네트워크를 더 빠르게 만들거나, 웹 폰트의 용량을 줄여야 하는데 네트워크를 개선할 수는 없으니 폰트의 용량을 줄이는 방향으로 생각해봤습니다. 서브셋 폰트 참고할만한 네이버 D2 글 저는 Pretendard에서 제공하는 서브셋 폰트를 적용했습니다. 서브셋 폰트는 한글의 모든 글자를 담는 대신 불필요한 글자를 제거하고 사용할 글자만 남긴 폰트입니다. 영어는 26개 알파벳으로 이루어져 있다. 영문 폰트에는 대소문자를 포함해 총 72자의 글자가 필요하다. 하지만 한글은 자음, 모음의 조합으로 구성되어 있다. 모든 경우를 조합하면 한글의 글자 수는 11,172자나 된다. 그래서 한글 폰트 파일은 영문 폰트 파일보다 용량이 크다. (...중략) 불필요한 글자를 폰트에서 제거하고 사용할 글자만 남겨 둔 폰트가 서브셋 폰트다. 글자의 개수가 줄었기 때문에 서브셋 폰트는 용량이 작다. - 네이버 D2 글 중 발췌 서브셋 폰트를 불러올 때 웹 폰트를 사용하지 않고 직접 웹서버에서 서빙하는 방식으로 변경했으며, 아래의 코드를 적용했습니다. font-display 프로퍼티를 swap으로 줘서 폰트 로드가 덜 됐을때도 글자는 보이게 했으며, src 프로퍼티에 fallback 폰트로 woff를 줘 woff2를 지원하지 않는 브라우저에서도 Pretendard 폰트를 쓸 수 있도록 했습니다. 거기에 더해, local을 최우선 src로 줘서 사용자의 기기에 이미 Pretendard가 설치돼 있다면 그걸 불러오도록 했습니다. (참고로 테스트 기기에는 해당 폰트가 설치돼있지 않습니다.) 개선 결과 폰트 최적화 후 배포 버전 링크 개선된 부분 성능 점수가 90점 위로 올랐습니다. (82점 => 91점)TTI가 40% 개선되었습니다. (2.5s => 1.5s)LCP가 40% 감소했습니다. (3.0s => 1.8s)FCP가 조금 줄었습니다.Total Blocking Time이 50% 감소했습니다. (80ms => 40ms)Network Payload의 크기가 대폭 감소했습니다. (3736KiB => 1628KiB) Tradeoff 폰트를 불러오는 Request Chain에서 Maximum Critical Path Laytency가 검사 할 때마다 널뛰기를 합니다. Vercel에서 제공하는 무료 웹서버의 한계인 것 같은데, 추후 CDN을 통해 배포하는 방식 등으로 개선할 필요가 있습니다. 결론 최종적으로 원하던 결과였던 90점 이상 맞기는 달성했습니다. 이후 웹 접근성 관련 문제들이나 잘못 작성된 마크업들을 수정해 아래의 결과를 얻을 수 있었습니다.  조금 더 나아가고 싶은 부분 성능과는 별개의 이야기지만, 동적으로 사용자들이 데이터를 올리는 커뮤니티 특성상 sitemap.xml을 어떻게 생성해줘야 할지 고민이 많이 됐습니다. 다른 서비스들은 이런 경우 sitemap을 어떤 식으로 생성하는지 궁금해서 찾아보니 사용자가 글을 올릴 때마다 새로운 sitemap을 생성한다고 하더라고요. 이 부분도 추후 더 개선해보고 싶습니다. "},{"slug":"멋사 프론트엔드 스쿨 11주차 회고","title":"멋사 프론트엔드 스쿨 11주차 회고","date":"2022-11-14","content":"4주만에 적는 회고록 회고 지금까지 있었던 일 연구실 업무로 열심히 개발하던 설문 웹페이지 드디어 완성했습니다.데모 페이지난관이 너무나 많았는데 완성하니 아주 뿌듯해요. TypeScript는 이제 많이 익숙해진 것 같아요.혼자 처음부터 끝까지 개발하는게 쉽진 않았지만 기존에는 잘 없던 특이한 유형의 설문조사를 구현했고, (슬라이더, 영상 선택 및 점수 부여하기 등 두가지 유형) Python으로 개발돼있던 복잡한 로직의 일관성 검사 로직을 TypeScript로 성공적으로 마이그레이션 해냈어요.이 일 때문에 정말 바쁘게 지냈는데, 막상 끝내고나니 뭔가 허전한...나름 여러가지 자잘한 코딩도 많이 했던거같아요. 확실히 4주 전보다 많이 성장했단게 느껴져요.멋사 팀 분배를 위한 테스트도 보고, 당근마켓 인턴도 지원해보고, 프로그래머스 데브매칭도 도전해봤어요. 아직 결과가 나온건 아무것도 없지만 모두 좋은 경험!! 데모 페이지난관이 너무나 많았는데 완성하니 아주 뿌듯해요. TypeScript는 이제 많이 익숙해진 것 같아요.혼자 처음부터 끝까지 개발하는게 쉽진 않았지만 기존에는 잘 없던 특이한 유형의 설문조사를 구현했고, (슬라이더, 영상 선택 및 점수 부여하기 등 두가지 유형) Python으로 개발돼있던 복잡한 로직의 일관성 검사 로직을 TypeScript로 성공적으로 마이그레이션 해냈어요.이 일 때문에 정말 바쁘게 지냈는데, 막상 끝내고나니 뭔가 허전한... 기억에 남는 일 팀원분들이 '저 덕분에 ~를 이해할 수 있었다' 같은 말을 해줄때 엄청 뿌듯했어요. 다른 분들께 제가 아는걸 설명하면서 저 자신도 개념을 정리하는게 저한테 잘 맞는 공부법인거같았는데, 회고조원들도 좋았다고 해주셔서 다행이에요. 아쉬웠던 점 아쉬운건 없어요! 매일 매일 성장하고 있다는 느낌이 드는 요즘입니다.굳이 꼽자면 코테 준비를 철저히 못한것...? 할 일과 다짐 코테 준비 열심히 계속하자!개인 프로젝트, 팀 프로젝트 모두 무사히 잘 진행될 수 있도록 열심히!!번아웃 조심하자. 몸은 엄청 피곤한듯... "},{"slug":"복잡하게 구성된 if문 리팩토링하기","title":"복잡하게 구성된 if문 리팩토링하기","date":"2022-11-05","content":"연구실 과제용 웹페이지 개발중 복잡한 모양의 if else 구문이 필요한 경우가 있었는데, 어떻게 하면 더 보기 좋은 코드가 될지 고민했습니다. 리팩토링할 코드 연구실 과제로 개발중인 설문 페이지에서는 사용자가 입력한 답안이 유효한지 여부를 판단하는 로직이 들어갑니다. 그 중, 숫자를 하나 받아 숫자의 크기에 따라 증감된 값을 리턴하는 함수가 필요했습니다. 실제 코드는 아래와 같습니다. numToChange라는 변수 하나를 가지고, 역수인지 여부를 판단 후 (역수라면 분모가) 1 ~ 9 범위 내에서 증감하도록 하는 코드입니다. 다중 if else문이 들어가는 탓에 보기에 굉장히 복잡합니다. 어떻게 하면 if else문을 제거하고 가독성을 높일 수 있을까요? 조건문 클린코딩 방법 리팩토링에 앞서 조건문과 관련된 클린코딩 기법, 설명들을 찾아봤습니다. 아래의 예제들은 Clean Code In A Nutshell에 있는 코드입니다. 단순한 조건문이라면 삼항 연산자를 사용하자! 단순한 조건문이라면 조건문을 사용하기보다 삼항 연산자로 바꿔쓰는게 좋습니다. 삼항 연산자는 다중으로 쓰지 말아요! 하나의 코드블록으로 이뤄진 다중 조건문을 피하자! 코딩을 하다보면 특정 값이 nullish한지 여부를 확인하는 로직이 자주 필요합니다. 이 때 하나의 코드블록 (if문 만으로 이뤄진)으로 구성된 다중 조건문을 작성하기 쉽상인데요, 이럴땐 아래의 테크닉을 사용하도록 합니다. 특정 조건이 다중 조건문에서 반복적으로 나오면 논리 연산자로 줄이자! 위 예제에서는 할인 여부를 판단하기 위한 조건문이 공통된 if 조건문을 가지고 있습니다. 이럴 경우 공통된 부분을 밖으로 빼고, &&과 || 연산자를 적절히 사용해 이렇게 간결하게 나타낼 수 있습니다. 복잡한 계산이 필요한 조건은 함수로 분리하자! 이 규칙에서 저는 '클린 코드란 코드를 줄이는 것이 아닌 가독성과 유지보수성을 향상시키고자 하는 과정'임을 알 수 있었습니다! 적용해보기 코드 전반부 클린코드 전 클린코드 후 코드 후반부 클린코드 전 클린코드 1단계 후 *단순한 조건문이라면 삼항 연산자를 사용하자!*는 법칙에 따라 아래처럼 바꿨습니다. 여전히 부족한 부분이 보입니다. 한번 더 리팩토링해보겠습니다. 클린코드 2단계 후 필요없는 변수(increasedElement, decreasedElement) 제거하고, 범위를 판단하는 부분을 배열로 변경해 구간 순서대로 직관적으로 볼 수 있도록 했습니다. 이 때, 배열 안에 수식이 위치하면 가독성에 문제가 생길것을 감안해 numToChange의 증감 값을 나타내는 increasedNum, decreasedNum 상수를 추가 선언했습니다. 또한, numToChange === 1인 경우 빠르게 결과를 리턴해 이후 이 경우의 수는 생각하지 않아도 되게끔 했습니다. 클린 코드가 문제가 아니다 이렇게 중첩된 조건문을 많이 제거하고, 꽤 '고급 기술처럼 보이는' 코드를 짰습니다. 그런데, 그래도 반복되는 코드가 계속 눈에 밟혔습니다. 내가 지금 비효율적인 로직을 짠게 아닐까? 그렇게 뚫어져라 쳐다보다가, 중요한 사실을 하나 깨달았습니다. 저 코드는 필요없는 판단을 포함하고 있었습니다. 문제를 발견한 부분은 이곳입니다. numToChange에 따라 숫자 범위마다 인덱스를 부여하고 incrementArr, decrementArr에 인덱스와 매치해 결과값을 얻고자 한 부분입니다. 하지만 잘 생각해보면 리턴의 increasedElement를 얻기 위해 필요한 판단은 numToChange >= 8 뿐입니다. 마찬가지로 decreasedElement를 얻기 위해 필요한 판단은 numToChange <= 2 뿐이고요. 이런 아이디어에 기반해 최종적으로 아래의 코드가 됐습니다. 완성된 함수의 전체적인 모습은 다음과 같습니다. 처음에 비하면 훨씬 간결한 모습입니다. 생각 정리 처음 리팩토링을 시작할 때는 조건문을 줄이는데에 치중했지만 그 과정 덕분에 로직의 중복되는 부분을 찾아 더 효율적인 코드를 완성했습니다. 그러나 다음에 다시 비슷한 코드를 마주친다면 무조건 if else를 줄이겠다는 시선으로 바라보기보다 중복되는 판단이 있지는 않은지를 중점적으로 찾아야겠다는 생각이 들었습니다. 다중 조건문에서 비슷한 코드가 반복된다면 분명 로직이 반복되고 있다는 뜻이라는걸 알았으니까요! "},{"slug":"filter를 주면 position fixed 동작이 달라져요!","title":"filter를 주면 position fixed 동작이 달라져요!","date":"2022-11-01","content":"블로그의 navbar를 리뉴얼하는 과정에서 다크모드 스위치에 부여한 position fixed가 navbar 기준으로만 동작하는 문제를 해결하고자 했습니다. 문제상황 블로그의 navbar 디자인을 아주 살짝 바꾸고 있었는데, 화면이 작아질 경우 다크모드 스위치의 위치를 뷰포트 우하단으로 옮기고자 아래의 스타일을 추가했습니다. 그런데 이상하게도 아래처럼 동작했습니다.  .darkmode-switch 요소가 뷰포트 기준이 아닌 navbar 기준으로 위치하고 있는 상황으로 보였습니다. .darkmode-switch 요소는 navbar의 자식 요소긴 하나, position: fixed; 를 부여하면 뷰포트 전체를 기준으로 위치하도록 할 수 있을 거라고 생각했는데, 왜 이런 일이 벌어진걸까요? MDN 문서를 확인해보자 MDN 문서 (position: fixed;) MDN 문서에 따르면 fixed는 뷰포트의 초기 컨테이닝 블록, 즉 루트 요소를 기준으로 배치되도록 하는 property가 맞습니다. 그러나, 이런 내용이 있습니다. 요소의 조상 중 하나가 transform, perspective, filter 속성 중 어느 하나라도 none이 아니라면 뷰포트 대신 그 조상을 컨테이닝 블록으로 삼습니다. (perspective와 filter의 경우 브라우저별로 결과가 다름에 유의) 블로그의 navbar에는 backdrop-filter: blur(15px) 가 부여돼 있었는데 이로 인해 원치 않은 동작을 일으킨 것입니다. 즉 아래같은 상황인거죠. 부모 요소에 filter property를 지정한 상황입니다. 아마 위 예제의 핑크 박스(.child 요소)의 위치가 브라우저별로 다르게 보일 것입니다. 테스트해보니 Blink 엔진에서는 .parent 안에 위치하고, Webkit 엔진에서는 우하단에 위치하는 것을 확인할 수 있었습니다. (크롬과 사파리로 각각 본 포스트를 열어 직접 확인해보세요!) 즉, Blink 엔진에서는 부모의 filter property가 none이 아닐 때 자식에 position: fixed;를 부여하면 부모를 컨테이닝 블록으로 삼기 때문에 생기는 문제였습니다. Webkit 엔진에서는 문제가 없겠지만 Blink 엔진에서도 제대로 동작해야 하기에 다른 방법을 사용해 해결해보기로 했습니다. 해결 아이디어 부모 요소에 backdrop-filter property를 부여한 것이 원치 않는 동작을 일으키는 원인이 됐으므로 이를 제거하고, backdrop-filter를 부여할 배경 역할의 가상 요소를 추가하면 해결될 것입니다. 해결 코드 새로 만든 가상 요소에 z-index: -1; 을 줘서 .navbar-container가 생성하고 있는 stacking context(쌓임 맥락) 기준으로 가장 밑에 위치하도록 했습니다. navbar 안의 다른 요소들과 가상 요소는 형제 관계에 놓이기 때문에 문제가 해결됩니다. 앞선 예제로 예를 들면 아래와 같은 코드가 될 것입니다. 이제 Blink 엔진에서도 .child 요소의 위치가 원하던대로 뷰포트 기준 우하단에 위치하고 있습니다. 결과  이제 원하던대로 잘 동작하네요! "},{"slug":"Next.js에서 Mixed Content 에러 해결하기 (feat. Proxy)","title":"Next.js에서 Mixed Content 에러 해결하기 (feat. Proxy)","date":"2022-10-31","content":"Mixed Content 에러를 알아보고 해결했습니다. 발생한 문제 연구실 업무로 개발중인 설문 웹페이지에서 마지막에 설문 결과를 서버로 보내는 부분이 아래의 에러를 뿜으며 동작하지 않는 문제가 발생했습니다. Mixed Content: The page at 'https://goodrider-interview-web.vercel.app/submitted' was loaded over HTTPS, but requested an insecure resource 'http://geodb.uos.ac.kr/api/driver/post/survey'. This request has been blocked; the content must be served over HTTPS. /submitted 경로에서 POST 요청을 HTTP 프로토콜로 열려있는 백엔드 서버에 날리는 과정이었는데요! 해석해보면 이런 내용인거죠. 요청을 날리는 웹은 HTTPS로 로드되고 있는데, 요청을 받는 웹은 보안이 취약한 HTTP 프로토콜로 이뤄져 있어서 내가 막아줬어! 보안을 걱정해주는건 고마운데, 곤란한 상황이죠. 백엔드의 API를 HTTPS로 제공하면 베스트겠지만 서버를 건드릴 수 없는 경우에는 어떻게 해결할 수 있을까요? Mixed Content가 뭐야? 우선 Mixed Content가 뭔지부터 제대로 알고 가는게 첫 단계입니다. MDN 문서 간단하게 말하면 HTTPS로 제공되는 웹페이지에서 HTTP 프로토콜로 받은 컨텐츠를 포함하고 있는 경우 이 컨텐츠를 Mixed Content라고 부릅니다. 이 경우 웹페이지는 부분적으로만 암호화돼있는 상태인거고, 결국 암호화되지 않은 부분은 미들맨 공격(man-in-the-middle attack)에 노출됩니다. HTTP와 HTTPS의 차이를 더 확실하게 알고 있다면 깊은 이해가 가능할 것 같아요. 간단하게 설명하면 HTTPS는 패킷으로 데이터를 주고받는 프로토콜인 HTTP에 중간에 패킷을 가로채 데이터를 가져가거나 수정하지 못하게 암호화 계층(TLS)을 추가한 프로토콜입니다. 어떻게 해결할까? - 프록시로 접근해보자. 다행히도 저는 이 오류를 접하기 전에 '프록시 서버(Proxy Server)'라는 개념을 알고 있었습니다. 프록시 서버는 서버와 클라이언트 사이에 위치하면서 클라이언트 대신 서버와 통신해 응답을 돌려주는 중간 서버입니다. CORS 문제, 보안상 이유 등으로 프록시 서버를 사용할 수 있습니다. 프록시 서버는 서버에 요청을 날릴 때 클라이언트에 관한 그 어떤 데이터도 제공하지 않기 때문입니다. 설문지 웹페이지는 Next.js로 개발됐기 때문에, Next.js 웹 서버 자체를 프록시 서버로 활용해 문제를 해결할 수 있을 것이라고 생각했습니다. 찾아보니 아래의 방법으로 프록시를 설정할 수 있다고 합니다. next.config.js next.config.js에 요청 path와 연결해야 할 URL을 이런 식으로 넣으면 됩니다. rewrite()라는 함수로 넣기 때문에 유동적으로 바꿀수도 있습니다. 위 설정을 통해 클라이언트는 https://goodrider-interview-web.vercel.app/api/post 라는 URL로 http://geodb.uos.ac.kr/api/driver/post/survey 라는 엔드포인트에 접근할 수 있게 됐습니다. "},{"slug":"멋사 프론트엔드 스쿨 7주차 회고","title":"멋사 프론트엔드 스쿨 7주차 회고","date":"2022-10-17","content":"코테 준비 본격적으로 시작한 주! 회고 이번 주에 있었던 일 연구실 업무가 막판에 몰려서 열심히 개발중입니다.지난주 회고를 작성하지 못한 이유도 연구실 + 멋사를 병행하다보니 정신도 없고 조금 지쳤었어요ㅠㅠ그래도 설문 페이지가 점점 완성도를 갖춰가고 있어서 뿌듯함을 느끼고 있습니다.Next를 활용해 개발하긴 했으나 오버스펙으로 개발한 것 같아서 조금 후회스럽기도 합니다.Tailwind CSS와 styled-components를 둘 다 사용하겠다는 바보같은 선택은 대체 왜 한건지!!설문자의 응답이 유효한지 여부를 검사하는 로직을 넣고, 백엔드에 결과를 전송하는 부분만 개발하면 마무리 될 듯 해요.백엔드를 맡은 친구가 제 시간 안에 완성해줄지 조금 걱정되네요.드디어 코테 문제를 풀어보기 시작했어요.일단은 프로그래머스 Lv.2만 쭉 풀어보고 있어요.풀리긴 하는데 뒤로 갈수록 시간이 늘어나고 있어요...ㅎㅎ 지난주 회고를 작성하지 못한 이유도 연구실 + 멋사를 병행하다보니 정신도 없고 조금 지쳤었어요ㅠㅠ그래도 설문 페이지가 점점 완성도를 갖춰가고 있어서 뿌듯함을 느끼고 있습니다.Next를 활용해 개발하긴 했으나 오버스펙으로 개발한 것 같아서 조금 후회스럽기도 합니다.Tailwind CSS와 styled-components를 둘 다 사용하겠다는 바보같은 선택은 대체 왜 한건지!!설문자의 응답이 유효한지 여부를 검사하는 로직을 넣고, 백엔드에 결과를 전송하는 부분만 개발하면 마무리 될 듯 해요.백엔드를 맡은 친구가 제 시간 안에 완성해줄지 조금 걱정되네요. 일단은 프로그래머스 Lv.2만 쭉 풀어보고 있어요.풀리긴 하는데 뒤로 갈수록 시간이 늘어나고 있어요...ㅎㅎ 기억에 남는 일 토요일에 GDSC Job Fair를 다녀왔어요. 여러 스타트업 부스 돌아다니면서 열심히 볼펜 수집해왔어요ㅋㅋ스타트업으로의 취업을 고려하고 있었는데 어떤 기준으로 기업을 바라볼지 저만의 관점을 찾을 필요성을 느꼈어요.코클(Cochl)이라는 기업의 인턴으로 지원해보고 싶다는 생각이 들었어요. 스타트업으로의 취업을 고려하고 있었는데 어떤 기준으로 기업을 바라볼지 저만의 관점을 찾을 필요성을 느꼈어요.코클(Cochl)이라는 기업의 인턴으로 지원해보고 싶다는 생각이 들었어요. 아쉬웠던 점 멋사 외적인 공부를 추가로 하지는 못했어요.연구실 업무를 마쳐야 하다보니 역대급으로 늦게잤어요. 매일 서너시에 자니까 낮에 수업도 졸고ㅠㅠㅠ 할 일과 다짐 계속해서 코테 꾸준히 풀어보자!!이번주는 그래도 조금이라도 일찍 자보자ㅠㅠ연구실 일 마무리짓자! 이번주에 정리한 내용 없음 😭 JS 과정 들어오니 블로그 글 작성할 거리도 잘 안보이네요...ㅎㅎ 빨리 웹브라우저 렌더링 과정 블로깅 해야하는데!! "},{"slug":"자바스크립트 동등 연산자(==)의 암시적 변환 작동 방식","title":"자바스크립트 동등 연산자(==)의 암시적 변환 작동 방식","date":"2022-10-05","content":"true == 'true'는 false인 이유가 뭘까요? 자바스크립트 동등 연산자(==)의 작동 방식을 제대로 알아봤습니다. true == 'true'는 false입니다. 딱 직관적으로 생각했을 때는 좌변은 true니까 참이고, 우변은... 비어있지 않은 String이니까 참이...고... 그러면 true? 라는 생각이 들 수밖에 없습니다. 근데 이 기가막힌 JS는 저희가 행복해지는걸 두고보지 않죠.  대체 왜 이런걸까요?? MDN 문서를 살펴보자 MDN 문서 (한국어 문서는 최신 내용이 아님에 유의해주세요.) ==는 느슨한(Loose) 의미의 같음을 비교하는 연산자입니다. 자바스크립트 엔진은 == 연산자를 만나면 내부적으로 일종의 '형 변환' 과정을 거친 후 비교합니다. 자세히는 이 순서대로 동작합니다 (동등 연산자 연산이 완료될때까지 계속 반복됩니다.): 양 변이 같은 타입이라면 ===(일치 연산자)처럼 동작합니다.객체라면 같은 객체여야만 trueString이라면 같은 순서대로 문자들이 놓여있을때만 trueNumber라면 같은 값일때만 true, 둘 중 하나라도 NaN이라면 false참고로 +0과 -0은 같은 값으로 취급됩니다.Boolean, BigInt이라면 같은 값일때만 trueSymbol이라면 같은 symbol을 reference하고 있을때만 true둘 중 하나가 null 혹은 undefined라면:나머지 하나도 null 혹은 undefined: true그 이외의 경우: false둘 중 하나가 객체이고, 다른 하나가 원시형이라면 toPrimitive(), valueOf(), toString() 등의 메서드들을 사용해 객체를 원시형 값으로 바꿉니다.객체를 원시형으로 바꾸는 과정은 조금 복잡할 수 있습니다. 자세한 과정은 여기를 참고해주세요!위 단계를 거쳤다면 이제 양 변이 모두 원시형 데이터인 상태일겁니다. 이 다음부터는 케바케로 동작합니다.양 변이 같은 타입이면 1번 방법을 따릅니다.둘 중 하나만 Symbol이라면 false둘 중 하나만 Boolean이라면 Boolean 데이터를 Number로 바꿉니다.Number vs String 꼴이라면 String을 Number로 바꿉니다.Number vs Bigint 꼴이라면 numberic 값을 비교합니다.Number가 Infinity 혹은 NaN이라면 falseString vs BigInt 꼴이라면 BigInt() 생성자로 String을 BigInt로 바꿉니다.형변환에 실패한다면 false 객체라면 같은 객체여야만 trueString이라면 같은 순서대로 문자들이 놓여있을때만 trueNumber라면 같은 값일때만 true, 둘 중 하나라도 NaN이라면 false참고로 +0과 -0은 같은 값으로 취급됩니다.Boolean, BigInt이라면 같은 값일때만 trueSymbol이라면 같은 symbol을 reference하고 있을때만 true 참고로 +0과 -0은 같은 값으로 취급됩니다. 나머지 하나도 null 혹은 undefined: true그 이외의 경우: false 객체를 원시형으로 바꾸는 과정은 조금 복잡할 수 있습니다. 자세한 과정은 여기를 참고해주세요! 양 변이 같은 타입이면 1번 방법을 따릅니다.둘 중 하나만 Symbol이라면 false둘 중 하나만 Boolean이라면 Boolean 데이터를 Number로 바꿉니다.Number vs String 꼴이라면 String을 Number로 바꿉니다.Number vs Bigint 꼴이라면 numberic 값을 비교합니다.Number가 Infinity 혹은 NaN이라면 falseString vs BigInt 꼴이라면 BigInt() 생성자로 String을 BigInt로 바꿉니다.형변환에 실패한다면 false Number가 Infinity 혹은 NaN이라면 false 형변환에 실패한다면 false 예시에 적용해보자 true == \"true\" 좌변이 Boolean이므로 Number로 바꿉니다.1 == \"true\";Number vs String 꼴이므로 String을 Number로 바꿉니다.1 == NaN;우변이 NaN이므로 false입니다. 2 == \"2\" Number vs String 꼴이므로 String을 Number로 바꿉니다.2 == 2;양 변이 같은 타입이므로 값을 비교하면 true입니다. "},{"slug":"멋사 프론트엔드 스쿨 5주차 회고","title":"멋사 프론트엔드 스쿨 5주차 회고","date":"2022-10-03","content":"드디어 JS 본격적으로 시작!! 회고 이번 주에 있었던 일 타스 집필팀 계획을 잡았습니다. 집필팀에서 기술 도우미(?)를 맡기로 했는데 도움이 될 수 있도록 더 열심히 해야겠네요!Sass 오류 잡고 공식 문서 contribution 도전하기: 알고보니 이미 공식 문서에 해당 내용이 있더라고요ㅎㅎ 비록 PR은 거절당했지만 좋은 경험이었습니다.이력서 특강에 맞춰서 수정하기천하제일 이력서 만들기 경진대회에 제출한 디자인을 바탕으로 내용을 채워봤습니다! 이력서 링크 각 기술별로 어떤것들을 할 수 있는지 서술도 추가하면 좋을 것 같아요.이력서 페이지 개발하면서 Tailwind를 처음으로 제대로 써봤는데 정말 신세계... 왜 좋다좋다 하는지 알 것 같아요.흐물이는 흐물흐물 캐릭터 만들기 (결과물) 천하제일 이력서 만들기 경진대회에 제출한 디자인을 바탕으로 내용을 채워봤습니다! 이력서 링크 각 기술별로 어떤것들을 할 수 있는지 서술도 추가하면 좋을 것 같아요.이력서 페이지 개발하면서 Tailwind를 처음으로 제대로 써봤는데 정말 신세계... 왜 좋다좋다 하는지 알 것 같아요. 기억에 남는 일 큰 오픈소스 프로젝트에 기여하기를 처음으로 도전해봤는데, 아쉽게도 실패했지만 정말 좋은 경험이었어요!! 다음엔 꼭 더 좋은 내용으로 기여해보겠습니다.캐릭터 경진대회, 이력서 경진대회 일정 안밀리고 잘 제출한점은 저 자신을 칭찬하고 싶어요. 아쉬웠던 점 집안일을 잘 못해서 집 상태가…개인 프로젝트나 개인 공부 등 멋사 외적인 활동을 거의 못한게 너무 아쉬워요ㅠㅠ 할 일과 다짐 뭐라도 시작해보자… 개인 프로젝트…!!!블로그 글 최소 두 개 이상 작성하기TS 책 집필 시작하기 영웅님께서 하신 말씀 중 '열심히 사는 것'과 '잘 사는 것'은 다르다는 말이 기억에 남아요. 지금까지 바쁘게만 해오고, 잘 하진 못한게 아닌가 다시 한번 돌아보면서 이번주부터는 바뀌어보려고 합니다!! 이번주에 정리한 내용 SVG 사용법 정리내용이 너무 부실하고 실속없어서 추후 글을 좀 보완해야 할 것 같아요. 과제하면서 제 글만 참고하고 해보려고 했더니 별로 도움이 안되더라고요.Sass 버전에 따라서 Equality Operator의 작동 결과가 달라진다? 내용이 너무 부실하고 실속없어서 추후 글을 좀 보완해야 할 것 같아요. 과제하면서 제 글만 참고하고 해보려고 했더니 별로 도움이 안되더라고요. "},{"slug":"Sass 버전에 따라서 Equality Operator의 작동 결과가 달라진다","title":"Sass 버전에 따라서 Equality Operator의 작동 결과가 달라진다?","date":"2022-09-29T18:09:00+09:00","content":"Sass를 공부하던중 저 혼자 Equality Operator의 작동 결과가 다른것을 알게 됐습니다. 문제 아주 간단한 코드입니다. 전자의 경우 당연히 true가 나와야 할 것이고, 후자의 경우에도 true가 나오는게 당연할거라고 생각했습니다. 공식 문서에는 true라고 돼있습니다. 그런데...  보시다시피 @debug 1 != 1px;가 false가 나오고 있습니다. 1 == 1px 이라고...?? 버전을 체크해보자  제가 사용한 node-sass의 버전입니다. node-sass는 7.0.3으로 최신 버전이 맞는데, 밑에 libsass라는 Sass Compiler의 버전이 3.5.5라고 나와 있습니다. LibSass 버전 3.6.5 변경사항 LibSass는 Sass 코드를 컴파일 할 수 있는 컴파일러로, C와 C++로 만들어진 라이브러리입니다. 즉 node-sass는 libsass의 도움을 받아 .scss 코드들을 .css로 변환해주고 있는 것입니다. (node-sass를 wrapper(=implementer)라고 부르는 이유입니다.) LibSass Repo 그런데 위 레포지토리를 보면, 가장 최신 버전은 21년 5월에 올라온 버전 3.6.5 입니다. 대체 어떤게 달라졌기에 3.5.5에서는 1 == 1px이라고 했다가, 1 != 1px로 바뀐걸까요? 버전 3.6 대의 Changelog를 한번 살펴보다가 버전 3.6.5의 수정 내역중 이런 문구를 발견했습니다.  밑에서 네번째 줄에 보시면 Fix edge case regarding unit-less number equality as object keys 라는 문구가 있습니다. 해석하면 '단위가 없는 숫자의 동일성을 객체의 키로 인식하는 edge case 수정' 정도가 될 것 같습니다. (edge case란 디버깅 혹은 단위 테스트에서 사용되는 용어로 여기에서는 '특이 케이스'정도로 생각할 수 있겠습니다.) 제 레벨에서는 이해하기 어려운 문제이지만, 일단 조금 읽어본 바로는 Sass 컴파일러 내부에서 unordered map 형식의 데이터는 equality check에서 hash 싱크 체크를 건너 뛰는 문제가 있는 것 같았습니다. 관련 issues 이슈 넘버 3094 이슈 넘버 1667 그러다보니 한 쪽이 unit-less일 경우 반대쪽의 단위로 이상한걸 막 써놔도 숫자만 같으면 같다고 판단해버립니다...  결론: Dart Sass를 쓰자 저같은 초보는 깊게 이해할 수는 없으니 'LibSass 버전 3.6.5에서 Equality Operator 관련 변경사항이 있었구나' 정도만 알고 넘어가도 좋겠습니다. 다만, 이 과정에서 또 알게된 중요한 사실은 LibSass가 deprecated 됐다는 점입니다. Sass 공식 문서에서는 Dart Sass를 이용할 것을 권장하고 있습니다.  Mac에서 Dart Sass 설치하기 공식 문서 저는 MacOS 환경을 사용하고 있으므로, 공식 문서에서 소개하고 있는 홈브루를 이용하는 방식으로 설치할 수 있습니다. 홈브루가 설치돼 있다면 간단하게 이렇게만 입력하면 끝입니다. Ruby Virtual Machine (RVM)이 설치된 환경이라면 ruby-sass를 모든 가상환경에서 지워줘야 합니다! ruby-sass도 deprecated 됐습니다. 가장 최근 버전은 1.55.0입니다!  package.json의 scripts를 아래와 같은 형식으로 변경하고 이제 아래의 코드를 다시 돌려보면...  짜잔~! 이제 잘 나오네요! 🙌🙌 Sass 공식문서 Contribution도 노려봤습니다 sass-site 레포지토리에 issue 올리고 PR 날려봤습니다. 어떻게 될지는 모르겠지만 이렇게 대형 프로젝트에 기여해보려고 한건 처음이라 두근두근 하네요! 10/4 업데이트: PR 실패ㅠㅠ 알고보니 해당 내용이 이미 공식 문서에 토글 버튼으로 숨어있더라고요ㅎㅎ 비록 성공하지는 못했지만 좋은 도전이었고 앞으로 오픈 소스 기여에 계속 도전해보겠습니다!! "},{"slug":"SVG 사용법 정리","title":"SVG 사용법 정리","date":"2022-09-27T18:09:00+09:00","content":"Scalable Vector Graphics의 사용법을 간략하게 정리했습니다. SVG, Scalable Vector Graphics XML 기반의 2차원 벡터 그래픽으로, HTML 요소로 이뤄져 있어 CSS와 JavaScript로 컨트롤 할 수 있습니다. 벡터이기 때문에 확대해도 깨지지 않으며 크기를 키워도 용량이 늘어나지 않습니다. 코드로 이뤄진 이미지이기 때문에 복잡할수록 사이즈가 기하급수적으로 커집니다. 단순한 아이콘이나 로고, 도형 등을 구현할 때 많이 사용합니다. 사용법 <img> 요소로 넣기CSS background로 넣기인라인으로 구현하기: SVG 코드를 그대로 HTML 안에 넣습니다.<object> 요소 사용하기: 아래처럼 <object> 요소로 넣으면 내부 요소에 접근할수도 있습니다. 내부 요소 조작이 필요하면 3, 4번 방법을, 그렇지 않다면 1, 2번 방법을 사용하면 됩니다. SVG 컨트롤 하기 SVG 코드를 이루는 요소는 당연히 class를 부여할 수 있습니다. 이렇게 부여한 class를 가지고 CSS를 이용해 스타일을 줄 수 있습니다. "},{"slug":"멋사 프론트엔드 스쿨 4주차 회고","title":"멋사 프론트엔드 스쿨 4주차 회고","date":"2022-09-25","content":"벌써 한 달이나 지났네요... 시간 참 빠르다 회고 이번 주에 있었던 일 이번주에는 글을 많이 쓰지는 못했어요. 점점 시간이 부족해지네요...매일 커밋하지는 못했지만 알차게 공부했으니 후회는 없어요!처음으로 멋사 동료분들을 오프라인에서 만나뵀어요.금요일에는 회고조 조장 커피챗 모임을 하고 처음으로 페어 프로그래밍을 해봤어요. 멋사 직원분들 직접 뵈니까 좋았어요! 페어 프로그래밍도 잘 될까 걱정이 많았는데 다들 너무너무 잘 적응해주셔서 보람있는 시간이었어요.토요일에는 회고조 분들과 회식을 했어요. 치킨 먹고 보드게임 카페를 갔는데 다들 훨씬 친해진 것 같아요. 다음번엔 술을...ㅋㅋㅋ인터넷 친구같은 느낌이었는데 얼굴 보니까 좋네요! 금요일에는 회고조 조장 커피챗 모임을 하고 처음으로 페어 프로그래밍을 해봤어요. 멋사 직원분들 직접 뵈니까 좋았어요! 페어 프로그래밍도 잘 될까 걱정이 많았는데 다들 너무너무 잘 적응해주셔서 보람있는 시간이었어요.토요일에는 회고조 분들과 회식을 했어요. 치킨 먹고 보드게임 카페를 갔는데 다들 훨씬 친해진 것 같아요. 다음번엔 술을...ㅋㅋㅋ인터넷 친구같은 느낌이었는데 얼굴 보니까 좋네요! 기억에 남는 일 과제를 할 때 마크업을 꽤 심도있게 고민하는 내 모습을 보고 뿌듯했어요. 한 달 전까지만 해도 아무 생각 없이 하던 부분인데 이해하고 내 것으로 만들어나가니 불안감이 점점 해소되는 것 같아요.페어 프로그래밍 경험이 정말 좋았어서 정기적으로 해보고 싶을 정도!! 아쉬웠던 점 공부한 내용을 잘 정리하지는 못한 것 같아요. 딥다이브도 공부할 시간을 내기가 쉽지 않네요ㅠㅠ코어 자바스크립트 공부는 일단 보류하기로 했어요. 당장 딥다이브 공부할 시간도 내기 힘들고, 코어 자바스크립트는 나중에 JS를 더 깊게 공부한 뒤에 다시 보면 좋을 내용같았어요. 다음주 할 일과 다짐 자바스크립트 딥다이브 조금이라도 공부하기코테 문제 조금이라도 풀기 이번주에 정리한 내용 CSS 실무 테크닉 "},{"slug":"CSS 실무 테크닉","title":"CSS 실무 테크닉","date":"2022-09-22T16:37:00+09:00","content":"실무에서 사용되는 여러 CSS 테크닉들을 익혔습니다. <input> 요소 체크박스 바꾸기 <select> 요소 커스터마이징 <select> 요소는 스타일링이 까다로워 아얘 따로 구현합니다. 다만, 모바일에서는 OS마다 형태가 매우 다르기 때문에 <select> 요소를 그대로 사용합니다. 스타일중 중요한 부분만 떼서 보겠습니다. .btn-select에 이런 property와 value를 부여해서 컨텐츠가 길어지면 ...으로 줄이도록 합니다. 같은 코드가 <option> 역할을 하는 <button> 요소에도 들어있습니다. 버튼 옆에 있는 삼각형 이미지는 background-image로 넣고, .on 클래스가 붙으면 바꿔줍니다. <article> 요소에 position: relative;를 주고 ul.list-selectives에 position: absolute;를 줘서 확실하게 <article> 요소에 붙도록 만들어줍니다. absolute 부분은 밑에 위치할 요소 위로 올라가게 되므로 활성화돼도 레이아웃이 깨지지 않도록 합니다. .btn-select에 .on 클래스가 붙으면 .list-selectives의 display property를 block으로 바꿔 보일 수 있도록 합니다. IR(Image Replacement) 테크닉 스크린리더나 브라우저를 위해 정보를 전달하는 텍스트를 넣으면서 디자인적으로는 보이지 않도록 하는 스타일입니다. 재현님이 추천하신 글 글 내용중 opacity property를 0으로 주면 스크린리더가 읽지 못한다는 말이 있는데, 현재는 읽어주는 것으로 확인됩니다. 이렇게 인터넷에서 얻는 정보들은 진위여부를 잘 알아봐야 합니다. 카카오 이미지 내에서 의미있는 텍스트의 대체 텍스트를 제공할 때 text-indent: -9999px;때문에 브라우저는 어찌됐든 -9999px까지 그려야 한다는 단점이 있습니다. (다만 성능 저하를 실제로 불러오는지에 대해서는 근거가 없다고 합니다.) 현재는 잘 사용하지 않습니다. 스크린리더가 읽을 필요는 없지만 마크업 구조상 필요한 경우 스크린리더는 width와 height가 0이라면 읽지 않는다는 점을 이용한 방법입니다. 이미지가 나오지 않을 때에도 대체 텍스트를 보여주고자 할 때 현재 카카오가 가장 많이 사용하는 방법입니다. 이미지가 나오지 않을 때 대체 텍스트를 보여주고자 하는 때란 언제를 말하는걸까요? 자주 쓰이지 않는 폰트로 구성된 문구 등이 들어가면 sprite 등의 기법을 써 이미지로 처리하는데, 이 때 이미지가 로드되지 않아도 텍스트가 보일 수 있도록 하기 위해 사용합니다. 네이버 IE 구버전에서는 인식하지 못하는 경우가 있기 때문에 margin: -1px;을 넣는다고 합니다. clip property를 이용해 요소를 잘라내기도 합니다. clip은 position: absolute;가 부여된 경우에만 사용할 수 있습니다. clip은 deprecated property이기 때문에 대체재인 clip-path: inset(50%);를 추가로 넣는것도 좋다는 강사님 의견이 있습니다. 쿠팡 애플 네이버와 비슷한 방법을 사용하고 있습니다. border, padding property도 지정해줘서 조금 더 범용성있게 사용하고자 한 듯 합니다. 에어비엔비 aria-label이라는 웹 접근성을 위한 최신 attribute를 사용하거나, 네이버와 비슷한 방법을 사용하고 있는것이 확인됩니다. 레거시 브라우저를 위해 조금 더 철저히 코드를 추가한 것을 볼 수 있습니다. CSS Sprite 기법 여러 조그마한 이미지를 하나의 이미지 파일에 모아 이미지 로드 부담을 줄이는 기법입니다.  이렇게 로드해온 이미지를 가지고 CSS에서 background-image로 적당히 잘라(position, width, height 이용) 사용하는 식입니다. CSS Sprites Generator Sprite 기법을 사용할 때 유의점 Sprite가 너무 크면 '판' 자체의 로드가 부담을 가해 여러 군데의 로드가 늦어질 수 있다는 문제가 있습니다. 변경사항이 있을 경우 수정이 까다롭다는 점도 단점중 하나입니다. 따라서, Sprite가 너무 커지지 않도록 무조건 한 '판'으로 모으기보다는 적절히 나누는것도 필요합니다. 추후 Webpack으로 해결이 가능한 문제이기도 합니다. Webpack은 이미지를 data format (base64) 으로 디코딩해 삽입해줍니다. 레티나 디스플레이 대응법 레티나 디스플레이는 화소 밀도가 높은 디스플레이(300PPI 이상)를 부르는 애플 LCD 제품의 브랜드 이름입니다. 고해상도 화면으로 기술이 발전하며 논리적 픽셀(CSS에서 표현하는 화소의 기본 단위)과 물리적 픽셀의 차이가 발생하게 됐습니다. 브라우저는 CSS에서 정의한 픽셀만큼 이미지를 렌더링하기에 원래 물리적 픽셀에 맞게 렌더링된 이미지가 논리적 픽셀의 크기만큼 커져버리게 됩니다. 화면에 그리고자 하는 이미지 사이즈의 두 배 되는 이미지를 넣으면 해결할 수 있습니다. 대신 이 때는 이미지의 사이즈를 조절하는 과정을 거쳐야 합니다. 예전에는 모바일의 경우 레티나 화면과 아닌 화면을 분리해서 개발했지만, 요즘엔 다 좋아져서 굳이 구분하지는 않는다고 합니다. "},{"slug":"멋사 프론트엔드 스쿨 3주차 회고","title":"멋사 프론트엔드 스쿨 3주차 회고","date":"2022-09-18","content":"뭔가 뿌듯했던 셋째주였어요! 회고 이번 주에 있었던 일 1만 시간의 법칙 과제를 하고 유진님께 받은 피드백으로 고쳐나갔습니다.정말 좋은 경험이어서 아주 자세히 글을 써봤어요!시간이 너무 많이 걸려서 앞으로 어떤 식으로 기록할지 고민됩니다.회고조 활동에 대해 여러모로 많이 고민해보고 회의했어요!매일 커밋 ✅맨날 미루는 성격을 이겨내고 과제를 일찍 마무리했어요 👏함께 자라기 스터디를 했는데 좋은 바이브를 얻어갈 수 있었어요.스터디에서 배운 내용중에 실수 기록을 작성하기 시작했어요. 아직 많이 쌓이지는 않았지만 실수, 삽질, 하마터면 사건들을 많이 기록하려고 해요.코어 자바스크립트 스터디에 들어갔어요! 정말 좋은 경험이어서 아주 자세히 글을 써봤어요!시간이 너무 많이 걸려서 앞으로 어떤 식으로 기록할지 고민됩니다. 스터디에서 배운 내용중에 실수 기록을 작성하기 시작했어요. 아직 많이 쌓이지는 않았지만 실수, 삽질, 하마터면 사건들을 많이 기록하려고 해요. 기억에 남는 일 금요일 특강을 해주신 이수진 개발자님께 용기내서 페어프로그래밍 요청 드려봤어요! 10월중에 하기로 했는데 정말 기대돼요.게더타운에서 게임을 많이 했는데 다들 목소리 들으니까 좋았어요ㅎㅎ 아쉬웠던 점 지난주에 계획했던 운동은 상상도 못했어요... 너무 힘들어...블로그 글을 열심히 작성한건 좋은데 너무 시간을 많이 쏟은 것 같아요. 조절좀 해야겠습니다. 다음주 할 일과 다짐 자바스크립트 딥다이브 10장까지 나가기코어 자바스크립트 공부 계획 세우기페어 프로그래밍 해보기: 멋사분들과 페어프로그래밍 직접 해보고싶어요! 이번주에 정리한 내용 딥다이브 시작: 자바스크립트 intro딥다이브 4장: 변수딥다이브 5장: 표현식과 문1만 시간의 법칙 반응형 웹 개발 및 피드백 "},{"slug":"1만 시간의 법칙 반응형 웹 개발 및 피드백","title":"1만 시간의 법칙 반응형 웹 개발 및 피드백","date":"2022-09-15","content":"멋사 프론트엔드 스쿨에서 받은 과제를 어떻게 해결했는지 기록했습니다. 디자이너의 시안을 그대로 코드로 옮기는 실무에 가까운 일은 처음 해봤는데 정말 좋은 경험이었습니다. 1만 시간의 법칙 과제  디자이너가 작성해준 Figma 시안을 보고 반응형 웹을 구현하는 과제입니다. 혼자 구현해보고 멘토님의 피드백을 받아 고쳤는데 그 내용을 기록해보려고 합니다!! 레포지토리 결과물 (Github Pages로 배포됨) 결과물 전체적인 구조 HTML 우선 <head> 요소에서 <link rel=\"icon\" type=\"image/x-icon\" href=\"./img/favicon.ico\" />를 이용해 파비콘을 추가하고, 기본 PC 스타일, 모바일 환경을 위한 스타일을 따로 불러줍니다. <header>에는 <h1>이 들어가고, <body>는 세 개의 <section>들로 나눠줬습니다. modal 창을 위한 <div> 요소를 <footer> 요소 아래에 배치했습니다. 호준 강사님께서 추천하신 방법입니다. 마지막으로는 스크립트를 불러옵니다. CSS 전체적으로 스타일을 어떤식으로 구현해야 효율적일지 고민했습니다. 스타일링 수정이 편하도록 property를 적는 순서 컨벤션을 정해서 작성했습니다. 조금 귀찮은 컨벤션이지만 잘 정해서 작성하니 코드를 관리하는데에 큰 도움이 됐습니다.1. `position`, `display`, `align`, `visibility`2. `width`, `height`3. `margin`, `padding`, `border`, `box-sizing`4. `text-align`, `font`, `line-height`5. `color`, `background-color`6. `background-image`7. `animation`, `opacity` 등 기타CSS Selector를 어떤 식으로 작성할지 고민했는데, 일단 class 이름은 BEM을 따라서 정하기로 했습니다. 또한 단순히 class 이름만으로 요소를 선택하기 보다는 '어떤 요소에 대한 스타일인지' 추가적인 정보가 필요하다면 요소명을 붙여줬습니다. (예를 들어 .title 보다는 img.title을 사용하는 식)사용자의 선택에 따라 글씨 크기를 조정할 수 있도록 함과 동시에 유지보수성을 높이기 위해 font-size 등 일부 property는 px이 아닌 rem/em 단위를 사용했습니다.주요 색상을 CSS 변수로 선언해 추후 편리하게 색상을 변경할 수 있도록 했습니다.:root {  --main-color: #5b2386;  --second-main-color: #ffff;  --sub-color: #babcbe;  --point-color: #fcee21;  /* 위에서부터 차례로 보라색, 흰색, 회색, 노란색입니다. */} <body> 요소에 공통적인 스타일을 해주며 코드가 시작됩니다. CSS 파일 구조 index.css: PC 스타일을 주로 담으며, 모바일용 스타일시트를 제외한 다른 모든 스타일이 모이는 곳입니다.reset.css: User Agent Stylesheet를 리셋합니다.font.css: 웹폰트를 불러옵니다.tools.css: margin: auto;같이 자주 쓰이는 스타일을 class로 묶어둔 스타일시트입니다.general.css: <button>, <input> 요소처럼 컴포넌트 단위로 자주 쓰이는 스타일을 모은 곳입니다.mobile.css: 모바일용 스타일이 담깁니다. reset.css: User Agent Stylesheet를 리셋합니다.font.css: 웹폰트를 불러옵니다.tools.css: margin: auto;같이 자주 쓰이는 스타일을 class로 묶어둔 스타일시트입니다.general.css: <button>, <input> 요소처럼 컴포넌트 단위로 자주 쓰이는 스타일을 모은 곳입니다. 모바일용 스타일 코드는 대부분이 크기를 조절하거나 margin을 바꾸는 코드여서 여기에선 특별한 경우가 아니라면 설명하지 않겠습니다. 실제 코드를 더 자세히 보고싶다면 레포지토리를 확인해주세요! tools.css <header> 요소 <h1> 요소 구현 결과  HTML <img> 요소의 srcset, sizes attribute를 이용해 Viewport 크기에 따라 유동적으로 이미지를 로드하도록 구현했습니다. 타이틀 이미지의 alt를 \"1만 시간의 법칙 타이틀\"로 할지 \"1만 시간의 법칙\"으로 할지 고민하다가 스크린 리더를 감안해 이렇게 결정했습니다. 배경이 되는 clock.png를 담은 <img> 요소에는 alt를 비워서 스크린 리더가 무시하도록 했습니다. CSS 중첩은 이렇게 처리하고, 이미지의 가운데 정렬은 .centering { margin: 0 auto; }로 줬습니다. 타이틀 아래(under)에 위치하는 시계 이미지에 .img-flow-root { display: flow-root }를 줘서 Inline element로서 baseline에 영향받는 부분을 없앰과 동시에 .centering 스타일이 유효할 수 있도록 해줬고, 로고에 해당하는 .title__img는 position: absolute;에 .centering을 줘서 정렬했습니다. 이미지에 position: absolute;를 주면 display property는 자동으로 block으로 바뀝니다! 그래서 별다른 스타일을 추가로 주지 않아도 .centering에 영향받아 가운데 정렬이 가능한거죠. 멘토님 Feedback 요약하면 로고 뒤의 시계 이미지를 background-image로 표현할지 제가 원래 했던 것처럼 <img> 요소를 중첩시켜 표현할지의 문제였습니다. 이호준 강사님: 로고 전체가 백엔드에서 조작이 가능한 동적인 요소로 만들어야 한다고 판단한다면 <img> 요소로 넣어야 한다는 의견김유진 멘토님: 사용자에게 필요하지 않은 정보로 보이는 부분은 background-image로 판단한다는 의견 개인적인 판단에는 로고가 바뀐다면 배경 이미지도 동시에 바뀔거라고 생각해 일단은 그대로 두었습니다. 실무였다면 디자인/PM과 의논해 해결할 수 있는 부분이라고 생각합니다. 아예 로고/배경을 두 파일로 나눠 넣지 말고, 배경 이미지까지 하나의 이미지로 합쳐서 로고로 넣는것도 깔끔한 해결책이 아닐까 생각합니다. <main> 요소 격언 <section> 구현 결과  HTML 우선 격언과 정의 부분을 하나의 섹션으로 봤습니다. 시멘틱을 위해 <h2>요소를 넣고 .blind 클래스로 가려줬습니다. 격언은 <blockquote> 요소로 처리했습니다. <p>요소 안에서는 1만 시간의 법칙을 설명하고 있으므로 <dfn> 요소를 한번 사용해봤습니다. 줄바꿈을 어떻게 처리하는게 좋을지 고민하다가 <br> 요소를 썼지만, 스타일을 통해 구현하는것도 좋은 방법이 될 것 같습니다. (그래서 아래에서 다른 방법을 사용해보기도 합니다.) CSS .quote-wisdom의 경우 수업중에는 폰트 로드 시간 문제로 많이 쓰이지 않는 폰트이니 이미지로 처리하는 것을 고려해봐야 한다 해주셨지만 우선은 폰트를 로드해 Text node로 구현했습니다. modal에서도 쓰이는 서체이므로 앞으로 더 사용될 수 있는 폰트라고 봤습니다. <blockquote>는 Block-level element이므로 .text-centering { text-align: center; }를 줘서 Text node의 가운데 정렬을 구현했습니다. p.rule-definition에서는 큰따옴표 이미지를 background-image로 표현했습니다. 입력 <section> 구현 결과  HTML 우선 두 <input> 요소들은 각각 한 줄씩 그 주위 텍스트들과 함께 <p> 요소로 묶었습니다. 둘 다 required attribute를 부여해서 반드시 입력해야 하게끔 유효성을 검사합니다. 몇 시간씩 훈련할지 입력하는 두번째 <input> 요소에는 pattern=\"[0-9]*\\.?[0-9]*.*\" attribute를 넣어서 시간이 제대로 입력됐는지 정규표현식으로 유효성을 확인하도록 했습니다. 모바일에서의 개행을 고려해 특정 Text node들은 <span>으로 묶었습니다. 노란 입력 제출 버튼은 페이지 내 로직의 작동을 일으키는 역할을 하므로 <button> 요소를 사용했습니다. (<button>의 default type은 submit이므로 타입을 따로 지정하지는 않았습니다.) 이 부분에서 손가락 이미지를 어떻게 구현할까 고민하다가 <button>과 <img>를 감싸는 <div>를 추가해 손가락 <img>에 position: absolute;를 부여, 위치를 조정하고자 했습니다. CSS CSS에서 복잡한 부분은 없었지만, .rule-form__btn과 .click-icon의 위치를 이렇게 표현하는게 과연 맞는 선택일까 고민이 됐습니다. 두가지 종류의 interactive element style 앞서 루트 요소에 색을 CSS 변수로서 선언한 점을 감안해 클래스명을 지었습니다. CSS (Mobile)  개행이 일어나는 부분 처리 앞서서는 <br> 요소로 개행을 구현했는데, <span>으로 묶은 요소에 display: block;을 줘 개행하는것도 좋은 방법인 것 같습니다. interactive elements들 스타일 모바일에서는 둥글둥글했던 interactive element가 네모난 모양으로 바뀌는데, 모바일용 스타일이 적용되는 클래스를 따로 정의해줬습니다. mobile.css가 더 나중에 로드되도록 <link> 요소를 배치하고 클래스를 미리 부여해서 break point를 넘어서면 모바일의 스타일이 적용됩니다. break point를 780px로 잡은 이유는 PC 화면에서 가장 width가 긴 부분이 약 760px정도 됐기 때문입니다. 멘토님 Feedback 우선 <label>을 어떻게 넣을 것이냐...는 굉장히 까다로운 문제인 것 같습니다. 이렇게 <label>을 무엇으로 지정할지 명확하지 않은 상황에서는 어떤 방법이 좋을지 차차 고민해 봐야겠습니다. 우선은 스크린 리더로 테스트 해본 결과 (개인적인 생각에는) 그대로 가도 문제 없어보여서 건들지는 않았습니다. 두 번째 <input>의 type을 text로 한 이유는 예시가 '5시간' 이였기 때문입니다. 정규표현식으로 소수를 포함한 숫자만 빼오고 뒤에 위치하는 '시간' 텍스트는 무시하도록 했는데, 유진 멘토님께서 '시간5'처럼 텍스트를 앞에 쓸 경우엔 오류가 발생함을 짚어주셨습니다. 정규표현식은 공부를 더 열심히 해봐야겠습니다. .click-icon 부분은 구현을 너무 더럽게 한게 아닐까 고민이었는데 멘토님께서 딱 집어 좋은 대처방안을 제시해주셨습니다. Resolve 조언 주신대로 두 번째 <input>의 type을 number로 변경했습니다.<p class=\"rule-form__txt\">  <span>그래서 앞으로 매일 하루에</span  ><input    class=\"rule-form__input input-main-colored rule-form__input-hours-js\"    type=\"number\"    placeholder=\"예)5시간\"    required  />시간씩 훈련할 것이다.</p>클릭 아이콘을 CSS의 pseudo element로 변경했습니다.<button class=\"rule-form__btn btn-point-colored btn-squared-mobile\">  <span>나는 며칠 동안 훈련을 해야</span> 1만 시간이 될까?</button><!-- img 요소 삭제 --><!-- 손가락 모양은 CSS 가상 요소로 넣습니다. -->.rule-form__btn {  margin-top: 115px;  position: relative;}.rule-form__btn::after {  content: url(../img/click.png);  position: absolute;  left: calc(100% + 7px);  top: 14px;} 결과 확인 <section> 구현 결과  HTML <button>과 <a> 모두 Inline elements이므로 text-align: center;를 이용해 가운데 정렬하기 위한 <div> 요소를 추가했습니다. <button>들의 좌 우측에 각각 margin:auto;를 주는것도 방법이 될 수 있겠지만 이게 더 간편하다고 생각했습니다. 과제를 하면서 이렇게 CSS를 줄일지, 마크업을 줄일지 고민이 되는 부분이 많았습니다. \"훈련하러 가기\"는 modal 창을 띄우고, \"공유하기\"는 페이지의 URL을 복사하는 <button> 요소로 봤습니다. \"공유하기\" <button>에서는 data-copiedlink라는 data-* attribute를 추가해 URL을 넘기도록 했습니다. 이걸 JS에서 받아서 사용할겁니다. CSS section.result에서 line-height property의 값을 크게 줘서 사용자가 긴 목표를 입력했을 경우에도 적당한 줄간격을 가지도록 한 부분이 포인트입니다. .result__txt에 max-width를 준 부분도 눈여겨 볼만 합니다. 멘토님 Feedback 🙌🙌 좋은 선택이었던 것 같아요ㅎㅎ <footer> 요소 위니브 로고와 저작권 정보 부분 구현 결과  HTML CSS modal 창 구현 결과  뒷 배경에 블러처리를 해줬습니다! HTML .cheerup-modal__wrapper가 화면 전체를 뒤덮게 해서 거기에 블러처리를 하려고 했습니다. \"종료하고 진짜 훈련하러 가기\" <button> 요소가 위니브 홈페이지로 가는 링크라고 생각하고 뒷 배경을 누르면 modal 창이 닫히게 하려고 했는데, 모바일에서는 뒷배경이 거의 남지 않는 문제가 있어 modal창 자체를 누르면 닫히게 했습니다. 실무였다면 디자이너와 협의해 닫기 버튼을 추가하는 등의 시도를 해도 좋을 것 같습니다. CSS .cheerup-modal__wrapper가 화면 전체를 감싸도록 했으므로 .cheerup-modal에서는 position: fixed;와 top, left를 50%로 줘서 .cheerup-modal의 좌상단을 Viewport의 가운데로 맞춘 후, transform proprerty를 이용해 창 자체가 가운데로 올 수 있도록 합니다. JS에서 .activated 클래스를 부여하거나 삭제해 애니메이션을 구현하고자 했습니다. 멘토님 Feedback 멘토님 HTML, CSS 총평 JavaScript 로직이 필요한 부분의 구현을 위해 간단한 스크립트를 작성했습니다. 참고로 JS상에서 접근이 필요한 요소들에는 ~-js 클래스를 추가해 스타일을 위한 클래스명이 바뀌더라도 로직은 작동할 수 있도록 했습니다. 요소를 가져오기 지금 보니까 너무 부끄러운 코드인데,,, 우선 멘토님 피드백을 보겠습니다. 멘토님 Feedback 실수노트에 추가한 내용... 처음에는 각 요소에 id를 부여해서 접근하고자 했기에 코드를 getElementById 메소드를 이용해 작성하고 있었는데 그걸 클래스로 접근해야겠다 생각하고 바꾸다가 비슷하게 생긴 getElementsByClassName에 꽂혀버렸기에 벌어진 일입니다. Resolve 아래 코드로 얼른 수정했습니다. EventListener 각종 이벤트 리스너들을 추가하는 부분입니다. $modalWrapper 요소에 PC와 모바일에서의 스크롤 이벤트를 방지하는 코드를 추가했습니다. modal 창을 뚫고 스크롤이 되면 안되니까요! 이벤트 버블링은 막았지만 캡처링을 건들지는 못해서 modal이 길어질 경우 modal 자체의 스크롤이 안됩니다. 추후 더 좋은 방법이 있을지 고민 해봐야겠습니다. 입력 <section>, 결과 <section> 멘토님 Feedback 페이지 접속시에는 가렸다가 submit 이벤트가 유효성 검사를 통과했을 때 보이게 하는건 유진 멘토님께서 말씀하신 것처럼 추가로 구현하겠습니다. 유효성 검사는 HTML에서 하니 같은 로직을 JS에서도 구현하는건 너무 중복되는게 아닌가 고민됐습니다. 하지만 유진 멘토님 말씀대로 안정적인 서비스를 위해 '유효성 검사' 만큼은 여러번 해도 지나치지 않다고 생각을 바꾸려고 합니다. Resolve tools.css 아래에 나올 modal과 지금 수정하고 있는 결과 <section> 요소처럼 가려져 있다가 나타나는 요소들에 .transition 클래스를 부여한 후 .activated, .deactivated 클래스를 작동 상황에 따라 부여하겠습니다. 결과를 보여주는 <section>에 .deactivated 클래스가 부여돼 있다면 .activated로 toggle합니다.submit 이벤트가 일어나면 <input>을 비워주는 코드를 추가했습니다.openModal(), closeModal() 함수는 필요 없어졌으므로 삭제했습니다. modal 창 앞서 수정한 코드에 이어서 수정한 내용입니다. 간단하게 \"훈련하러 가기 GO!GO!\" 버튼 혹은 modal을 감싸고 있는 wrapper <div>를 누르면 toggleActivation($modalWrapper)를 호출하도록 해 구현했습니다. 결과 <section>에서 '공유하기' 버튼 Clipboard API는 이번에 처음 알게 됐는데 재밌었습니다ㅎㅎ 멘토님 Feedback dataset을 가져오는 방식이란 일종의 '커스텀 attribute'로, data-*꼴로 넣을 수 있습니다. 예를 들어 저는 1만 시간의 법칙 페이지에서 이런 코드를 사용했습니다. 유진님께서 피드백 주신대로 단순 링크 복사보다는 더 멋진 무언가를 구현하면 좋을 것 같아요. 이건 추후에 더 붙여보는걸로 하겠습니다! 멘토님 JS 총평 멘토님 보기 좋으시게 JSDoc을 약간 작성했는데 칭찬받아서 기분이 좋네요 😆 마무으리 멘트 이 글 처음 쓰기 시작했을 때는 이렇게 시간이 오래 걸릴줄 몰랐는데 생각보다 엄청 오래 걸렸네요 😅 그래도 처음으로 디자이너님의 시안을 바탕으로 웹페이지 개발을 해봤는데 너무너무 재밌었습니다. 멘토님의 코드리뷰를 받고 고쳐나가는 과정도 정말 좋았구요. 이렇게 열심히 정리하고 보니 뿌듯하기도 하고, 코딩 과정에서 어떤 부분이 미숙했는지도 다시 한번 곱씹어 볼 수 있었습니다! "},{"slug":"딥다이브 5장: 표현식과 문","title":"딥다이브 5장: 표현식과 문","date":"2022-09-12T19:09:00+09:00","content":"'값(value)', '표현식(expression)', '문(statement)' 등의 정확한 정의가 무엇인지 알아봅니다. 값(value) 값(value)은 표현식(expression)이 평가(evaluate)돼 생성된 결과를 말합니다. 평가란 식을 해석해 값을 생성하거나 참조하는 것을 의미합니다. 아래의 식은 '평가'돼 '값' 30을 생성합니다. 모든 값은 데이터 타입을 가지고, 메모리에 비트의 나열로 저장됩니다. 이렇게 저장된 값은 데이터 타입에 따라 다르게 해석됩니다. 위 코드에서 변수 value에 할당되는 것은 10 + 20이 아닌 그 평과의 결과인 30입니다. 값은 이 코드처럼 식을 통해 생성할 수도 있지만, 값을 생성하는 가장 기본적인 방법은 리터럴을 이용하는 것입니다. 리터럴(literal) 리터럴(literal)은 사람이 이해할 수 있는 문자 혹은 약속된 기호를 이용해 값을 생성하는 표기법(notation)을 말합니다. 이 코드에서 3은 단순히 숫자 3이 아니라 '숫자 리터럴'입니다. 사람이 이해할 수 있는 아라비아 숫자를 사용해 숫자 리터럴 3을 넣으면 JS 엔진은 이를 평가해 숫자 '값' 3을 생성합니다. 즉 리터럴은 사람이 이해할 수 있는 문자 또는 기호('', \"\", ,, ., [], {} 등)로 표기한 코드를 의미합니다. 값을 생성하기 위해 미리 약속한 일종의 표기법인 것입니다. 리터럴을 통해 다양한 타입의 값을 생성할 수 있습니다. 표현식(expression) 값으로 평가될 수 있는 모든 문(statement)을 말합니다. 표현식이 평가되면 새로은 값을 생성하거나 기존 값을 참조하게 됩니다. 방금 살펴본 리터럴도 값으로 평가되기 때문에 그 자체로 표현식입니다. 문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다는 점을 알아둡시다. 문(statement) 프로그램을 구성하는 기본 단위이자 최소 실행 단위를 말합니다. 명령문이라고도 부르며, 문의 집합이 곧 프로그램이고, 문을 작성하고 순서에 맞게 배치하는 것이 프로그래밍입니다. 하나의 문은 여러 토큰으로 구성됩니다. 이 때 토큰이란 문법적인 의미를 가지고 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미합니다. 여기에서 const, sum, =, 1, +, 2, ; 각각이 바로 토큰입니다. 세미콜론 ;은 문의 종료를 나타내는데 이는 생략이 가능합니다. JS 엔진에 문의 끝이라고 예측되는 지점에 자동으로 세미콜론을 붙여주는 ASI(Automatic Semicolon Insertion) 기능이 있기 때문입니다. ASI에 의존해도 될지 말아야 할지는 논쟁거리입니다. 대부분은 세미콜론 사용을 권장합니다. 표현식인 문과 표현식이 아닌 문 표현식은 문의 일부일 수도 있고, 그 자체로 문이 될 수도 있습니다. 값으로 평가될 수 있는지 없는지를 생각해보면 쉽게 구분할 수 있습니다. 표현식인 문은 값처럼 사용할 수 있습니다. "},{"slug":"딥다이브 4장: 변수","title":"딥다이브 4장: 변수","date":"2022-09-12T17:09:00+09:00","content":"자바스크립트의 변수를 간단히 알아봅니다. 변수(variable) 컴퓨터는 메모리를 통해 데이터를 기억하고, CPU를 통해 연산합니다. 메모리는 데이터를 저장할 수 있는 memory cell의 집합체입니다. cell 하나당 1 byte(= 8 bit)이며 1 byte 단위로 데이터를 저장하거나 읽습니다. 각 cell은 고유의 memory address를 가집니다. 컴퓨터가 10 + 20이라는 연산의 결과값 30을 메모리에 저장했다고 하면, 이 30이라는 값에 접근할 수 있는 방법은 30이 저장된 cell의 주소값을 통해 직접 접근하는 것입니다. 하지만, 주소를 통해 직접 값에 접근하는 것은 매우 위험한 일입니다. 따라서 JS는 개발자의 직접적인 메모리 제어를 허용하지 않습니다. 그렇기 때문에 변수(variable)이라는 개념이 필요합니다. 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 그 자체 혹은 그 메모리 공간을 식별하기 위해 붙이는 이름을 말합니다. 즉, 값의 위치를 가리키는 상징적인 이름입니다. 인터프리터가 알아서 메모리 공간의 주소로 치환해 실행합니다. 식별자(identifier) 변수 이름을 식별자라고도 부르는데, 어떤 값을 구별해 식별할 수 있는 고유한 이름을 말합니다. 여기에서 식별자 result에는 값 30이 저장돼 있는 메모리 주소를 기억합니다. 이를 값이 저장돼 있는 메모리 주소와 매핑 관계를 맺는다고 말하며, 이 매핑 정보 또한 메모리에 저장됩니다. 변수 이름 뿐만 아니라 함수, 클래스 등의 이름도 식별자입니다. 변수의 선언(variable declaration) 변수 선언은 값을 저장하기 위한 메모리 공간을 확보(allocate)하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)해 값을 저장할 수 있게 준비하는 것을 말합니다. 이 때 확보된 공간은 해제(release)되기 전까지는 누구도 사용할 수 없도록 보호됩니다. JS에서 변수를 선언할 때 사용할 수 있는 키워드는 var, let, const 등이 있습니다. 추후 정리할 여러 이유들로 인해 최근에는 var를 거의 쓰지 않지만, 종종 옛날에 작성된 코드들에서 사용됩니다. ES6에서 let, const 키워드가 추가됐다는 점을 알아둡시다. 변수를 선언만 하고 값을 할당하지 않으면 JS 엔진은 undefined라는 값을 암묵적으로 할당해 초기화하기 때문에 쓰레기 값이 확보된 메모리 공간에 있을 염려가 없습니다. undefined는 primitive value중 하나입니다. 선언문의 실행 시점과 호이스팅(hoisting) 변수 선언문보다 변수를 참조하는 코드가 더 앞에 있다면 어떻게 될까요? JS 코드는 인터프리터 언어기 때문에 한 줄씩 순차적으로 실행되므로 위 코드에서는 undefined가 출력될 것입니다. 여기서 중요한 점은 참조 에러(ReferenceError)가 발생하지 않는다는 것입니다. JS는 소스코드를 순차적으로 실행하기 전에 코드를 평가하며 실행하기 위한 준비를 합니다. 이 때, 모든 선언문을 코드에서 찾아 먼저 실행합니다. 그리고 평가 과정이 끝나면 선언문을 제외한 코드를 한 줄씩 실행합니다. 즉, 선언문이 runtime이 아닌 그 이전 단계인 평가 단계에서 먼저 실행되기 때문에 ReferenceError가 발생하지 않습니다. 따라서 선언문이 어디에 있든 있기만 하다면 언제든지 변수, 함수, 클래스 등을 참조할 수 있습니다. 이런 특징을 호이스팅이라고 부릅니다. 값의 할당(assignment) 변수에 값을 할당할 때는 대입 연산자 =를 사용합니다. 변수의 선언과 할당은 한 문으로 축약해 표현할 수 있지만, 주의할 점은 실제 실행될때는 변수의 선언과 할당 시점이 다르다는 것입니다. runtime 전에 name이 선언되므로 코드는 ReferenceError 없이 잘 실행됩니다. 그렇다면 여기에서 두 console.log는 각각 어떤 내용을 출력할까요? 이는 아래 순서로 실행된다고 생각하면 쉽게 예측할 수 있습니다. 값의 재할당(reassignment) let이나 var 키워드로 선언된 변수의 값은 재할당 될 수 있습니다. 위 코드가 실행되면, x 값은 undefined가 할당되고, 다음으로 10이 먼저 재할당됐다가 20이 재할당됩니다. 이 때 재할당 되는 값은 먼저 할당된 값이 저장돼 있던 메모리 공간에 덮어쓰는 것이 아니라, 새로운 메모리 공간을 확보하고 거기에 새로 할당된 값을 저장합니다. 매핑 정보가 사라진 undefined와 10은 가비지 콜렉터에 의해 자동으로 해제됩니다. (언제 해제될지는 예측할 수 없습니다.) garbage collector가 있는 언어를 managed language라고 부릅니다. C언어는 대표적인 unmanaged language이며 malloc(), free()같은 저수준 메모리 제어 기능을 제공합니다. 덕분에 개발자의 역량에 따라 최적의 성능을 확보할 수 있지만 치명적 오류를 일으킬 가능성도 늘어납니다. 반면 managed language는 알아서 메모리를 관리해주니 생산성은 높지만 성능 면에서 손실을 감수할 수밖에 없습니다. 식별자 naming convention 식별자를 naming할때는 주석을 달지 않고도 변수가 무엇인지 설명할 수 있는지를 잘 생각하며 정하면 좋습니다. 자주 쓰이는 컨벤션은 아래의 네가지가 있습니다. 일반적으로 변수나 함수의 이름에는 camelCase를, 생성자 함수나 클래스 이름에는 PascalCase를 사용합니다. "},{"slug":"딥다이브 시작: 자바스크립트 intro","title":"딥다이브 시작: 자바스크립트 intro","date":"2022-09-12T17:09:00+09:00","content":"자바스크립트를 할줄은 알지만 기초가 부족하기에 완전히 바닥부터 다시 한번 자세하게 공부해보려고 합니다. [모던 자바스크립트 Deep Dive] 책을 읽으며 공부한 내용을 정리하겠습니다! 자바스크립트의 역사 자바스크립트는 1995년 넷스케이프의 브렌던 아이크가 개발한 브라우저용 경량 프로그래밍 언어입니다. 이듬해 마이크로소프트에서 JScript라는 파생 버전을 개발하며 브라우저에 따라 웹페이지가 정상적으로 동작하지 않는 크로스 브라우징 이슈가 발생하기 시작했습니다. ECMAScript 이에 넷스케이프에서 비영리 표준화 기구인 ECMA 인터네셔널에 JS의 표준화를 요청했습니다. 그렇게 탄생하게 괸 것이 표준화된 자바스크립트, ECMAScript입니다. let, const, 화살표 함수, 클래스, 모듈 등 범용 프로그래밍 언어로서 갖춰야 할 기능을 대거 도입한 ES6가 발표된 2015년 이후 비교적 작은 기능들을 매년 추가해 버전업하고 있습니다. JS와의 관계 자바스크립트는 프로그래밍 언어로서 기본 Core를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API(DOM, BOM, Canvas, XMLHttpRequest, fetch, WebStorage 등), Ajax 1999년, 자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능인 Ajax(Asynchronous JavaScript and XML)가 XMLHttpRequest라는 이름으로 등장했습니다. 이전에는 HTML 코드를 서버로부터 받아서 웹페이지 전체를 렌더링 하는 방식으로 작동했기에 페이지가 바뀌면 페이지 전체를 다시 렌더링했지만, Ajax의 등장 덕분에 변경이 필요한 부분만 한정적으로 렌더링 하는 방식이 가능해졌습니다. jQuery 2006년 등장한 jQuery는 DOM(Document Object Model)을 더 쉽게 제어할 수 있도록 도와주고, 크로스 브라우징 이슈의 해결에도 일조했습니다. 자바스크립트보다 배우기 쉽고 직관적이기 때문에 넓은 사용자 층을 순식간에 확보했습니다. V8 JavaScript Engine 2008년에는 구글에서 V8 자바스크립트 엔진을 발표했습니다. 그 뛰어난 성능 덕분에 웹 어플리케이션도 데스크탑 어플리케이션만큼 좋은 사용자 경험을 제공할 수 있게 됐습니다. V8 엔진으로 JS는 크게 발전하기 시작했으며 기존에는 웹 서버에서 수행되던 로직들이 대거 프론트엔드 영역으로 넘어오게 됐습니다. Node.js V8이 등장하고 이듬해 라이언 달이 V8 엔진으로 빌드된 Node.js 자바스크립트 런타임 환경을 발표했습니다. 브라우저의 JS 엔진에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서도 동작할 수 있게 돼, 자바스크립트 만으로도 프론트와 백을 모두 개발할 수 있다는 이점을 가져왔습니다. SPA Framework 규모가 크고 복잡해진 모던 웹 어플리케이션과 발맞춰 대두된 CBD(Component Based Development) 방법론을 기반으로 하는 SPA(Single Page Application)가 대중화되며, Angular, React.js, Vue.js 등 다양한 SPA 라이브러리/프레임워크들이 등장했습니다. 자바스크립트의 특징 자바스크립트는 웹 브라우저에서 동작하는 유일한 프로그래밍 언어로, 인터프리터 언어(interpreteer language)입니다. 모던 JS 엔진들은 인터프리터와 컴파일러의 장점을 결합해 비교적 느리다는 인터프리터 언어의 단점을 해결했습니다. 명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어TypeScript를 이용하면 더 강력한 객체지향 언어가 됩니다. 인터프리터 언어 vs 컴파일러 언어 interpreter language: runtime에 문 단위로 한 줄씩 중간 코드(intermediate code)인 바이트코드(가상 머신에서 실행하도록 만든 바이너리 코드, 실행 환경에 구애받지 않습니다)로 변환한 후 실행합니다. 실행 파일을 따로 생성하지 않고, 인터프리트 단계와 실행 단계가 분리돼있지 않다는 특징이 있습니다.compiler languange: 코드가 실행되기 전 단계인 compile time에 코드 전체를 한번에 머신 코드로 변환한 후 실행합니다. 실행 파일을 생성하고, 컴파일 단계와 실행 단계가 분리돼 있습니다. 미리 컴파일을 하니 일반적으로는 인터프리터 언어에 비해 더 빠릅니다. 대부분의 모던 브라우저들이 사용하는 인터프리터들은 명시적인 컴파일 단계를 거치지는 않지만 복잡한 과정을 거쳐 일부 코드를 컴파일하고 실행합니다. 따라서 요즘은 그 구분이 점점 모호해지고 있다고 합니다. "},{"slug":"멋사 프론트엔드 스쿨 2주차 회고","title":"멋사 프론트엔드 스쿨 2주차 회고","date":"2022-09-12","content":"둘째주가 되니까 슬슬 계획대로 안되기 시작합니다... 회고 여전히 정신없는 한 주가 또 지났는데, 언제나 그랬지만 이번주도 전혀 계획한대로 흘러가지는 않았어요!ㅠㅠ 이번 주에 있었던 일 블로그에 '시리즈' 기능을 붙이고 조금 더 시멘틱하게 바꿔봤어요.글 제목 위에 보시면 있는 조그맞게 있는 글씨가 바로 시리즈...입니다...ㅎㅎ,,,블로그 글 쓰다가 오 이거 필요하겠는데? 싶으면 쓰던 글 내팽겨치고 기능 개발하고 하다보니 TIL을 거의 못썼던게 좀 아쉬워요.시리즈가 있는 글에는 글 말미에 시리즈의 다른 글이 보이는 기능까지만 완성되면 이젠 정말로 글 내용에 집중하기로...매일 코테 한 문제씩은 풀었어요! 이건 좀 뿌듯멋사 붙캠 최종과제를 벌써 시작한 분이 계시다길래... 일단 자극받아서 저도 레포를 열어만 뒀어요. 흐흐처음으로 디자이너의 시안대로 웹사이트를 개발하는 과제, 1만 시간의 법칙을 JS까지 완성했어요. 다음주에 멘토님의 피드백을 받기로 했는데 기대됩니다.회고조 코드리뷰를 위한 깃헙 레포를 열고 협업 방법을 세워서 공유했어요. 방법 설명을 최대한 열심히 하려고 했는데 다들 잘 해주셔서 뿌듯해요. 저도 Git을 CLI 환경에서 사용하는 데에 아주 조금이나마 더 익숙해질 수 있어서 좋았어요. 글 제목 위에 보시면 있는 조그맞게 있는 글씨가 바로 시리즈...입니다...ㅎㅎ,,,블로그 글 쓰다가 오 이거 필요하겠는데? 싶으면 쓰던 글 내팽겨치고 기능 개발하고 하다보니 TIL을 거의 못썼던게 좀 아쉬워요.시리즈가 있는 글에는 글 말미에 시리즈의 다른 글이 보이는 기능까지만 완성되면 이젠 정말로 글 내용에 집중하기로... 기억에 남는 일 종찬님께 낸 과제중에 이런것도 대응이 됩니다를 어필하려고 간단하게 추가로 해봤던 내용이 종찬님의 '뭐임' 폴더에 들어가는 영광...ㅠㅠ 넘 부끄러웠어요 아쉬웠던 점 자바스크립트 딥다이브 스터디에서 시간맞춰 인증하지 못했어요. 이번주는 이런 식으로 시간 분배를 잘 못했던 것 같아서 너무 아쉬워요.TIL을 많이 정리하지는 못했던것도 아쉬워요,, 그래도 1일 1커밋은 지켰당 다음주 할 일과 다짐 이제 매일 아침에 운동...!! 꼭 할겁니다최종과제를 조금이라도 시작해보려고 해요.회고조 미팅을 진행해보려고 해요. 이번주에 정리한 내용 HTML Living Standard 1HTML Living Standard 2 "},{"slug":"HTML Living Standard 2","title":"HTML Living Standard 2","date":"2022-09-07T17:09:00+09:00","content":"HTML Living Standard를 확실히 공부해서 기본기를 다지는 시간 2탄!! Text-level semantics Text-level 요소는 요소 안의 컨텐츠의 크기만큼만 영역을 점유하고, 자식으로 Sections나 Grouping Contents를 배치할 수 없습니다. <br>, <wbr> <br>, <wbr> 모두 줄바꿈을 하는 요소입니다. <wbr> 태그는 텍스트 박스에서 한 줄로 모두 표시가 안될 때에만 줄바꿈이 일어나게 합니다. <wbr> 요소는 이렇게 줄바꿈이 필요할 때(text가 overflow될 때) 자동으로 줄을 바꿔줍니다. CJK(Chinese, Japanese, Korean)의 기본적인 work-break property 값은 break-all로 되어있기 때문에 글자 한 자 한 자씩 끊어서 줄을 바꿉니다. white-space 줄바꿈에 관련된 property로는 또 white-space가 있습니다. nowrap, break-spaces, pre 등 다양한 value들이 있으며, 각각의 작동은 아래와 같이 달라집니다. (직접 버튼을 눌러서 어떻게 바뀌는지 확인해보세요!) <a> <a> 요소는 링크, 즉 하이퍼 텍스트를 만들 때 사용하는 HTML(HyperText Markup Language)의 핵심적인 요소입니다. href(hyper reference) attribute의 값을 통해 경로를 지정할 수 있습니다. 자바스크립트로 경로를 지정할 수도 있지만 검색엔진 Agent들이 JS는 안읽고 HTML로만 문서를 판단하는 경우가 있으므로 웹 접근성에 위배되니 href attribute를 사용하는것이 좋습니다. 그래도 요즘은 다 JS까지 로드한 뒤에 데이터를 추출하긴 한다고 하네요! <a>는 예외적으로 Sections나 Grouping Contents들을 자식으로 가질 수 있습니다. 다만, <a>안에 <a>가 위치할 수는 없습니다! <b>, <strong> 둘 다 굵은 글씨(볼드체)를 표현하고 싶을 때 사용하지만, <strong> 요소는 더 나아가 '중요도'를 강조하는 의미를 가집니다. heading 요소를 사용하기 애매할 때 <strong> 요소를 사용합니다. 조직의 컨벤션에 따라 <b>는 아예 사용하지 않기도 합니다. <i>, <em> 둘 다 기울어진 글씨(이텔릭체)를 표현하고 싶을 때 사용하지만 아래과 같은 차이가 있습니다. <em> 요소는 강조의 의미를 가집니다.<i> 요소는 '주 언어와 다른 언어로 표현된 부분(주 언어는 한글인데 영어로 표기됐을 경우)', '소설 등의 작품에서 등장인물의 생각이 표기된 부분' 등 주위와 구분해야 하는 부분을 표현하기 위해 사용합니다. <dfn> 현재 문맥에서 정의하고 있는 용어를 의미합니다. 가장 가까운 부모가 <p> 또는 <dt>, <dd>쌍, <section>일 경우 그 컨텐츠가 <dfn>에서 정의하고자 하는 용어의 설명이 됩니다. <abbr> 줄임말을 나타내고 싶을 때 사용합니다. 이렇게 줄임말이라는 표시가 생깁니다. title attribute는 필수는 아닙니다. <sup>, <sub> 각각 윗첨자, 아랫첨자를 의미합니다. 단순히 작은 글자를 나타낼때 사용하면 안되고, 화학 기호나 수학 공식 등의 입력에만 사용합니다. 이외의 상황에서 위나 아래에 붙은 글자를 나타내고 싶다면 CSS에서 vertical-align property를 이용하면 됩니다. <time> 시간을 의미합니다. 컴퓨터가 알아듣기 어려운 형식일 경우 datetime attribute를 지정해줘야 합니다. datetime의 형식은 MDN 문서에서 확인할 수 있습니다. <cite> 책, 시, 노래, 영화 등 창작물 이름 등을 표현할 때 사용하는 요소로, 보통 이텔릭체로 렌더링됩니다. <span> 줄바꿈 없이 영역을 묶는 용도로 사용하는 요소로, 별다른 의미는 없습니다. <div>와 마찬가지로 남발하면 안됩니다. Embedded content <img> <img> 요소는 이미지를 삽입할 때 사용합니다. src (source): 필수 attribute로, 이미지 파일의 위치와 파일명을 알려줍니다. 이 때 경로는 절대경로 혹은 상대경로입니다.alt (alternative text): 이미지가 보이지 않을 때 이미지 대신 보여줄 텍스트입니다. 스크린리더같은 접근성을 위한 프로그램에 정보를 제공하기 위한 용도로도 사용되며, 이미지에 대한 정보를 브라우저에게 제공해 SEO에 도움을 주기도 합니다.<!-- 스크린 리더가 읽지 않습니다. --><img src=\"a.png\" alt=\"\" /><!-- 스크린 리더가 'a'를 읽습니다. --><img src=\"a.png\" /><!-- 스크린 리더가 '이미지'를 읽습니다. --><img src=\"a.png\" alt=\"이미지\" />경우에 따라서는 일부러 비워두기도 합니다.srcset (source set): 여러 해상도에 대응해 브라우저가 최상의 이미지를 로딩하는데 도움을 줄 수 있도록 하는 attribute입니다. 동일 이미지를 최소 2개 이상 가지고 있을 때 사용하며, 브라우저가 이미지를 선택합니다.아래는 제가 실제로 사용한 샘플 코드입니다.<img  class=\"title__img centering\"  srcset=\"./img/title_mobile.png 267w, ./img/title.png 564w\"  sizes=\"(max-width: 780px) 267px, 564px\"  src=\"./img/title.png\"  alt=\"1만 시간의 법칙\"/>srcset에서 이미지의 크기를 나타낼 수 있는 방법은 여러가지가 있는데, 여기에서는 x서술자, w서술자, sizes attribute라는 키워드만 언급하겠습니다. src (source): 필수 attribute로, 이미지 파일의 위치와 파일명을 알려줍니다. 이 때 경로는 절대경로 혹은 상대경로입니다. alt (alternative text): 이미지가 보이지 않을 때 이미지 대신 보여줄 텍스트입니다. 스크린리더같은 접근성을 위한 프로그램에 정보를 제공하기 위한 용도로도 사용되며, 이미지에 대한 정보를 브라우저에게 제공해 SEO에 도움을 주기도 합니다. 경우에 따라서는 일부러 비워두기도 합니다. srcset (source set): 여러 해상도에 대응해 브라우저가 최상의 이미지를 로딩하는데 도움을 줄 수 있도록 하는 attribute입니다. 동일 이미지를 최소 2개 이상 가지고 있을 때 사용하며, 브라우저가 이미지를 선택합니다. 아래는 제가 실제로 사용한 샘플 코드입니다. srcset에서 이미지의 크기를 나타낼 수 있는 방법은 여러가지가 있는데, 여기에서는 x서술자, w서술자, sizes attribute라는 키워드만 언급하겠습니다. <picture> <source>, <img> 요소를 통해 각 조건에 따라 맞는 이미지를 보여주는 요소입니다. <img>에서 srcset attribute를 사용하면 화면에 따른 이미지의 크기만 조절하지만, <picture> 요소를 사용하면 이미지의 포멧 자체를 바꿀 수 있습니다. type, media attribute의 값을 참고해 브라우저에 가장 알맞는 이미지 source를 자동으로 골라줍니다. 모든 <source> 요소의 이미지 사용이 불가하면 최후에 <img> 요소의 src를 이용합니다. 이런 방식의 크로스브라우징 기법을 점진적 향상기법(기본적으로 옛날 브라우저에서 작동할 수 있는 코드를 넣고, 최신 기술을 사용할 수 있는 환경에서는 최신 기술을 사용할 수 있도록 하는 기법)이라고 합니다. <source> 요소의 srcset attribute가 media attribute의 값을 참고해 <img>의 src attribute를 바꿔넣는 식으로 작동하므로 반드시 <img>요소는 있어야됩니다. 언제 srcset을 쓰고 언제 <picture> 요소를 쓸까? 해상도에 따라 '다른' 이미지(포멧이 달라도 다른 이미지입니다)를 보여주고 싶다면 <picture> 요소를, '같은' 이미지를 보여준다면 srcset을 이용합니다. <iframe> HTML 안에서 또 다른 HTML 페이지를 보여주고 싶을 때 사용하는 요소입니다. width, height attribute로 크기를 조절하며 따로 값을 안정하면 150px x 300px이 기본값이 됩니다. 본 블로그에서 포스트 중간 중간 보이는 HTML 실습 결과도 이미지가 아닌 <iframe> 요소입니다. 보통은 유튜브 영상을 불러올 때 많이 사용합니다. 웹사이트 안에서 다른 웹페이지를 또 불러오는 것이기 때문에 DBD(Drive By Download) 공격에 취약해질 수 있으므로 조심히 사용해야 합니다. DBD 공격이란 사용자의 의도와 무관하게 악성코드가 다운로드 및 실행되는 공격으로, 여기에서는 <iframe> 안에 위치한 JS 코드도 실행된다는 점을 악용한 공격입니다. <audio> 음악 컨텐츠를 재생하기 위한 요소로, 요즘엔 잘 안씁니다. <source> 요소를 자식으로 사용해 크로스브라우징을 위해 여러 포멧을 사용할 수도 있습니다. <video> 동영상 파일을 재생하기 위한 요소입니다. <source> 요소를 자식으로 사용해 크로스브라우징을 위해 여러 포멧을 사용할 수도 있습니다. <form> 정보를 입력하는 영역을 뜻합니다. <form>에 입력하고 제출(submit)하면 데이터는 서버로 전송되고, 그 데이터는 웹 서버가 처리하며 그 결과 페이지를 클라이언트에 전송합니다. <input> 사용자가 <form>에 입력할 수 있는 공간을 만들어 주고, 사용자에게 정보를 입력받습니다. 굉장히 많은 attribute와 type을 가지고 있습니다. <input>의 attribute들 type: <input> 요소의 모양을 다양하게 바꿀 수 있습니다.name: 요소의 이름을 지정합니다.readonly: 읽기 전용으로 합니다.maxlength, minlength: 최대, 최소 글자 수를 지정합니다.required: 필수적으로 입력해야 하는 값이 됩니다. 이 값을 채우지 않고 submit하면 에러를 띄우고 데이터가 전송되지 않습니다.autofocus: 웹 페이지가 로딩되면 이 요소로 포커스가 바뀝니다.placeholder: 입력할 값에 대한 힌트를 사용자에게 표시합니다.pattern: 정규표현식을 사용해 값의 유효성을 검사할 수 있습니다. 다양한 type들 <input type=\"hidden\">은 언제 사용하는걸까? hidden 타입은 서버로 넘길 데이터가 추가될 필요가 있을 때 사용합니다. 이 부분을 자바스크립트로 구현하려고 하면 굉장히 번거로우니, 꼭 hidden 타입을 잊지 말고 사용합시다!! 바퀴를 다시 발명하지 마라(Don't reinvent the wheel)라는 개발자 격언이 있다고 해요! <label> <input> 요소를 설명하는 텍스트를 의미하며, 웹 접근성에도 영향을 줄 수 있습니다. (시각 장애인들도 사용할 수 있도록 Semantic하게 사용해야 합니다.) 사용하는 방법은 두가지가 있습니다. <select>, <option> 드롭다운 리스트 박스를 생성하는 요소입니다. 아래처럼 사용합니다. <select>의 attribute들 multiple=\"multiple\": 사용자가 여러개의 <option> 요소를 선택할 수 있게 해줍니다. (컨트롤 or 커멘드 키 누르면서 눌러야 한다는 단점이 있음)size: 드롭다운 리스트에서 한번에 보여줄 수 있는 <option>의 개수를 정할 수 있습니다. <option>의 attribute들 value: 서버에 전송할 값을 정합니다.selected: 페이지가 로딩된 뒤 기본으로 선택되는 <option>을 지정합니다. 이 attribute가 사용되지 않았을 경우엔 기본적으로 첫번째 <option>이 선택됩니다. <fieldset> 자식 요소로 사용되는 form control들을 그룹화 할 수 있습니다. 폼 내용이 길어서 섹션을 나눌 필요가 있는 경우 유용하게 사용할 수 있습니다. 실제로 브라우저에서는 어떻게 구현되는지 보겠습니다. <legend> <fieldset> 바로 아래에 위치하며, 폼 그룹의 목적을 나타내는 제목을 의미합니다. 반드시 <fieldset>의 첫번째 자식으로 사용해야 합니다. <button> 클릭 가능한 버튼을 나타내는 요소입니다. submit(default), reset, button 등의 type이 있습니다. <input type=\"submit\">과 <button>의 차이는 무엇일까요? <button> 요소는 <input> 요소보다 스타일을 적용하기 훨씬 쉽습니다. 또한 <input> 요소는 닫는 태그가 없어 value attribute에 텍스트밖에 넣을 수 없지만 <button>은 여러 자식 요소를 추가할 수 있는데다가, ::after나 ::before같은 CSS 가상 요소를 사용할수도 있습니다. 더 멋진 스타일이 필요하다면 <button> 요소를 쓰면 됩니다. <textarea> 여러 줄의 텍스트를 입력받을 수 있는 요소입니다. 본 블로그에서는 댓글 입력란이 <textarea> 요소입니다. cols attribute로 입력창의 넓이를, rows로 보여줄 입력 줄 수를 지정할 수 있습니다. <datalist> <select>와 <input> 요소의 역할을 섞어서 사용할 수 있도록 해주는 요소입니다. <input>요소의 list 속성을 이용해 <datalist> 요소의 id attribute와 연결해 사용합니다. 설명이 좀 복잡한데, 아래의 예시를 보면 이해됩니다. 보시다시피 option중 하나를 선택하거나, 직접 option을 추가할 수 있습니다. "},{"slug":"HTML Living Standard 1","title":"HTML Living Standard 1","date":"2022-09-07T12:06:00+09:00","content":"HTML Living Standard를 확실히 공부하고 Semantic HTML을 향해 한발짝 더 나가봤습니다! 시멘틱 마크업? 의미있는 HTML을 만들기 위한 노력입니다. 웹 에이전트, Web Agent Serch Engine의 DB를 구축하기 위해 인간을 대신해 정보 자원을 수집, 검색, 추론해 다른 에이전트와 상호 정보 교환 등의 일을 수행하는 지능형 에이전트로, 시멘틱 웹 기반 응용 서비스의 핵심 요소입니다. 이런 페이지가 있다고 하면 Web Agent는 Naver 밑에 오픈캐스트가 있고, 그건 다시 금주의 오픈캐스트와 오늘의 오픈캐스트로 나뉘는구나! 라고 생각합니다. 같은 페이지에 대해 똑같은 Text Node를 가진 <a>가 많이 있다면 아, 이 페이지의 컨텐츠가 인기가 좋구나, 이 페이지를 상단에 띄워줘야겠다고 생각하기도 합니다. 이렇게 컨텐츠까지도 시멘틱 마크업의 범주에 포함됩니다. 즉, 인터넷의 정보들을 컴퓨터가 이해할 수 있고, 그 정보를 가공할 수 있도록 하는게 Semantic Markup의 목적입니다. 웹 접근성을 향상시켜 정보의 격차를 줄이는 것도 목표중 하나입니다. HTML Living Standard 웹 표준을 정하고자 하는 단체는 대표적으로 W3C(World Wide Web Consortium)와 WHATWG(Web Hypertext Application Technology Working Group)가 있습니다. 2007년에 WHATWG에서 W3C측에 제안한 명세가 바로 HTML5입니다. 2019년부터 두 조직이 합의해 WHATWG가 내세우는 HTML Living Standard가 표준이 되었습니다. WHATWG 웹은 항상 진화하고, '완성'되지 않습니다. 이런 의미에서 살아있는 생물처럼 웹 표준도 시시각각 달라진다는 뜻으로 HTML Living Standard라고 부릅니다. 관련 기사 본 글에서는 HTML Living Standard의 요소들 중 자주 사용하는 요소들을 정리했습니다. 시작하기 전에 Remind 👀 : Markup은 항상 가능한 최소로, 간결하게 짜는 것이 좋은 습관입니다! Document element <!DOCTYPE html> DTD(Document type Definition)라고 불리며, 문서의 타입에 관한 정보를 나타냅니다. 이 요소가 없다면 브라우저는 quirks mode(호환 모드)로 HTML을 렌더링하게 되는데, 브라우저마다 구현 방식이 다르기 때문에 다르게 동작할 가능성이 있으므로 반드시 문서 최상단에 이 요소를 넣어줘야 합니다. MDN 호환 모드와 표준 모드 <html> HTML 문서의 최상단 요소로, 루트 요소라고도 불립니다. 다른 모든 요소들은 <html> 요소의 후손입니다. lang attribute를 통해 문서의 주 언어가 무엇인지 설정할 수 있으며, 이 값이 검색엔진과 스크린 리더의 작동에 영향을 미칩니다. Document metadata <head> 문서 메타데이터가 모이는 요소입니다. <title> 문서의 제목을 의미하며, 반드시 한번만 사용해야 합니다. <link> 외부의 자원을 문서와 연결하는 역할을 합니다. 스타일 시트, 파비콘 등 여러가지를 연결합니다. <meta> MDN 문서 문서의 메타데이터를 나타내는 요소입니다. <meta>가 제공하는 메타데이터는 다음의 네가지가 있습니다. name: 문서 전체에 영향을 주는 document-level metadata입니다.name=\"author\": 페이지를 작성한 개발자의 이름입니다.name=\"description\": 페이지에 대한 설명 정보로, 검색엔진이 사용자에게 결과 화면을 출력할 때 중요하게 고려되는 요소입니다.name=\"viewport\": 모바일에서 사용자 화면의 사이즈에 대한 값을 설정, 요즘엔 반드시 넣어주는 것이 권장됩니다.http-quiv: pragma directive(프라그마 지시문)이라고 합니다. 브라우저에 어떤 행동을 지시하려는 목적으로 사용됩니다.http-quiv=\"X-UA-Compatible\": IE에서 어떤 형식으로 렌더링할지 지정할 때 사용하며, content=\"IE=edge\"는 IE8 이상에서 항상 표준모드로 렌더링 되도록 합니다.charset: 문서의 문자 인코딩 상태를 의미하며, 보통 UTF-8로 설정해 전세계 모든 언어를 지원토록 합니다.itemprop: 유저가 정의한 메타데이터를 나타냅니다.예를 들어 썸네일 이미지를 표시하고 싶다면 Open Graph Image가 들어가도록 <meta property=\"og:image\" content=\"이미지/주소.png\">를 넣는 식입니다. name=\"author\": 페이지를 작성한 개발자의 이름입니다.name=\"description\": 페이지에 대한 설명 정보로, 검색엔진이 사용자에게 결과 화면을 출력할 때 중요하게 고려되는 요소입니다.name=\"viewport\": 모바일에서 사용자 화면의 사이즈에 대한 값을 설정, 요즘엔 반드시 넣어주는 것이 권장됩니다. http-quiv=\"X-UA-Compatible\": IE에서 어떤 형식으로 렌더링할지 지정할 때 사용하며, content=\"IE=edge\"는 IE8 이상에서 항상 표준모드로 렌더링 되도록 합니다. 예를 들어 썸네일 이미지를 표시하고 싶다면 Open Graph Image가 들어가도록 <meta property=\"og:image\" content=\"이미지/주소.png\">를 넣는 식입니다. 자주 쓰이는 메타데이터 <style> 문서 전체 혹은 일부의 스타일을 나타냅니다. 외부에서 불러온 CSS보다 <style>요소에 담긴 스타일이 우선적으로 적용됩니다. Sections <body> 사용자에게 보여지는 문서의 컨텐츠를 나타냅니다. <header> WHATWG 문서 특정 컨텐츠의 시작을 나타냅니다. 일반적으로 구역의 제목(Heading elements 혹은 <hgroup>)을 포함합니다. (꼭 있어야 하는건 아닙니다.) 페이지당 하나만 있어야 하는건 아니며, 각 <section>들도 <header>를 가질 수 있습니다. <h1> ~ <h6> Section Heading elements MDN 문서 heading 요소라고 부르며, <h1> ~ <h6>까지 중요도에 따라 제목을 지정하기 위해 사용됩니다. 순서를 잘 지켜서 사용해야 합니다. 해당 제목을 포함하는 익명 영역(Anonymous Section)을 암묵적으로 생성해 다음 heading 요소가 나올때까지가 해당 heading 요소의 공간이 됩니다. <h1>은 페이지당 한 번만 사용해야 합니다. 보통 로고나 브랜드명을 <h1>으로 감쌉니다. 이 블로그에서는 좌상단에 있는 Custardcream이 이 요소로 감싸져 있습니다. (제 닉네임,,,) <section>, <article> 문서의 구획을 나누고자 할 때 사용합니다. 둘은 아래의 차이점이 있습니다. <article>은 독립적으로 있을 수 있는 컨텐츠에 사용합니다. *다른 서비스에 가져다 놔도 어색하지 않은가?*를 기준으로 삼으면 됩니다. 날씨 위젯 등이 여기에 해당됩니다.<section>은 사이트 내의 다른 컨텐츠와 연관이 있습니다. heading 요소와 함께 사용하는 것을 권장하지만 필수는 아닙니다. <nav> 현재 페이지 내, 혹은 다른 페이지로의 링크를 보여주는 구획입니다. 보통 메뉴에 사용되며, 페이지 최상단에 오는 <nav>는 <header>에 넣습니다. <aside> 문서의 흐름과는 상관 없는 별개의 구획을 나타냅니다. 보통 각주나 광고 영역을 넣거나, 양쪽 사이드에 위치해야 하는 요소를 그룹지을 때 사용합니다. <footer> 페이지나 각 <section>의 최하단에 위치하는 요소로, 페이지 최하단에 위치한 경우 회사에 대한 정보나 저작권 관련 정보가 들어가는 부분입니다. <address> 가장 가까운 부모 <article>이나 <body> 요소의 연락처 정보를 나타냅니다. 전화번호, 메일 주소, 우편 주소 등이 올 수 있습니다. <a>로 넣을 경우 컨텐츠가 직접 정보를 나타낼 필요는 없습니다. <a href=\"mailto:custardcream@kakao.com\">메일 주소</a>같은 요소도 <address>의 자식이 될 수 있습니다. <small> 저작권 정보를 나타냅니다. Grouping content <main> 문서의 주요 콘텐츠를 의미합니다. 현재 페이지에서 유일한 내용이어야 하며, 다른 페이지 혹은 섹션에서 반복될 수 있는 정보(로고, 검색 폼, 저작권 정보 등)는 이 요소에 들어가지 않습니다. <div> 레이아웃을 나눌 때 사용하는 요소입니다. 컨텐츠의 형태를 바꾸지는 않지만 여러 요소들을 <div>로 묶어 스타일을 변경할 수 있습니다. <article>, <section>, <header>, <nav> 등은 기본적으로 <div>와 동일한 역할을 합니다. 단지 그 이름으로 Semantic하게 마크업을 할 수 있도록 정의된 요소들일 뿐입니다. 의미있는 마크업을 위해 가능하면 <div>를 남발하기 보다는 적합한 요소를 찾아 사용해야 합니다. <ol>, <ul>, <li> <ol>과 <ul>은 각각 Ordered List, Unordered List를 의미합니다. <li>는 이 요소들의 자식으로 오는 List Item을 뜻합니다. <ol>과 <ul>의 직계자식은 반드시 <li>만 올 수 있습니다. <dl>, <dt>, <dd> <ol>, <ul>, <li>처럼 목록을 정의할 때 사용하지만, 사전처럼 어떤 것을 정의할 때 쓰이는 목록입니다. <dl>은 Definition List, <dt>는 Definition Term, <dd>는 Definition Description을 의미합니다. 보통 <footer>에서 아래같은 부분을 <dl>, <dt>, <dd> 요소로 마크업합니다.  (실제 코드라이언 페이지 코드 보니까 ul li로 돼있긴 하지만... 이렇듯 마크업은 개발자의 생각에 따라 좌지우지되고 정답은 없습니다.) <figure>, <figcaption> 이미지에 캡션(설명)을 달 때 사용하는 요소입니다. <p> 문단을 의미합니다. 하나의 완결된 문단을 의미하므로 <p>가 <p>를 자식으로 가질수는 없습니다. 줄바꿈 용도로 써서도 안됩니다. <pre> HTML에 작성한 내용 그대로 표시하는 요소입니다. (정확히는 이 부분의 마크업에 있는 공백은 있는 그대로 표현해라 라는 뜻) 주로 코드를 표현할 때 사용합니다. 보시다시피 User Agent Stylesheet로 인해 기본적으로 고정폭 글꼴(fixed-width font)을 사용해 표현됩니다. <blockquote>, <q> <blockquote>는 블록으로 감싸는 인용구를, <q>는 짧은 인용구를 의미합니다. 본 블로그에서는 이게 <blockquote>입니다! <hr> 이야기의 장면 전환, 문단 안에서 주제가 바뀔 때 구별을 위해 사용합니다. 원래는 가로줄을 표현하기 위해 사용된 요소이지만 HTML5 이후로 의미가 생겼습니다. 단락을 구분한다는 의미이므로 <p> 요소 안에서 사용하는 것은 웹 표준에 어긋납니다. "},{"slug":"멋사 프론트엔드 스쿨 1주차 회고","title":"멋사 프론트엔드 스쿨 1주차 회고","date":"2022-09-04T01:00:00+09:00","content":"멋사 프론트엔드 스쿨에서의 첫 주를 돌아봤습니다. 회고 프론트엔드 개발자가 되기로 마음은 먹었지만, 솔직히 막학기를 휴학까지 해가며 풀타임 부트캠프를 다니게 될 줄은 몰랐어요. 지금까지는 한 적 없었던 과감한 결정이었기에 혹시 나랑 맞지 않는 선택이었다면 어쩌지 하는 걱정과 함께 시작한 주였습니다. 정신없는 일주일을 보낸 후 회고를 적고 있는 지금은 정말 잘한 결정이었다고 과거의 저를 칭찬하고 싶어요. 이번 주에 있었던 일 고등학교 졸업 이후 5년만에 처음으로 5일 연속 9시 전에 일어났어요... 시차적응중...그동안 여러 개인 프로젝트를 해보며 HTML이나 CSS는 알고있다고 생각했는데 완전히 기초를 놓지고 있었다는걸 깨달았어요.특히 Semantic Markup이 어떤 의미이고 왜 필요한지 확실히 공부한 점과 금요일에 들은 이종찬 강사님의 CSS 기초 특강이 정말 좋았어요.Semantic Markup 실습을 위해 본 블로그의 HTML 요소들을 고쳤습니다. 그동안 수많은 <div>와 <span>을 남발하고, <h1>을 두개, 세개씩 쓰고 했던걸 보며 정말 엉망으로 하고있었구나 싶었어요. 지금은 꽤 Semantic해진 것 같은데, 나중에 한 번 피드백 받아보고 싶네요.display: flex;를 남발한 CSS도 지속적으로 고쳐나갈 예정입니다.멋사 FE 스쿨 3기의 회고 8조 조장을 맡게 됐습니다. 회고 활동 뿐만 아니라 같이 성장하는 동료가 될 수 있도록 최선을 다하겠습니다!!스터디를 두개나 들어가서 '함께 자라기', '모던자바스크립트 딥다이브' 이렇게 책을 두 권 샀어요. 특히 딥다이브는 꼭 한번 공부해야겠다 생각했는데 이 참에 공부하게 돼서 좋네요.멋사 온라인 모각코용으로 게더타운을 열었는데 많이 들어와주셨어요.코테 챌린지 두 개 신청했어요. 당연히 붙진 못하겠지만 목표가 생기면 코테공부에 도움이 될 것 같았어요. (Python에서 JS로 코테 언어 바꾸는것도 심각하게 고민중) 특히 Semantic Markup이 어떤 의미이고 왜 필요한지 확실히 공부한 점과 금요일에 들은 이종찬 강사님의 CSS 기초 특강이 정말 좋았어요.Semantic Markup 실습을 위해 본 블로그의 HTML 요소들을 고쳤습니다. 그동안 수많은 <div>와 <span>을 남발하고, <h1>을 두개, 세개씩 쓰고 했던걸 보며 정말 엉망으로 하고있었구나 싶었어요. 지금은 꽤 Semantic해진 것 같은데, 나중에 한 번 피드백 받아보고 싶네요.display: flex;를 남발한 CSS도 지속적으로 고쳐나갈 예정입니다. 기억에 남는 일 들어봤다 => 배웠다 => 해봤다 => 다르게 해봤다의 단계를 밟아 성장하자. 이번주에 들었던 말 중 이게 가장 기억에 남아요. 아 또 종찬님께서 종찬님 특강을 듣고 정리한 제 블로그 글을 봐주시고 좋아요 눌러주신것도 기억에 남아요. 지금의 글을 초고라고 생각하고 떠오를 때마다 고쳐나는 것도 엄청 공부가 될거란 조언을 주셨어요. 다음주 일정, 할 일과 다짐 일정 월요일부터 원티드 TypeScript 프리온보딩 챌린지가 시작돼요.무리하지 않고 할 수 있는 만큼만 참여할거에요.거의 매일 GDSC UOS 신입 면접에 면접관으로 참여해요. 무리하지 않고 할 수 있는 만큼만 참여할거에요. 할 일과 다짐 목요일에 '함께 자라기' 스터디가 있어요.목요일까지 딥다이브 4, 5챕터 공부할거에요.매일 코테 두 문제 이상 풀거에요.가능하다면 멋사 과제를 시작해볼거에요. 이번주에 정리한 내용 emmet(에멧) 정리!Git CLI 명령어 정리 1CSS 기본 다지기 "},{"slug":"CSS 기본 다지기","title":"CSS 기본 다지기","date":"2022-09-02","content":"CSS 기본기를 다지는 시간을 가졌습니다! 목표  오늘은 이런 페이지를 만들어보며 마크업의 기초를 다져보겠습니다. HTML, CSS를 짜기 전에 Remind 코딩을 할 때는 작은 조각들을 만들어 합쳐나가지만, 마크업을 짤 때는 꼭 큰 덩어리부터 만들어야 합니다. CSS 기본 initial value, User Agent Stylesheet 모든 CSS Property에는 지정하지 않아도 주어지는 디폴트 값이 있습니다. 이런 값을 initial value라고 합니다.  User Agent Stylesheet라고 브라우저에서 정한 기본값도 있습니다. 이건 initial value와는 다릅니다. 여기에서 'wow'를 컨텐츠로 가지고 있는 div는 User Agent Stylesheet에서 정한 body의 margin: 8px;에 영향을 받고 있는 것을 볼 수 있습니다. 각 브라우저의 User Agent Stylesheet 크롬 기본 제공 스타일파이어폭스 기본 제공 스타일 브라우저에서 제공하는 User Agent Stylesheet는 개발자가 의도하지 않은 결과를 낳을 위험이 있으므로 reset하는 과정이 필요합니다. margin: initial같이 initial 키워드를 사용하면 property에 따른 initial value가 들어가고, 또는 임의로 값을 부여해도 됩니다. height, width height와 width의 initial value는 auto입니다. 그럼 width: auto;와 width: 100%;는 어떻게 다를까요? 다음 예시를 보겠습니다. 즉, width: auto;는 브라우저가 계산한 자식(자신)의 margin, padding, border등을 고려해 유연하게 부모가 제공하는 최대 컨텐츠 영역 너비만큼을 줍니다. 반면, width: 100%;는 부모가 제공하는 최대 컨텐츠 영역을 가져오고, 거기에 마진을 더합니다. 더 자세한 내용은 여기에 정말 잘 설명돼 있습니다. height: auto;는 자식(자신)이 가지는 컨텐츠 높이만큼 유연하게 가져갑니다. 부모를 기준으로 정하는 width와는 달리 자식(자신)을 기준으로 한다는 점이 포인트입니다. box-sizing 요소의 사이즈를 결정하는 방법을 정하는 프로퍼티입니다. initial value는 content-box입니다. value를 border-box로 바꾸면 어떻게 달라지는지 아래의 예시를 보겠습니다. 즉, content-box는 컨텐츠의 크기를 width와 height로 정한 후 거기에 padding과 border를 더해 박스의 크기를 결정하고, border-box는 padding과 border를 포함한 크기가 width와 height가 되도록 컨텐츠 영역을 유연하게 조정합니다. Block-level elements MDN 문서 Block-level elements는 일단 한 줄을 확보하고, 요소의 크기만큼 차지하도록 한 후, 나머지는 잉여공간으로 둡니다. 아래의 예시로 확인하겠습니다. 여기에서 각 div들은 Block-level elements이므로 한 줄이 주어집니다. margin으로 auto를 주면 브라우저가 계산 후 가용한 잉여공간을 최대로 채울 수 있는 값이 부여됩니다. margin이 주어지지 않은 default div는 왜 왼쪽에 있는걸까요? <html> 요소의 attribute로 lang='ko'가 주어져 있으므로, Global attribute로 dir=\"ltr\"(left to right)이 부여돼있기 때문입니다. div가 Block-level elements인 이유는 User Agent Stylesheet에서 display: block;을 부여하고 있기 때문입니다. 대표적인 Block-level elements로는 <div>, <ul>, <li>, <h1> ~ <h6>, <p> 등이 있습니다. 단축 속성, shorthand property 위 예시에서 margin: 0 auto;, margin: auto;처럼 쓰는 방식을 shorthand property라고 부릅니다. 시계방향으로 값을 부여할 수 있으며, 두개만 적으면 위아래-좌우, 하나만 적으면 모든 방향으로 값이 들어갑니다. 이 때, 두 방법 모두 요소가 가운데로 정렬되는 이유는 위아래 잉여 영역은 0이므로 모든 방향으로 auto를 넣어도 위 아래로의 margin은 0이 들어가기 때문입니다. CSS Selector MDN 문서 Id Selector는 체계적으로 스타일을 관리하는 데에는 좋지 않은 방법이므로 보통 사용하지 않습니다. combinator는 \" \"(space), >, ~, + 등이 있는데 아래와 같이 사용합니다. 참고로 브라우저의 CSS Parser는 Selector의 맨 오른쪽부터 체크합니다. 이를 고려해서 적절한 Selector를 입력해야 합니다. text-align: center; 이런 HTML이 있다고 하면, div.header 안의 요소들을 가운데 정렬하는 방법은 어떤게 있을까요? div.header를 가운데 정렬했듯 margin: auto;를 이용하면 될까요? Inline elements MDN 문서 Block-level elements와 달리 Inline elements는 컨텐츠의 흐름을 바꾸지 않고, 요소를 정의하는 태그로 감싼 공간만 차지하는 요소입니다. 위 예시에서 <h1>과 <p>는 모두 Block-level elements이고, <img>와 <h1>, <p>로 감싸여있는 텍스트(=텍스트 노드)들은 Inline elements입니다. 이 때는 text-align: center;를 부모에 줘서 자식에 있는 Inline elements들을 가운데 정렬할 수 있습니다. <h1>과 <p>에 background-color를 줘보면 왜 이렇게 되는건지 확실히 보입니다. <div>, <h1> ~ <h6> 등은 '컨테이너'일 뿐이고, 그 안에 컨텐츠로 들어간 텍스트는 Inline elements라는 점을 헷갈리면 안됩니다. inline의 padding, margin Inline elements의 padding, margin property는 조금 신기하게 작동합니다. 이렇듯 Inline elements는 baseline을 기준으로 움직이는 요소들입니다. 따라서 baseline과 같은 방향이라면 margin이나 padding이 공간을 차지하고, 다른 방향이라면 생기긴 하는데 공간을 차지하진 않습니다. Inline elements는 컨테이너의 개념이 아니기 때문에 width나 height가 없습니다. 지정해줘도 작동 안합니다. 마크업 개행 HTML은 마크업을 할 때 개행한 경우 구분되는 요소로 생각하고 약간의 공백을 자동으로 부여합니다. 이 공백의 사이즈는 font-size에 따라 달라집니다. 이런식으로 우리의 편의를 위해 주는 기능을 쓰는건 좋지만, HTML로 스타일을 주는건 왠만하면 피해야 합니다. 상속 inheritance 앞선 예시에서 부모 요소에 준 text-align: center;가 자식 요소인 <h1>이나 <p>에도 전해진 이유는 property의 value가 상속됐기 때문입니다. 이렇게 상속이 되는 property와 그렇지 않은 property들이 있습니다. 상속이 되는 property는 대표적으로 text-align, color, font-size 등이 있는데... 이건 외울필요는 없고 상속이 되는게 합리적인 property인지 아닌지 생각해보면 됩니다. MDN 문서에서 검색해봐도 되고, 아니면 부딪혀보면 되죠... 상속받은 property의 value보다는 자식에서 지정된 value가 더 우선시됩니다. 상속은 하위 요소 모두에게 전파되며, inherit 키워드를 사용하면 background-color처럼 상속이 안되는 property도 억지로 상속받을수도 있습니다. inherited properties의 초기화 font-size는 상속을 지원하는 property입니다. 이런 property에 값을 지정해버리면 더이상 상속이 작동하지 않게 됩니다. 따라서 상속이 가능한 property는 inherit으로 초기화 해주는 것이 올바른 방법입니다. display property MDN 문서 Block-level elements를 inline화 하거나, Inline elements를 Block-level화 하는 등이 필요할 때 사용하는 property입니다. 원래 <a> 요소는 Inline elements이므로 padding이나 border property가 baseline이 아닌 위 아래 방향으로 영향을 줄 수 없습니다. 그러나 display: inline-block;을 부여해서 Inline elements임에도 Block-level elements처럼 작용되도록 만들었습니다. Margin Collapsing, 마진 병합현상 .child 코드를 보면 margin: 10px;를 줬으므로 A와 B 사이에는 20px의 마진이 생겨야 하나, 10px이 들어간 것을 볼 수 있습니다. 또한 A의 위와 B아래에도 각각 10px씩 공간이 있어야 하는데, 그 공간 없이 H모양이 돼버렸습니다. 이건 Margin Collapsing이 일어났기 때문입니다. 원래는 예쁜 디자인을 위해 의도된 현상입니다. 하지만 Margin Collapsing을 의도하지 않았을 경우를 대비해 어떤 조건에서 이 현상이 어떻게 발생하는지 알아둘 필요가 있습니다. Margin Collapse가 일어나는 정확한 조건이나 그 해결 방법은 생각보다 딥한 내용인 것 같아서, 추후 다른 포스팅으로 자세히 정리하겠습니다. 우선은 그 존재를 짚고 넘어가겠습니다. Selector Specificity 아래의 경우에는 어떻게 스타일이 적용될까요? 원래 style은 가장 마지막에 나온 코드가 적용됩니다. 그러나, 이 경우 더 구체적으로 선택했다고 평가되는 .text의 스타일이 적용됩니다. 이런 구체성을 Selector Specificity라고 부릅니다. 비슷한 예제로는 아래와 같은 상황이 있습니다. 같은 HTML에 아래의 CSS를 적용해보겠습니다. .text와 .text.text가 차이가 없으므로 background-color: orange;가 적용될 것 같지만, 재밌게도 .text.text쪽의 스타일이 적용됩니다. VSC에서는 Selector 위에 마우스를 올리면 Specificity를 확인할 수 있습니다. CSS는 이렇게 내부적으로 Selector의 중요도를 평가해 일종의 '계단'을 만들어 스타일을 적용합니다. 이런 모습이 마치 폭포수같다고 해서 Cascading Style Sheet, CSS라는 이름을 가지게 된겁니다. 목표 페이지 개발 위 내용을 가지고 아래의 페이지를 완성했습니다.  링크 Codes HTMLCSS "},{"slug":"Git CLI 명령어 정리 1","title":"Git CLI 명령어 정리 1","date":"2022-09-01","content":"매번 Git을 편하게 쓰고 싶어서 GUI로만 다뤄왔는데, Git 명령어를 정리해 CLI 환경에서도 Git을 얼마든지 사용할 수 있게 공부했습니다. Git이란 공식 문서 소스코드, 파일 등의 변경 내역을 저장하는 분산 버전 관리 시스템Git을 기반으로 하는 버전 관리 호스팅 서비스들이 많이 나와 있습니다. 대표적으로 GitHub, Bitbucket, Gitlab 등이 있습니다. 여기에서는 용어 설명보다는 명령어 위주로 기록하려고 합니다. Git을 처음 설치한 경우 GitHub 연결 2021년 8월 13일부터 비밀번호가 아닌 token이나 SSH로만 연결이 가능하게 바뀌었습니다. GitHub에서 token을 발급받거나, SSH 키를 등록하는 등의 과정을 거쳐야 합니다. 참고로, master라는 기본 브랜치 이름은 main으로 바꿔 사용하는 추세라고 합니다. 노예제를 떠올리게 한다는 이유라고 하네요. git clone 원격 저장소의 코드를 로컬로 받아오는 명령어입니다. git clone과 git remote가 헷갈릴 수 있는데요, git remote add origin는 특정 원격 저장소의 레퍼런스(origin)를 만드는 명령어이고, 여기에 git push -u origin main을 하면 origin 원격 저장소의 main 브랜치에 로컬에서 현재 선택돼 있는 브랜치를 연결한다는 의미입니다. 반면 git clone은 클론 대상인 원격 저장소를 복사해서 새로운 저장소를 로컬에 생성합니다. 그래서 git init 명령어를 사용해 저장소를 새로 시작할 필요가 없습니다. 따라서 타인의 저장소를 클론해 온 후, git remote add로 내 저장소와 연결하면 내 저장소에 push가 가게 됩니다. 자주 쓰이는 명령어 git pull 원격 저장소에 업데이트 된 데이터를 받아오고, 병합합니다. 코드 수정 후 push 하려는데 다른 사람이 이미 push해서 pull 받아야 하는 경우 이 경우 그냥 push하면 pull을 받지 않았기 때문에 오류가 발생합니다. 아래의 방법 중 하나로 병합하면 됩니다. git add, commit, push 원격 저장소와 로컬 저장소의 싱크가 맞지 않아 로컬 저장소로 강제로 맞추고 싶다면 아래처럼 --force 옵션을 추가하면 됩니다. 혼자만의 저장소일 때만 쓰고, 절대로 협업시에는 사용하면 안됩니다. "},{"slug":"emmet(에멧) 정리!","title":"emmet(에멧) 정리!","date":"2022-08-30","content":"emmet(에멧) 사용법을 정리했습니다. 에멧을 잘 사용하면 HTML 작업 능률이 엄청 올라갑니다! emmet(에멧) cheat sheet 에멧은 HTML 태그를 CSS 입력하듯 쓸 수 있게 도와주는 스니펫입니다. 부모 > 자식 element nav>ul>li 남매 element div+p class div.awesome 여러 개도 됩니다. id div#awesome 내용 넣기 h1{Hello} 여러 개 만들기 span*3 Item Numbering h$*3 ul>li.item-$.row-$*3 Lorem ipsum lorem: 한 문단 생성lorem5: 다섯 단어 생성lorem*3: 세 문단 생성 저는 한 문단 한글 lorem ipsum도 스니펫으로 추가해뒀습니다. img img:z Attribute a[href='https://custardcream.vercel.app'] Climb-up div>span+a^p "},{"slug":"멋쟁이 사자처럼 프론트엔드 스쿨 3기에 최종 합격하기까지","title":"멋쟁이 사자처럼 프론트엔드 스쿨 3기에 최종 합격하기까지","date":"2022-08-23","content":"멋쟁이 사자처럼에서 진행하는 프론트엔드 스쿨 부트캠프 3기에 최종 합격했습니다. 앞으로 4달 간 오로지 코딩 공부에 전념할 예정입니다! 멋쟁이 사자처럼 프론트엔드 스쿨에 지원하기까지 후기에 앞서서 제가 어떻게 멋쟁이 사자처럼 프론트엔드 스쿨에 지원하게 됐는지 적어보려고 합니다. 이 이야기는 제가 멋사 부트캠프 지원서나 자기소개 영상에 담은 내용이기도 해요. 나는 프론트엔드뿐이야 저는 올 해 1학기에 4학년으로서 공간정보공학과 졸업작품으로 동선을 고려한 All-in-One 일정 관리 서비스 크로스플랫폼 앱을 개발했습니다.(작품 링크) 앱은 Flutter를 이용해 개발했는데, 일정 블록을 Drag & Drop으로 삭제, 순서를 변경하거나 Hold & Drag로 일정 시간을 조정할 수 있는 타임라인 Widget을 개발했던 부분이 가장 뿌듯했습니다. 게다가 평소에 벡터 그래픽을 취미로 만들 정도로 디자인에도 관심이 있었기 때문에 프론트엔드 개발에 공을 들였고, 단기간에 개발한 앱 치고 꽤 멋진 모습이 됐습니다.  졸업작품은 무사히 개발을 마쳐, 서울시립대학교 도시과학대학 공동작품전에서 도시과학대학장상이라는 좋은 성과를 거둘 수 있었죠! 작품을 개발하며 깨달은 것이 하나 있다면, 제 길은 프론트엔드 개발자라는 것입니다. 비즈니스 로직을 구현하는 백엔드 개발자도 매력적인 직업이였으나, Flutter를 이용해 앱을 다채롭게 꾸며가는 과정이 너무나 즐거웠어요. 그래서, 드디어 프론트엔드 개발자로서의 길을 걸어가기로 다짐했습니다. 마음을 먹고 가장 먼저 했던 일은 네이버에서 진행하는 부스트캠프에 지원하는거였어요. 2차 코테까지는 갔는데 아쉽게도 광탈...ㅎㅎ 정사원으로 가주겠어 네이버 독학, 개인 프로젝트로 한 발짝 더 그 후, 본격적으로 JavaScript, Html, CSS는 물론, React.js와 부수적인 기술들을 독학했습니다. 저는 무언갈 배우면 하나 하나 다져가기보다는 바로 프로젝트를 진행해서 직접 부딪히며 익히는 성격이라 기초만 다진 채 금연을 도전하는 사람들을 위한 금연 타이머를 개발했습니다.  Github Repo사용해보기 멋진 결과물이었지만 무언가 부족한 느낌이 들었죠. 아직 여러모로 어설프기도 하고, 내가 개발을 온전히 내 것으로 컨트롤하고 있다는 느낌이 부족했어요. 공부한 내용을 정리하고 기록할 공간이 있어야겠다는 생각이 들었죠. 그래서 개발했던게 지금 보고계시는 이 블로그입니다. Next.js를 사용해서 남들 다 쓰는 벨로그나 jekyll 템플릿 말고 정말 나만의 블로그를 만들겠다는 다짐을 가지고요. 블로그의 레이아웃은 물론 카테고리별 분류, 댓글 기능까지 모든 부분을 직접 개발했답니다. 부족해, 부족해... 여기까지는 탄탄대로였지만, 이 이후가 문제였습니다. 개발을 완전히 구현 위주로만 공부해왔기에 기본기가 부족하다는 느낌이 정말 강하게 들었거든요. 제가 좋아하는 노마드 코더의 니꼬쌤이 하신 말씀 중 이 구절이 뇌리에 강하게 박혔어요. 좋은 프론트엔드 개발자는 리액트의 도움 없이도 원하는걸 구현할 줄 알아야 합니다. 제 실력으로는 바닐라 JS로 모달창도 만들기 어렵겠다는 생각이 들자 너무 부끄러워지더라고요. 그동안 뭘 한걸까 싶고, 갈피를 잡기 어려웠습니다. 부족했던건 그뿐만이 아니었습니다. 개인 프로젝트는 충분히 해본 것 같은데, 팀 프로젝트를 진행해보고 싶어도 마음이 맞는 동료를 찾기가 쉽지 않았어요. 아예 모르는 분과 프로젝트를 시작하기에는 부담감이 컸고, 주변에는 저처럼 프론트엔드 개발자를 목표로 하는 분이 많지 않았거든요. 같이 개발자로서 성장할 친구들이 필요했습니다. 그래서 최근에 제가 이미 Data/ML팀 Core Member로서 활동중이던 Google Developer Students Club UOS에서 Frontend로 팀을 변경하기도 했어요. 휴학생 신분으로 2학기에 멋사 부트캠프와 병행할 예정이에요. 게다가, 인턴을 지원해보면서 느낀 점인데 생각보다 인턴을 뽑는 회사도 많지 않고, 제 이력서가 좋은 평가를 받지 못하는 것 같았어요. 그래서 멋사 부트캠프를 통해 멋진 회사들에 제 이름을 알리고 멋사의 도움을 조금 받아서 스타트업에서 인턴을 해보고 싶기도 해요. 기본기를 다지자 네, 이런 생각 끝에 저는 멋쟁이 사자처럼 프론트엔드 스쿨에 지원하게 됐습니다. 4개월동안 빡 집중해서, 바닐라 JS의 달인이 되겠다는 목표로 열심히 달려보려고요. 4개월이라는 짧은 기간동안 틈틈히 GDSC활동도 하고, 멋사에서 만난 분들과 팀 프로젝트도 하고, 면접 준비에 코테 준비까지 하겠다는게 지금 계획이긴 한데...ㅎㅎ 물론 계획대로 흘러가지는 않겠지만 정말 최선을 다 해서 열정을 쏟아보겠습니다. 멋사에서 빡공하고 멋사 연계 스타트업에서 인턴하자!! "},{"slug":"Frontend 기본기 다지기 - CS편","title":"Frontend 기본기 다지기 - CS편","date":"2022-08-20","content":"Frontend 개발자가 되기 위해 기본기도 다지고, 앞으로 있을 기술 면접을 대비해 중요한 개념들을 질문, 답변의 형태로 정리했습니다. 질문들은 이 블로그를 참고했습니다. CS, JS, React, Frontend로 나뉘며 각 편은 계속해서 내용을 붙여나갈 예정입니다. 이 글은 그 중 CS 관련 내용을 정리한 글입니다. 브라우저 주소창에 주소를 입력하면 어떤 일이 일어나나요? 참고할만한 Web.dev 글 가장 먼저 웹사이트의 IP주소를 알아야 합니다. 이를 위해 첫째로 DNS Cache를 확인하고, 다음으로 로컬에 있는 hosts 파일을 확인하고, 마지막으로 DNS 서버에 질의합니다. IP주소를 획득하면 TCP연결을 먼저 진행합니다. TCP 연결이 성공하면 HTTP request가 나가서 response를 받게 됩니다. 이후 웹 브라우저의 렌더링 엔진이 이 응답을 브라우저상에 렌더링하게 됩니다. 렌더링 엔진에 대해 설명해주세요. 렌더링 엔진은 HTML, XML, 이미지 등 웹 서버로부터 받은 응답을 브라우저상에 보여주는 역할을 합니다. 예를 들어 HTML 문서를 응답받으면 렌더링 엔진의 HTML parser와 CSS parser를 이용해 파싱되고, DOM과 CSSDOM 트리로 변환되고, 렌더 트리로 결합합니다. 그 다음, 렌터 트리에 명시돼 있는 각 노드의 정확한 위치를 가지고 layout을 그린 후, 브라우저의 UI Backend Layer를 이용해 페인팅을 진행해 웹페이지를 화면에 표시합니다. 크롬은 Blink, 사파리는 Webkit을 사용하며 렌더링 엔진마다 CSS문법이 다르기도 합니다. URL과 URI는 어떻게 다른가요?  URI, Uniform Resource Identifier는 URL과 URN을 포함하는 개념입니다. URI는 인터넷에서 특정 아이템을 식별할 수 있는 string이며 URL이 이에 포함됩니다. URL(Uniform Resource Locator)은 특정 아이템의 identifier와 그 아이템으로 접근할 수 있는 방법(cheme)이 명시된 string입니다. 예를 들어, google.com은 URI이고, https://google.com은 URI이자 URL입니다. DNS에 대해 설명해주세요. DNS, Domain Name Service는 분산형 DB 구조를 가지고 있는 서버로, 도메인 네임을 가지고 Host의 IP를 찾아주는 역할을 합니다. Protocol이란 무엇인가요? 프로토콜이란 컴퓨터 사이 데이터 통신을 위한 규약을 말하는데, Application Layer, Transport Layer, Internet Layer, Network Interface Layer(Link Layer)의 네 스택으로 나뉩니다. HTTP에 대해 설명해주세요. HTTP, Hyper Text Transfer Protocol은 인터넷 프로토콜 중 하나입니다. HTTP는 Protocol의 네 레이어 중 Application Layer에 속합니다. HTTP는 세가지 특징이 있습니다. 클라이언트 서버 구조, 즉 서버에 요청을 보내고, 응답을 기다렸다가 서버로부터 응답을 받는 구조를 가지고 있습니다.서버가 프로토콜의 상태를 보존하지 않는 무상태 프로토콜입니다. 때문에 로그인처럼 상태를 유지할 필요가 있는 경우에는 쿠키나 세션 등을 이용해야 합니다.연결을 유지하지 않는 비연결성을 가지고 있습니다. HTTP 메세지는 Request와 Response로 구성되는데, 이는 각각 start-line, header, empty line, message body로 이뤄져 있습니다. 그 중 start-line만 설명하면 아래와 같습니다. Request Request-Line(Request): Method SP Request-URI SP HTTP-Version CRLFSP=공백, CRLF=줄바꿈Method 종류: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT SP=공백, CRLF=줄바꿈Method 종류: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT Status-Line(Response): HTTP-version SP Status-Code SP Reason-Phrase CRLFStatus-Code 종류1xx: Informational2xx: Success3xx: Redirection4xx: Client Error5xx: Server Error Status-Code 종류1xx: Informational2xx: Success3xx: Redirection4xx: Client Error5xx: Server Error 1xx: Informational2xx: Success3xx: Redirection4xx: Client Error5xx: Server Error TCP/IP 연결이란 무엇인가요? IP, Internet Protocol은 Internet Layer에 속하는 프로토콜로, 지정한 IP 주소에 패킷 단위로 데이터를 전달하는 프로토콜입니다. 패킷에는 출발지의 IP, 목적지의 IP, 전송할 데이터 등이 포함됩니다. 그러나 IP 프로토콜은 패킷을 받을 상대가 없거나, 중간에 패킷이 사라지거나, 같은 IP를 사용하는 여러 어플리케이션이 통신하면 구분할 수 있는 방법이 없다는 한계가 있습니다. 이를 해결하기 위해 TCP를 사용합니다 TCP, Transmission Control Protocol은 Transport Layer에 속하는 프로토콜로, 연결지향형 프로토콜입니다. 3-Way-Handshake, 데이터 전달의 보증, 순서를 보장한다는 특징이 있어 신뢰할 수 있는 프로토콜이라고 불립니다. 3-Way-Handshake는 먼저 클라이언트에서 서버로 TCP 연결 요청을 보내고, 서버에서 ACK, 즉 acknowledgment(확인) 응답을 보내면 다시 클라이언트에서 서버로 ACK 응답을 보내는 과정으로, 이를 통해 TCP는 연결을 보장해줍니다. REST API에 대해 설명해주세요. Redhat Docs REST API(=RESTful API)는 HTTP를 사용하는, REST 아키텍처 스타일을 지키는 어플리케이션 프로그래밍 인터페이스이자 가이드라인입니다. 다양한 포멧을 사용할 수 있지만 보통은 JSON 포멧을 사용합니다. REST API를 설계할 때는 HTTP Method에 맞게, 확장성을 지니도록 잘 설계해야 합니다. 객체 지향 프로그래밍이란 무엇인가요? OOP, Object Oriented Programming은 프로그래밍 패러다임중 하나로 컴퓨터 프로그램을 여러 객체들의 모임으로 만들고자 하는 것입니다. 각 객체가 서로 데이터를 주고받고 처리하며 프로그램이 작동합니다. 객체지향 프로그래밍은 프로그램의 확장성과 유지보수성에 좋은 영향을 주고, 객체를 재사용하기 용이하며, 강한 응집력과 약한 결합력을 유지하는 데 도움이 되기 때문에 많이 사용됩니다. 기본적으로 클래스, 객체, 메소드와 메세지로 구성됩니다. Class: 같은 종류로 분류될 수 있는 것들을 모아둔 것으로, 클래스 외부에 있는 요소들과 독립적으로 디자인됩니다. field와 method를 가집니다.Object: 클래스의 Instance로, 클래스에서 정의된 내용들을 사용할 수 있습니다.Method, Message: 클래스로부터 생성된 객체를 사용하는 방법으로, 메소드로는 객체의 속성을 조작하고 메세지로 객체간 통신이 이뤄집니다. OOP는 다음의 특징을 가지고 있습니다. 추상화: 실생활의 문제들처럼 객체를 추상화해 설계합니다.상속, 다중 상속: 새로운 클래스가 기존의 클래스를 상속받거나 파생될 수 있습니다. 하나의 클래스가 두개 이상의 클래스로부터 상속받을 수 있습니다. 코드의 재사용성와 유연성을 높여줍니다.다형성: 한 요소에 여러 개념을 넣어 놓을 수 있다는 의미로, 대표적으로 메소드 오버라이딩이나 오버로딩이 있습니다. 오버라이딩은 같은 이름의 메소드가 여러 클래스에서 각기 다른 기능을 하는 것을 말하고, 오버로딩은 같은 이름의 메소드가 인자의 개수나 자료형에 따라 다른 기능을 하는 것을 말합니다. 추가적으로 클래스 관점에서는 여러 클래스를 상속에 따라 한가지 이름으로 부를수도 있습니다. 이를 통해 객체간 관계를 조직적으로 나타낼 수 있습니다.캡슐화: 내부의 구현은 감추고, 모듈 내에서 응집도를 높이며 모듈간의 결합도를 떨어뜨립니다. 그러나 이같은 장점에도 처리 속도가 느리다는 단점이 있어 프로그램을 설계하는 데에 많이 신경써야 합니다. 최근에는 함수형 프로그래밍이라는 패러다임이 떠오르고 있는데, 함수형 프로그래밍은 프로그램을 상태값을 지니지 않는 함수값들의 연속으로 보는 관점입니다. Process와 Thread의 차이는 무엇인가요? 프로세스는 OS로부터 자원을 할당받는 작업의 단위이고, 스레드는 이렇게 할당 받은 자원을 이용해 실행하는 단위로 한 프로세스 내에 여러 스레드가 있을 수 있습니다. 어플리케이션 하나가 프로세스이고, 그 안에서의 처리가 스레드입니다. Multi Process와 Multi Thread에 대해 설명해주세요. Multi Process는 하나의 프로그램을 여러 개의 프로세스로 구성해 각 프로세스가 하나의 작업을 처리하는 것입니다. 이렇게 함으로서 하나의 프로세스에서 오류가 발생해도 프로그램은 계속해서 동작할 수 있다는 장점이 있으나 context switching을 하는 과정에서 비용이 발생합니다. Multi Thread는 프로그램을 여러 개의 스레드로 구성하고 각 스레드가 작업을 처리하는 것입니다. 상대적으로 속도가 빠르고 스레드간 자원을 공유할 수 있다는 장점이 있으나 디버깅이 어렵고, 동기화 관련한 이슈가 발생할 수 있으며 스레드 하나라도 오류가 발생하면 전체 프로세스에 문제가 생긴다는 단점이 있습니다. Thread Safe란 무엇인가요? Thread Safe는 여러 스레드가 동시에 사용돼도 안전하다는 것을 의미합니다. 더 자세히 말하면, 특정 함수 혹은 변수가 여러 스레드에서 호출돼도 하나의 스레드에서 호출됐을 때와 같은 결과가 보장되어야 한다는 의미입니다. 함수가 함수 바깥에 위치하는 전역 변수를 참조하면 Thread Safe하지 않을 수 있습니다. Context Switching이란 무엇인가요? CPU에서 여러 프로세스를 돌아가며 작업을 처리하는 과정을 뜻합니다. 동작중인 프로세스가 대기를 하면서 프로세스의 context 즉 상태를 보관하고 대기하다가 다시 실행할 때 복구에 걸리는 시간이 이 Context Switching에 들어가는 비용입니다. 동기(synchronous)와 비동기(asynchronous)에 대해 설명해주세요. 동기 방식은 하나의 스레드로 여러 요청을 순서대로 처리하는 방식이고, 비동기 방식은 스레드를 여러개 만들어 여러 요청을 번갈아가며 처리하는 방식입니다. 자바스크립트와 연결지어 설명을 이어나가보겠습니다. 먼저, JS는 싱글 스레드 언어입니다. 때문에 시간이 걸리는 작업을 하나 처리해야 할 때 다른 서비스들이 실행이 중단돼버립니다. 이는 웹페이지의 사용성에 치명적이므로 WebAPI에서는 비동기적 처리를 가능케 해줍니다. JS Engine(대표적으로 V8)에는 하나의 힙과 하나의 콜 스택이, JS 런타임 웹 브라우저의 WebAPI에는 이벤트 루프와 콜백 큐가 존재합니다. 이 call stack에 요청이 stack 형태로 쌓이고, Web API에서 이 코드에 대한 처리를 비동기로 처리합니다. 비동기 함수에는 setTimeout(), setInterval(), HTTP 요청, 이벤트 헨들러 등이 있으며 각 함수들은 callback pattern을 사용해 이 콜백 함수에 넣어준 내용이 각 함수의 실행이 끝날 때 실행됩니다. "},{"slug":"유용한 VSC 단축키 정리","title":"유용한 VSC 단축키 정리","date":"2022-08-16","content":"Visual Studio Code는 제가 가장 좋아하는 IDE입니다. VSC의 '단축키'를 정리했습니다. 단축키는 생산성에 아주아주 큰 영향을 미치니, 꼭 알아두시길 바랍니다. 저는 MacOS를 사용하므로 Mac 기준으로 정리했지만, Command 키는 Control 키, Option 키는 Alt 키로 바꾸면 Windows에서도 대부분의 단축키가 작동할겁니다. 어떤 역할을 하는 키인지 글만으로는 알기 어려울 수 있지만, 제가 직접 사용해보고 '이것만은 정말 알아야한다'는 키들만 모았으니 꼭 시도해보세요. 단축키를 하나만 더 알아도 생산성은 배로 늘어납니다. 새로 알게된 단축키가 있을 때마다 갱신하겠습니다. 추가할만한 단축키가 있다면 댓글 부탁드립니다. VSC 설정이 어떻게 돼있냐에 따라 단축키가 다를 수 있습니다. 저장(Command + s)같이 당연히 알만한 단축키는 생략했습니다. 멀티 커서 관련 멀티 커서 Option(⌥) + 커서를 놓고 싶은 곳 클릭 여러 군데에 커서를 놓을 수 있습니다. 멀티 커서(키보드로) Command(⌘) + Option(⌥) + 위쪽 or 아래쪽 화살표 멀티 커서(일직선인 경우) 시작 부분에 커서를 놓고, Option(⌥) + Shift(⇧) + 선택이 종료되는 커서가 놓일 부분 클릭 가지런하게 놓인 연속적인 여러 줄에 대해 멀티 커서를 간편하게 만들 수 있습니다. 선택한 줄들의 맨 마지막으로 커서 이동 여러 줄을 드래그로 선택하고, Option(⌥) + Shift(⇧) + i 문자열 선택 같은 문자열들 선택 문자열을 선택하고, Command(⌘) + d 선택한 문자열과 같은 문자열을 멀티커서로 하나씩 늘려가며 선택합니다. 정말 정말 많이 사용합니다. 문자열 끝까지 선택 Command(⌘) + Shift(⇧) + 오른쪽 or 왼쪽 화살표 문자열 큰 단위로 선택 Option(⌥) + Shift(⇧) + 오른쪽 or 왼쪽 화살표 멀티 커서와 함께 사용하면 강력한 기능입니다. 여러 줄들이 문자열의 길이는 다른데 구성은 같다면 이 단축키로 원하는 단위만큼 멀티 선택 할 수 있습니다. 문자열 사각형으로 선택 Option(⌥) + Shift(⇧) + 여러 줄 드래그 여러 줄을 그냥 드래그하면 그 줄 전체가 선택되지만, 문자열을 사각형으로 선택하면 정확히 선택한 부분만 선택됩니다. 커서 이동 모든 이동 단축키는 hift(⇧)와 같이 사용하면 선택이 됩니다. 큰 단위로 이동 Command(⌘) + 오른쪽 or 왼쪽 화살표 작은 단위로 이동 Command(⌘) + 오른쪽 or 왼쪽 화살표 문서 맨 위 / 아래로 이동 Command(⌘) + 위쪽 or 아래쪽 화살표 기타 VSC Settings Command(⌘) + , 자동완성 확인하기 Ctrl + Spacebar 혹은 Command(⌘) + i 들여쓰기 / 내어쓰기 선택된 부분이 있는 경우 들여쓰기: 조절할 줄들을 선택하고(일부만 선택해도 됨), Tab내어쓰기: 조절할 줄들을 선택하고(일부만 선택해도 됨), Shift(⇧) + Tab 선택된 부분이 없는 경우 들여쓰기: Command(⌘) + ]내어쓰기: Command(⌘) + [ 커서가 있는 줄을 위 / 아래로 이동 옮기고 싶은 줄에 커서를 놓고, Option(⌥) + 위쪽 or 아래쪽 화살표 여러 줄을 선택한 상태로도 가능합니다. Refactoring시에 유용하게 쓰입니다. 한 줄 복사 / 삭제 복사: Shift(⇧) + Option(⌥) + 위쪽 or 아래쪽 화살표삭제: Shift(⇧) + Command(⌘) + k 새로 파일 열기 Command(⌘) + NCommand(⌘) + S파일명 입력 코드 스니펫 만들기 Command(⌘) + P>snippet 입력원하는 언어 선택해서 config json 수정 코드 스니펫 string에서 $숫자는 스니펫을 사용할 때 탭을 누르면 해당 위치로 순서대로 이동합니다. UPDATED ON 22.09.13 "},{"slug":"JavaScript만으로 SPA 개발해보기","title":"JavaScript만으로 SPA 개발해보기","date":"2022-08-15T22:30:00+09:00","content":"바람직한 웹 개발자는 Vanilla JS를 잘 다룰줄 알아야 합니다. Single Page Application을 React.js 등 프레임워크의 도움 없이 Vanilla JS로 개발해보겠습니다. Intro 제가 제일 좋아하는 쌤인 니꼬쌤께서는 항상 바닐라 자바스크립트의 중요성을 강조하십니다. 아무리 프레임워크를 잘 다뤄봤자 바닐라 JS를 잘 모른다면 이해도도 떨어지고, 프레임워크에 지나치게 의존적인 개발자가 될 위험이 있다는 말씀인거죠. 마침 지금 2차를 준비중인 멋쟁이 사자처럼 웹 프론트엔드 2차 과제 중 바닐라 JS로 SPA를 만드는 과정이 있어 따라해보며 정리하려고 합니다. 목표 저는 이 강의를 참고해 코인 순위를 보여주는 SPA를 만들어보고자 합니다. 강의에서는 정말 페이지가 하나뿐인 앱을 만들며 SPA를 표방했지만, 저는 Router까지 구현해보겠습니다. 사용하는 API는 Coinpaprika API입니다. 개발 실습 환경 구축 우선 아래의 형태로 기본적인 html 코드를 작성해줍니다. root div를 하나 만들고, data fetch 함수를 하나 선언해줬습니다. 이제 여기에 컴포넌트를 하나 하나 추가해가면 됩니다. 참고로, VSC의 Live Server라는 extension을 사용하면 매 번 저장할 때마다 바뀌는 코드의 내용을 auto reload하며 편하게 코딩할 수 있습니다. 컴포넌트 관리는 innerHTML을 넣기 보다는 이렇게! root에 코인 목록을 넣고싶다고 가정해보겠습니다. <ul> element를 root div 안에 추가하는 건데요. 가장 간단한 방법은 그냥 직접 html을 작성해서 innerHTML로 넣어주는거겠죠. 이렇게요! 하지만 이렇게 작성하면 코드의 일관성을 유지하기 어렵고, 모듈화를 통한 컴포넌트의 재사용을 할 수 없다는 단점이 있습니다. 때문에 아래의 방법처럼 작성합니다. 추후 css작업을 위한 클래스명을 적절히 부여하며 api를 사용해 10위까지의 코인이 보이는 메인 페이지 코드를 완성하겠습니다.  css 작업을 하기 전이라 보기 별로지만 코인 이름, 심볼, 순위까지 표시가 잘 되고 있습니다. SPA Router with JS 보통 Single Page Application들은 Routing을 할 때 실제 URL에 해당하는 html을 찾는 대신, 이걸 '낚아채서' URL 경로에 따라 올바른 컨텐츠를 동적으로 보여줍니다. Browser History를 이용하는 방법이 가장 보편적인데, 이 때 알아둬야 하는 api들은 다음과 같이 있습니다. History.pushState()Window의 popstate eventWindow의 DOMContentLoaded event 각각에 대한 설명은 링크된 MDN docs를 참고해주세요. 완벽한 Router를 개발하는 것은 웹서버 개발과 연관돼 있어 간단하게 개발하려면 hashed route등을 사용해야 합니다. 제가 개발하려고 하는 것은 coinId별로 달라지는 nested route로 약간 골치아프니, 실습을 위해 간단하게만 구현해보겠습니다. 방법론 먼저, router.js를 아래처럼 작성합니다. 정확하게 개발하려면 onpopstate 부분을 조금 손봐줘야 하겠지만, 본 앱은 단 두 개의 페이지로만 이뤄지므로 home()을 렌더링하도록 했습니다. 다음으로는 home.js, coinDetail.js를 각각 이렇게 짜줍니다. home.js coinDetail.js 보시다시피 window.history.pushState()를 이용해 history에 push해주면서 route를 관리합니다. 마지막으로, index.html에서 router.js를 불러와 initiating 합니다. index.html 핵심 로직은 완성됐습니다. 이제 css작업을 하면 됩니다. (css는 본문에서 생략하겠습니다. 코드를 보고 싶으시다면 여기를 참고해주세요.) 결과물 아래가 결과물입니다. 직접 눌러보세요. 잘 작동하네요! "},{"slug":"Webpack이란","title":"Webpack이란?","date":"2022-08-14","content":"bundler의 대표주자 Webpack이 무엇인지, Core Concepts를 확실하게 정리해두려고 합니다. 본 글은 Webpack Docs와 생활코딩님의 강의를 참고해 작성했습니다. Overall webpack은 모던 JS 어플리케이션을 위한 static module bundler입니다. webpack이 앱을 처리할 때, 하나 이상의 진입점(entry point)에서 종속성 그래프(dependency graph)를 내부적으로 작성하고, 프로젝트에 필요한 모든 모듈을 하나 이상의 번들로 만듭니다. 조금 어려운 용어가 많습니다. 차근 차근 뿌셔보겠습니다. 뿌셔보기 webpack을 이해하려면 webpack이 개발되기 전의 상황을 보아야 합니다. bundler index.html src/hello.js src/world.js webpack이 없었을 때 모듈을 export, import하던 방법입니다. 각각의 자바스크립트에서 명시적으로 export해야만 word라는 변수를 사용할 수 있습니다. 여기에는 두가지 문제가 있습니다. 오래된 브라우저에서는 작동하지 않습니다.만약 모듈이 수 십, 수 백 개의 스크립트 뿐만 아니라 css, 이미지 등의 다른 정적 파일까지 있었다고 가정하면, 많은 컴퓨팅 파워가 들어갔을 것입니다. 이는 결국 부하를 발생시키고, 속도가 느려지니 사용자 경험이 안좋아질 것이고, 서비스를 제공하는 측에 입장에서도 비용이 많이 들게 됩니다. 이에, '웹에서도 모듈의 개념을 이용하자', '여러개의 파일을 하나로 묶어서 제공하자'라는 의견이 나와 개발된 것이 바로 bundler입니다. webpack은 bundler의 대표주자이고요. dependency graph 한 파일이 다른 파일에 종속될 때마다 webpack은 '종속성 그래프'를 자동으로 생성합니다. 이를 통해 이미지, 웹 폰트같은 코드 이외의 asset을 가져오고 어플리케이션의 종속성으로 제공할 수 있게 됩니다. webpack은 configuration file에 정의된 모듈 목록에서부터 처리를 시작합니다. 이를 진입점(start point)라고 부릅니다. 이 진입점으로부터 어플리케이션에 필요한 모든 모듈을 포함하는 종속성 그래프를 재귀적으로 구축하고, 모든 모듈을 소수의 bundle로 묶습니다. 이렇게 묶인 모듈들은 브라우저에서 번들 단위로 로드됩니다. Configuration File webpack의 configuration file을 그럼 실제로 한번 보겠습니다. webpack.config.js entry 내부적으로 생성되는 dependency graph를 어디서부터 만들기 시작할 지를 지정합니다. string | [string] 타입으로, 여러 entry point를 지정할 수 있습니다. default 값은 ./src/index.js입니다. output 출력 bundle 파일이 저장되는 경로와 파일 이름을 지정합니다. loader webpack의 핵심 기능이라고 볼 수 있습니다.  bundler는 이렇게 다양한 형태의 파일들을 간단하게 묶어주는 일을 합니다. 그 중에서도 webpack은 자바스크립트가 아닌 파일들조차 번들링을 해줍니다. 그 과정이 바로 loader를 통해 이뤄집니다. webpack을 얼마나 잘 다루는가에 대한 부분도 이 loader를 얼마나 다양하고 유연하게 사용할 수 있는가에 따라 갈린다고 합니다. 위의 config에 나와있는 .css를 load하는 부분은 아래의 패키지를 설치하면 사용할 수 있습니다. css-loader는 css를 모듈로서 불러올 수 있게 해주며, style-loader는 웹 페이지 안에 <style>태그로 주입해주는 역할을 합니다. 즉, css를 로드할 때 따로 .css 파일을 받아오지 않더라도 html 파일 내에 이미 스타일이 들어가 있는 상태로 오므로 두개로 나눠서 올걸 하나로 합쳐서 준다는 거죠! 정리하면 loader는 입력한 asset들을 어떻게 가공해서 bundle로 만들지를 담당하는 녀석들입니다. plugin loader는 모듈을 어떻게 만들어갈까에 대한 부분이었다면, plugin은 그렇게 만들어진 bundle에 추가적으로 어떻게 가공할 지를 담당합니다. plugin마다 사용법이 제각기 다릅니다. 대표적인 plugin인 HTMLWebpackPlugin을 사용해 보겠습니다. HTML 파일을 템플릿 등을 이용해 더 쉽게 생성할 수 있도록 도와주는 플러그인입니다. 앞서 보았던 webpack.config.js로 돌아가보면, plugins에 HtmlWebpackPlugin()을 명시해 준 것을 볼 수 있습니다. 이렇게 하면 output이 담기는 dist/에 index.html이 아래처럼 자동으로 생성됩니다. entry point가 여러개라면 <script> 태그도 여러개 생성됩니다. 마무리 모던 자바스크립트 어플리케이션과 떼 놓을 수 없는 존재인 bundler, webpack에 대해 간단히 알아봤습니다. 저는 webpack을 직접 사용할 일은 많지 않을거라고 생각해 깊게 공부하지는 않았지만, 언젠가 한번 정리해봐야겠다 싶었는데 유익한 시간이였습니다. webpack은 bundling 외에도 lazy loading, code splitting 등을 지원하는데 이 개념은 Next.js를 공부하면서 배웠던 내용이라 신기합니다. 참고로 Next.js는 webpack5를 이용하는데, 원한다면 직접 webpack의 config를 바꿀 수 있다고 하네요. "},{"slug":"Open Graph Image, Thumbnail Generator 완성","title":"Open Graph Image, Thumbnail Generator 완성","date":"2022-08-11","content":"블로그를 Deploy 할 때마다 자동으로 썸네일, OG 이미지를 생성해 Firebase Store에 올리는 방법으로 해결했습니다. Intro 지난번 글에서 해결할 점으로 생각했던 부분 중 'Heroku 서버의 느린 응답 속도'를 resolve하고자 합니다. Idea 아래의 방법으로 flow를 바꿔서 해결하고자 했습니다. Deploy시 getStaticProps()에서 Heroku server로 이미지 생성을 요청합니다.Heroku server에서는 Firebase Store에 해당 이미지가 있는지 여부를 확인하고, 없다면 puppeteer를 이용해 이미지를 생성, Store에 저장합니다.저장된 이미지의 download url을 받아 response합니다.서버로부터 받은 url을 사용해 static page를 생성합니다. 직면했던 문제 Heroku에서 puppeteer로 생성한 스크린샷 이미지를 Firebase Store로 업로드할 때 Buffer 타입을 어떻게 Storage 서버로 전달할 지 고민하는 부분에서 조금 헤맸습니다. Firebase에서 제공하는 uploadBytes()함수는 ArrayBuffer를 업로드 할 수 있습니다. 따라서 Buffer를 ArrayBuffer로 바꾸면 됩니다. node.js 4.x 이상 부터는 Buffer가 UInt8Array의 subclass입니다.(참고) 따라서 .buffer로 ArrayBuffer를 간단하게 얻을 수 있었습니다. 이제 Deploy하는 것만으로 이미지가 생성되고 Firebase의 이미지 호스팅 URL을 얻을 수 있게 됐습니다 🙌 "},{"slug":"React, Express로 Open Graph Image, Thumbnail Generator 개발하기","title":"Heroku + React + Express로 Open Graph Image, Thumbnail Generator 개발하기","date":"2022-08-09","content":"블로그의 썸네일과 Open Graph Image를 매번 만드는 것은 여간 귀찮은 일이 아닙니다. Heroku, React, Express로 이 이미지를 자동으로 생성하는 api를 개발해봤습니다. Intro 블로그 글들에 썸네일이 없어 횡한데, 그렇다고 매번 썸네일을 만드는건 개발자답지 못한 방식이겠죠. 이걸 한번 자동화해보려고 합니다. 오늘은 그 첫 단계로 title, subtitle을 받아 썸네일 이미지를 생성하는 api를 만들었습니다. 방법론 TypeScript 환경으로 Express 서버 개발React Component로 html을 생성, react-dom/server의 renderToString() 함수를 이용해 생성된 html을 stringify했습니다.string으로 바뀐 html을 puppeteer 패키지를 활용해 이미지로 바꿉니다.respons head의 Content-Type을 image/png로 지정해줬습니다.image의 사이즈를 동적으로 바꾸는 것은 어렵지 않은 문제이지만 우선은 MVP 개발이므로 흔히 쓰이는 1200 X 630으로 고정했습니다.Heroku로 서버 Deploy원래는 간편하게 Vercel을 이용해 Deploy하려고 했으나, AWS Lambda의 50mb 용량 제한으로 불가능했습니다. 이에, Heroku로 배포하는 방법으로 선회했습니다.한글 폰트 깨짐 issue가 발생해, NotoSansKR 폰트를 static 파일로 읽어오는 코드를 추가했습니다.Deploy시 Heroku에서 puppeteer를 사용할 수 있도록 해주는 buildpack을 추가해줬습니다. TypeScript 환경으로 Express 서버 개발 React Component로 html을 생성, react-dom/server의 renderToString() 함수를 이용해 생성된 html을 stringify했습니다.string으로 바뀐 html을 puppeteer 패키지를 활용해 이미지로 바꿉니다.respons head의 Content-Type을 image/png로 지정해줬습니다.image의 사이즈를 동적으로 바꾸는 것은 어렵지 않은 문제이지만 우선은 MVP 개발이므로 흔히 쓰이는 1200 X 630으로 고정했습니다. Heroku로 서버 Deploy 원래는 간편하게 Vercel을 이용해 Deploy하려고 했으나, AWS Lambda의 50mb 용량 제한으로 불가능했습니다. 이에, Heroku로 배포하는 방법으로 선회했습니다.한글 폰트 깨짐 issue가 발생해, NotoSansKR 폰트를 static 파일로 읽어오는 코드를 추가했습니다.Deploy시 Heroku에서 puppeteer를 사용할 수 있도록 해주는 buildpack을 추가해줬습니다. 결과 Sample API https://og-img-generator-server.herokuapp.com/og/타이틀/서브타이틀  해결할 점 Heroku의 한계로 api가 이미지를 응답하는 속도가 매우 느립니다. (10초정도) 따라서, 실제로 사용하려면 다른 방법을 강구하거나, getStaticProps()에서 처리해 주어야겠습니다.좀 더 발전시켜서 유연한 Thumbnail / Open Graph Image Generator를 개발해보고 싶습니다. 2022.08.11 약간의 변경점이 있었습니다. 이 글을 참고해주세요! "},{"slug":"Next.js 블로그에 sitemap 생성하기","title":"Next.js 블로그에 sitemap 생성하기","date":"2022-08-06T17:23:00+09:00","content":"블로그를 검색엔진에 노출시키기 위해 sitemap을 생성하는 코드를 추가하겠습니다. What is Sitemap? 구글의 설명을 참고하면, 사이트맵은 사이트에 있는 페이지, 동영상 및 기타 파일과 그 관계에 대한 정보를 제공하는 파일입니다. 구글이나 네이버같은 검색 엔진들이 이 파일을 읽고 사이트를 더 효율적으로 크롤링할 수 있게 되죠. 필수적인 부분은 아니지만 SEO를 위해 생성해보도록 하겠습니다. npm package를 이용하면 간단합니다. next-sitemap next-sitemap은 Next.js 프레임워크로 생성된 사이트의 sitemap을 생성해주는 npm package입니다. 다른 방법들도 물론 많지만, 패키지를 이용하는게 가장 깔끔하고 간편한 방법입니다. 이 패키지를 사용하려면 루트 디렉토리에 next-sitemap.config.js를 추가해줘야 합니다. 여기에는 next-sitemap관련된 설정들이 들어가게 됩니다. 파일을 생성하고 tsconfig.json에 아래처럼 include에 추가해줍니다. 그리고 next-sitemap.config.js을 아래 코드로 채워줍니다. 설정할 수 있는 부분은 다양하게 있으므로 공식 문서의 Configuration Options를 참고합니다. 코드를 보시면 짐작하시겠지만 robots.txt까지 생성해줍니다. (환경변수로 개발환경에서의 URL을 넣어줄수도 있습니다.) robots.txt는 검색 엔진의 크롤링 봇에게 크롤링 권한을 부여해주는 파일입니다. 마지막으로 postbuild 스크립트를 package.json에 추가해주면 끝입니다. "},{"slug":"Next.js에서 styled-components 스타일을 늦게 불러오는 문제 해결하기","title":"Next.js에서 styled-components 스타일을 늦게 불러오는 문제 해결하기","date":"2022-08-05","content":"Next.js가 html을 불러올 때 JavaScript의 실행이 한 발짝씩 늦어서 styled-components로 지정된 스타일이 뒤늦게 로드되는 문제를 해결해보겠습니다. Intro  블로그를 처음 들어오면 이런 깜빡임이 보이는 문제가 있습니다. 자바스크립트에서 선언되는 styled-components의 스타일이 뒤늦게 로드되는건데요, 오늘은 이 문제를 해결해보려고 합니다. 해결 Next.js의 example을 참고했습니다! 1. styled-components용 Babel 플러그인 설치 devDependency로 설치합니다. 해당 플러그인은 첫 렌더링시에 styled-components를 이용해 스타일을 적용할 수 있게 해줄 뿐만 아니라, 컴포넌트의 hashed className을 환경간 일관되게 유지해줍니다. (SSR에는 필수적으로 필요) 2. ServerStyleSheet을 _document.tsx에 추가 기존에 이미 만들어뒀던 _document.tsx에 아래 코드를 추가합니다. _document.tsx는 <html>태그나 <body>태그에 접근할 수 있도록 해줍니다. 번들러로 처음 만들었을 때는 없는데, 커스텀이 필요할 때 생성합니다. 저는 Google Fonts를 로드하는 부분 때문에 미리 만들어뒀었습니다. MyDocument 클래스(Document를 상속하는 클래스입니다)의 getInitialProps() 함수를 정의합니다. 여기에서 ServerStyleSheet를 생성해 모든 페이지에 대해 스타일을 모으고, <App>에 prop으로 넘겨주는 식입니다. 이제 MyDocument에서 <Head>에 아래 한 줄을 추가하면 됩니다. 이제 깜빡임도 사라지고 더 부드럽게 돌아가는 블로그가 됐습니다 😄 "},{"slug":"블로그에 Firebase로 댓글 기능 추가해보기","title":"블로그에 Firebase로 댓글기능 개발하기","date":"2022-08-04","content":"Next.js를 이용해 이쁜 블로그를 개발했는데, 아직 댓글 기능이 없네요. 외부 서비스를 이용하지 않고 직접 개발해보려고 합니다. Intro 보통 블로그를 개발할 때 사용하는 댓글 플랫폼으로는 Utterance, Disqus 등이 있습니다.   Utterence가 이쁘고 Markdown 입력도 가능해서 좋은데, 깃헙 로그인만 지원하는 문제가 있습니다. (댓글들은 특정 레포지토리의 issue로 관리된다는 킬러 기능이 있긴 하지만요) 로그인 없이, 간단하게 댓글을 남길수만 있었으면 좋겠다! 불필요한 로그인을 강요하고 싶지 않았기에 간단하게 닉네임과 댓글만 입력하면 되는 댓글 기능을 개발해보고자 합니다. Firebase Firebase는 구글에서 제공하는 개발 플랫폼입니다. 저는 댓글을 저장하는 Backend로 아주 간편한 Firestore를 이용하기로 했습니다. Firebase Console에서 블로그 앱을 추가하며 시작합니다. DB Scheme Firestore는 요즘 핫한 NoSQL 클라우드 데이터베이스입니다. 일반적인 RDB와는 달리 Collection과 Document로 구성된 모양인데요, 저는 아래와 같이 설계했습니다. 추후 좋아요 등의 추가 기능이 필요하다면 comments collection 내의 docs들에 data를 붙여주면 됩니다. 개발 환경 설정 Firestore의 데이터 접근 규칙을 약간 손봐주고, 다음으로 할 일은 블로그에 firebase module을 불러오는 일입니다. 저는 아래와 같이 firebase와 firestore를 initialize하는 코드를 추가했습니다. firebaseConfig에 들어갈 환경변수들은 .env로 관리합니다. 추후 Vercel에서 배포할 때 Vercel에 환경변수들을 추가해주면 됩니다. 개발 환경을 위해 로컬에도 .env파일을 root 디렉토리에 두었습니다. 참고로, Next.js에서 환경변수들 중 클라이언트에 노출돼도 되는 값들 앞에는 NEXT_PUBLIC_이라고 붙여줘야 합니다. 댓글 개발 시 댓글 데이터에 접근하는 주체는 Web Server가 아닌 클라이언트이므로 저는 이렇게 붙여줬습니다. Doc 생성, 수정, 삭제 이것 또한 정말 간단합니다. 예시로 Comment를 추가하는 코드를 보여드리겠습니다. 눈여겨 보실 부분은 commentCollectionRef입니다. collection, doc, collection, ... 이 반복돼 collection reference를 선언하고, 여기에 추가할 doc을 object형태로 넘겨주면 됩니다. 삭제나 수정 또한 간단합니다. 생성과는 달리 collection이 아닌 특정 doc에 대한 레퍼런스를 선언하고, deleteDoc(), updateDoc() 함수를 사용하면 됩니다. updateDoc()에서는 수정되는 data만 object에 넣어주면 됩니다. (기존에 없던 key에 대한 데이터여도 updateDoc()을 이용해 추가할 수 있습니다.) Doc 실시간 업데이트 Firestore의 강력한 기능 중 하나는 바로 '실시간 업데이트'가 가능하다는 점입니다. 저는 댓글을 불러오는 부분에 아래와 같이 코드를 작성해 실시간으로 수정되는 데이터를 불러오도록 했습니다. onSnapshot() 함수로 실시간 업데이트하길 원하는 collection을 지정하면 됩니다. 저는 거기에 더해 댓글을 생성시간순으로 정렬하고, 랜덤으로 생성된 doc의 id를 추가로 읽어왔습니다. 댓글 기능 개발, CSS 작업 이후로는 끝없는 CSS와 기능 개발의 연속입니다. 딱히 어려운 부분이 없는 로직이라 고민 자체는 오래 걸리지 않았는데, 이것 저것 구현할 것이 있다보니 시간이 조금 걸렸습니다. 특히, 비밀번호를 요구해야 하는 부분 때문에 코드가 조금 더러워졌는데, 추후 클린코드 한번 싹 해줘야겠습니다. 자세한 코드는 본 블로그 레포지토리를 참고해주세요. 결과물은 여러분이 보고 계시는 이 아래의 댓글창입니다. 원하던 모습이 나온 것 같아요. 댓글 비밀번호 설정, 수정 혹은 삭제 시 비밀번호 입력 등이 잘 구현돼서 아주 만족합니다. 보안은 취약하지만 이정도면 간단한 블로그 댓글 기능으로 충분합니다. ToDos 댓글별 좋아요 카운터답글 기능댓글 Pagenation 특히 댓글 Pagenation은 가장 먼저 추가로 개발해야 할 부분입니다. 아직 블로그 글조차 Pagenation이 안되고 있으니, 추후 해당 기능 개발 시에 같이 완성해 나가야겠네요! "},{"slug":"React, TypeScript Container Component 만드는법","title":"React + TypeScript Container Component 만드는법","date":"2022-08-02","content":"React.js에서 TypeScript를 사용할 때 다른 컴포넌트를 감싸는 컴포넌트는 어떻게 선언할 수 있을까요? TIL TypeScript에서 prop으로 children Component를 받을 수 있게 하면 됩니다. 이 때, prop의 타입은 아래와 같이 지정해줬습니다. 사용 아주 간단하죠!😃 "},{"slug":"코테용 Python3 문법 정리","title":"코테용 Python3 문법 / 모듈 정리","date":"2022-08-01","content":"코딩테스트를 준비하며 정리한 유용한 Python3 문법 / 모듈들입니다. input 입력 개수가 한 개여도 input()보다 sys.stdin.readline()이 더 빠르다. 타입캐스팅 없이 문자열로 사용할 경우 반드시 .rstrip()함수를 호출해 줄바꿈 기호를 제거해야 한다. append 빈 리스트에 append보다는 초기화된 리스트에 인덱스로 접근해 입력하는것이 더 빠르다. list.append()의 반환은 null이다. print 줄바꿈할 때는 print()가 아니라 \\n을 이용해 한번에 출력하자. sorted key 속성으로 정렬 기준을 명시할 수 있다. reverse 속성으로 정렬을 뒤집을 수 있다. sorted()보다 list.sort()가 더 빠르다. 단, 이 경우 반환값은 null이다. itertools itertools.permutations iterable 객체에서 r개의 데이터를 뽑아 일렬로 나열하는 모든 경우(순열)를 계산해준다. itertools.combinations iterable 객체에서 r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모든 경우(조합)를 계산해준다. itertools.product iterable 객체에서 r개의 데이터를 중복하여 뽑아 일렬로 나열하는 모든 경우를 계산해준다. itertools.combinations_with_replacement iterable 객체에서 r개의 데이터를 중복하여 뽑아 순서를 고려하지 않고 나열하는 모든 경우를 계산해준다. random random()은 0 ~ 1을 리턴한다. 범위 지정 난수는 random.randrange(a, b)이며, a이상 b 미만 난수를 리턴한다. random.shuffle(a)는 iterable 객체 a를 섞는다. random.choice(a)는 iterable 객체 원소 중 하나를 뽑는다. collections collections.Counter dict를 이용한 카운팅이 필요할 때 써먹으면 아주 유용하다. dictionary를 확장하고 있기 떄문에 dict type의 API를 모두 사용할 수 있다. Counter().most_common() 메서드를 사용하면 데이서 개수가 많은 순으로 정렬된 배열을 리턴한다. collections.defaultdict 디폴트값이 정해지는 dict collections.deque Queue를 구현할 수 있는 라이브러리이다. 데이터의 삽입, 삭제가 list에 비해 효율적이다. dict sort dict를 Key 기준으로 정렬하기 - dict.items()는 [(key, value), ...] 형식의 Tuple Pair로 이루어진 리스트를 리턴한다. dict.items()와 sort()의 key 인자를 적절히 사용하여 원하는 정렬이 가능하다. 투플 리스트를 이용해 생성 투플로 이뤄진 리스트를 이용해서도 생성할 수 있다. zip() 함수와 같이 이용하면 강력하다. map(function, iterable) iterable의 각 원소를 function에 대입해 함수를 실행한다. map을 리턴하므로 list 혹은 tuple로 형변환해 사용해야 한다. function에 lambda함수도 대입이 가능하다. filter(function, iterable) function의 값에 따라 iterable을 filter하는 함수. filter를 리턴하므로 list 혹은 tuple로 형변환해 사용해야 함. map과 마찬가지로 lambda함수를 사용하는것이 편할 것. zip() 여러개의 iterable들을 인자로 받아 각 객체의 원소를 tuple의 형태로 묶어 iterable로 반환한다. 여러 그룹의 데이터를 한 번의 루프로 처리할 수 있다. zip()을 이용해 묶은 데이터를 다시 해체할 수도 있다. math math.floor() 버림 math.ceil() 올림 enumerate 예시 보면 바로 알 수 있음 겁나 유용함 "},{"slug":"Next.js로 블로그 개발하기","title":"Next.js로 블로그 개발하기","date":"2022-07-31","content":"이전까지 방치돼있던 제 jekyll을 이용한 블로그를 싹 지우고, 완전히 처음부터 모든 것을 만들어 보려 합니다. 100% 나만의 블로그를 개발해보자 단순히 React를 사용하는 것 뿐만 아니라, TypeScript, styled-components, recoil, react-query(필요할지는 모르겠지만) 등 지금까지 배운 기술들을 익히고, 무엇보다 애니메이션, 차트 등을 적극적으로 사용해 예쁜 블로그를 개발하겠습니다. CSS 프레임워크는 사용하지 않도록 하겠습니다. 드가즈아 Next.js 프레임워크 사용해보자 Blog라는 매체 특성상 굳이 CSR이나 SSR로 할 필요 없이 SSG로 하면 되므로 Gatsby를 보통 많이 사용하는 것 같던데 저는 공부 겸 Next.js를 사용하기로 했습니다. 넥스트로도 정적인 웹사이트는 만들 수 있습니다! "}]