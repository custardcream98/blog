[
  {
    "content": "React.js에서 TypeScript를 사용할 때 다른 컴포넌트를 감싸는 컴포넌트는 어떻게 선언할 수 있을까요? TIL TypeScript에서 prop으로 children Component를 받을 수 있게 하면 됩니다. 이 때, prop의 타입은 아래와 같이 지정해줬습니다. 사용 아주 간단하죠!😃 ",
    "date": "2022-08-02",
    "slug": "react-ts-container",
    "title": "React + TypeScript Container Component 만드는법"
  },
  {
    "content": "이전까지 방치돼있던 제 jekyll을 이용한 블로그를 싹 지우고, 완전히 처음부터 모든 것을 만들어 보려 합니다. 100% 나만의 블로그를 개발해보자 단순히 React를 사용하는 것 뿐만 아니라, TypeScript, styled-components, recoil, react-query(필요할지는 모르겠지만) 등 지금까지 배운 기술들을 익히고, 무엇보다 애니메이션, 차트 등을 적극적으로 사용해 예쁜 블로그를 개발하겠습니다. CSS 프레임워크는 사용하지 않도록 하겠습니다. 드가즈아 Next.js 프레임워크 사용해보자 Blog라는 매체 특성상 굳이 CSR이나 SSR로 할 필요 없이 SSG로 하면 되므로 Gatsby를 보통 많이 사용하는 것 같던데 저는 공부 겸 Next.js를 사용하기로 했습니다. 넥스트로도 정적인 웹사이트는 만들 수 있습니다! ",
    "date": "2022-07-31",
    "slug": "nextjs-blog-dev",
    "title": "Next.js로 블로그 개발하기"
  },
  {
    "content": "emmet(에멧) 사용법을 정리했습니다. 에멧을 잘 사용하면 HTML 작업 능률이 엄청 올라갑니다! emmet(에멧) cheat sheet 에멧은 HTML 태그를 CSS 입력하듯 쓸 수 있게 도와주는 스니펫입니다. 부모 > 자식 element nav>ul>li 남매 element div+p class div.awesome 여러 개도 됩니다. id div#awesome 내용 넣기 h1{Hello} 여러 개 만들기 span*3 Item Numbering h$*3 ul>li.item-$.row-$*3 Lorem ipsum lorem: 한 문단 생성lorem5: 다섯 단어 생성lorem*3: 세 문단 생성 저는 한 문단 한글 lorem ipsum도 스니펫으로 추가해뒀습니다. img img:z Attribute a[href='https://custardcream.vercel.app'] Climb-up div>span+a^p ",
    "date": "2022-08-30",
    "slug": "emmet-summary",
    "title": "emmet(에멧) 정리!"
  },
  {
    "content": "Scalable Vector Graphics의 사용법을 간략하게 정리했습니다. SVG, Scalable Vector Graphics XML 기반의 2차원 벡터 그래픽으로, HTML 요소로 이뤄져 있어 CSS와 JavaScript로 컨트롤 할 수 있습니다. 벡터이기 때문에 확대해도 깨지지 않으며 크기를 키워도 용량이 늘어나지 않습니다. 코드로 이뤄진 이미지이기 때문에 복잡할수록 사이즈가 기하급수적으로 커집니다. 단순한 아이콘이나 로고, 도형 등을 구현할 때 많이 사용합니다. 사용법 <img> 요소로 넣기CSS background로 넣기인라인으로 구현하기: SVG 코드를 그대로 HTML 안에 넣습니다.<object> 요소 사용하기: 아래처럼 <object> 요소로 넣으면 내부 요소에 접근할수도 있습니다. 내부 요소 조작이 필요하면 3, 4번 방법을, 그렇지 않다면 1, 2번 방법을 사용하면 됩니다. SVG 컨트롤 하기 SVG 코드를 이루는 요소는 당연히 class를 부여할 수 있습니다. 이렇게 부여한 class를 가지고 CSS를 이용해 스타일을 줄 수 있습니다.  ",
    "date": "2022-09-27T18:09:00+09:00",
    "slug": "svg-usage-summary",
    "title": "SVG 사용법 정리"
  },
  {
    "content": "블로그를 Deploy 할 때마다 자동으로 썸네일, OG 이미지를 생성해 Firebase Store에 올리는 방법으로 해결했습니다. Intro 지난번 글에서 해결할 점으로 생각했던 부분 중 'Heroku 서버의 느린 응답 속도'를 resolve하고자 합니다. Idea 아래의 방법으로 flow를 바꿔서 해결하고자 했습니다. Deploy시 getStaticProps()에서 Heroku server로 이미지 생성을 요청합니다.Heroku server에서는 Firebase Store에 해당 이미지가 있는지 여부를 확인하고, 없다면 puppeteer를 이용해 이미지를 생성, Store에 저장합니다.저장된 이미지의 download url을 받아 response합니다.서버로부터 받은 url을 사용해 static page를 생성합니다. 직면했던 문제 Heroku에서 puppeteer로 생성한 스크린샷 이미지를 Firebase Store로 업로드할 때 Buffer 타입을 어떻게 Storage 서버로 전달할 지 고민하는 부분에서 조금 헤맸습니다. Firebase에서 제공하는 uploadBytes()함수는 ArrayBuffer를 업로드 할 수 있습니다. 따라서 Buffer를 ArrayBuffer로 바꾸면 됩니다. node.js 4.x 이상 부터는 Buffer가 UInt8Array의 subclass입니다.(참고) 따라서 .buffer로 ArrayBuffer를 간단하게 얻을 수 있었습니다. 이제 Deploy하는 것만으로 이미지가 생성되고 Firebase의 이미지 호스팅 URL을 얻을 수 있게 됐습니다 🙌 ",
    "date": "2022-08-11",
    "slug": "og-image-thumbnail-gen",
    "title": "Open Graph Image, Thumbnail Generator 완성"
  },
  {
    "content": "블로그를 검색엔진에 노출시키기 위해 sitemap을 생성하는 코드를 추가하겠습니다. What is Sitemap? 구글의 설명을 참고하면, 사이트맵은 사이트에 있는 페이지, 동영상 및 기타 파일과 그 관계에 대한 정보를 제공하는 파일입니다. 구글이나 네이버같은 검색 엔진들이 이 파일을 읽고 사이트를 더 효율적으로 크롤링할 수 있게 되죠. 필수적인 부분은 아니지만 SEO를 위해 생성해보도록 하겠습니다. npm package를 이용하면 간단합니다. next-sitemap next-sitemap은 Next.js 프레임워크로 생성된 사이트의 sitemap을 생성해주는 npm package입니다. 다른 방법들도 물론 많지만, 패키지를 이용하는게 가장 깔끔하고 간편한 방법입니다. 이 패키지를 사용하려면 루트 디렉토리에 next-sitemap.config.js를 추가해줘야 합니다. 여기에는 next-sitemap관련된 설정들이 들어가게 됩니다. 파일을 생성하고 tsconfig.json에 아래처럼 include에 추가해줍니다. 그리고 next-sitemap.config.js을 아래 코드로 채워줍니다. 설정할 수 있는 부분은 다양하게 있으므로 공식 문서의 Configuration Options를 참고합니다. 코드를 보시면 짐작하시겠지만 robots.txt까지 생성해줍니다. (환경변수로 개발환경에서의 URL을 넣어줄수도 있습니다.) robots.txt는 검색 엔진의 크롤링 봇에게 크롤링 권한을 부여해주는 파일입니다. 마지막으로 postbuild 스크립트를 package.json에 추가해주면 끝입니다. ",
    "date": "2022-08-06T17:23:00+09:00",
    "slug": "nextjs-blog-sitemap",
    "title": "Next.js 블로그에 sitemap 생성하기"
  },
  {
    "content": "Next.js가 html을 불러올 때 JavaScript의 실행이 한 발짝씩 늦어서 styled-components로 지정된 스타일이 뒤늦게 로드되는 문제를 해결해보겠습니다. Intro  블로그를 처음 들어오면 이런 깜빡임이 보이는 문제가 있습니다. 자바스크립트에서 선언되는 styled-components의 스타일이 뒤늦게 로드되는건데요, 오늘은 이 문제를 해결해보려고 합니다. 해결 Next.js의 example을 참고했습니다! 1. styled-components용 Babel 플러그인 설치 devDependency로 설치합니다. 해당 플러그인은 첫 렌더링시에 styled-components를 이용해 스타일을 적용할 수 있게 해줄 뿐만 아니라, 컴포넌트의 hashed className을 환경간 일관되게 유지해줍니다. (SSR에는 필수적으로 필요) 2. ServerStyleSheet을 _document.tsx에 추가 기존에 이미 만들어뒀던 _document.tsx에 아래 코드를 추가합니다. _document.tsx는 <html>태그나 <body>태그에 접근할 수 있도록 해줍니다. 번들러로 처음 만들었을 때는 없는데, 커스텀이 필요할 때 생성합니다. 저는 Google Fonts를 로드하는 부분 때문에 미리 만들어뒀었습니다. MyDocument 클래스(Document를 상속하는 클래스입니다)의 getInitialProps() 함수를 정의합니다. 여기에서 ServerStyleSheet를 생성해 모든 페이지에 대해 스타일을 모으고, <App>에 prop으로 넘겨주는 식입니다. 이제 MyDocument에서 <Head>에 아래 한 줄을 추가하면 됩니다. 이제 깜빡임도 사라지고 더 부드럽게 돌아가는 블로그가 됐습니다 😄 ",
    "date": "2022-08-05",
    "slug": "nextjs-styled-late-load",
    "title": "Next.js에서 styled-components 스타일을 늦게 불러오는 문제 해결하기"
  },
  {
    "content": "뭔가 뿌듯했던 셋째주였어요! 회고 이번 주에 있었던 일 1만 시간의 법칙 과제를 하고 유진님께 받은 피드백으로 고쳐나갔습니다.정말 좋은 경험이어서 아주 자세히 글을 써봤어요!시간이 너무 많이 걸려서 앞으로 어떤 식으로 기록할지 고민됩니다.회고조 활동에 대해 여러모로 많이 고민해보고 회의했어요!매일 커밋 ✅맨날 미루는 성격을 이겨내고 과제를 일찍 마무리했어요 👏함께 자라기 스터디를 했는데 좋은 바이브를 얻어갈 수 있었어요.스터디에서 배운 내용중에 실수 기록을 작성하기 시작했어요. 아직 많이 쌓이지는 않았지만 실수, 삽질, 하마터면 사건들을 많이 기록하려고 해요.코어 자바스크립트 스터디에 들어갔어요! 정말 좋은 경험이어서 아주 자세히 글을 써봤어요!시간이 너무 많이 걸려서 앞으로 어떤 식으로 기록할지 고민됩니다. 스터디에서 배운 내용중에 실수 기록을 작성하기 시작했어요. 아직 많이 쌓이지는 않았지만 실수, 삽질, 하마터면 사건들을 많이 기록하려고 해요. 기억에 남는 일 금요일 특강을 해주신 이수진 개발자님께 용기내서 페어프로그래밍 요청 드려봤어요! 10월중에 하기로 했는데 정말 기대돼요.게더타운에서 게임을 많이 했는데 다들 목소리 들으니까 좋았어요ㅎㅎ 아쉬웠던 점 지난주에 계획했던 운동은 상상도 못했어요... 너무 힘들어...블로그 글을 열심히 작성한건 좋은데 너무 시간을 많이 쏟은 것 같아요. 조절좀 해야겠습니다. 다음주 할 일과 다짐 자바스크립트 딥다이브 10장까지 나가기코어 자바스크립트 공부 계획 세우기페어 프로그래밍 해보기: 멋사분들과 페어프로그래밍 직접 해보고싶어요! 이번주에 정리한 내용 딥다이브 시작: 자바스크립트 intro딥다이브 4장: 변수딥다이브 5장: 표현식과 문1만 시간의 법칙 반응형 웹 개발 및 피드백 ",
    "date": "2022-09-18",
    "slug": "likelion-frontend-week3",
    "title": "멋사 프론트엔드 스쿨 3주차 회고"
  },
  {
    "content": "벌써 한 달이나 지났네요... 시간 참 빠르다 회고 이번 주에 있었던 일 이번주에는 글을 많이 쓰지는 못했어요. 점점 시간이 부족해지네요...매일 커밋하지는 못했지만 알차게 공부했으니 후회는 없어요!처음으로 멋사 동료분들을 오프라인에서 만나뵀어요.금요일에는 회고조 조장 커피챗 모임을 하고 처음으로 페어 프로그래밍을 해봤어요. 멋사 직원분들 직접 뵈니까 좋았어요! 페어 프로그래밍도 잘 될까 걱정이 많았는데 다들 너무너무 잘 적응해주셔서 보람있는 시간이었어요.토요일에는 회고조 분들과 회식을 했어요. 치킨 먹고 보드게임 카페를 갔는데 다들 훨씬 친해진 것 같아요. 다음번엔 술을...ㅋㅋㅋ인터넷 친구같은 느낌이었는데 얼굴 보니까 좋네요! 금요일에는 회고조 조장 커피챗 모임을 하고 처음으로 페어 프로그래밍을 해봤어요. 멋사 직원분들 직접 뵈니까 좋았어요! 페어 프로그래밍도 잘 될까 걱정이 많았는데 다들 너무너무 잘 적응해주셔서 보람있는 시간이었어요.토요일에는 회고조 분들과 회식을 했어요. 치킨 먹고 보드게임 카페를 갔는데 다들 훨씬 친해진 것 같아요. 다음번엔 술을...ㅋㅋㅋ인터넷 친구같은 느낌이었는데 얼굴 보니까 좋네요! 기억에 남는 일 과제를 할 때 마크업을 꽤 심도있게 고민하는 내 모습을 보고 뿌듯했어요. 한 달 전까지만 해도 아무 생각 없이 하던 부분인데 이해하고 내 것으로 만들어나가니 불안감이 점점 해소되는 것 같아요.페어 프로그래밍 경험이 정말 좋았어서 정기적으로 해보고 싶을 정도!! 아쉬웠던 점 공부한 내용을 잘 정리하지는 못한 것 같아요. 딥다이브도 공부할 시간을 내기가 쉽지 않네요ㅠㅠ코어 자바스크립트 공부는 일단 보류하기로 했어요. 당장 딥다이브 공부할 시간도 내기 힘들고, 코어 자바스크립트는 나중에 JS를 더 깊게 공부한 뒤에 다시 보면 좋을 내용같았어요. 다음주 할 일과 다짐 자바스크립트 딥다이브 조금이라도 공부하기코테 문제 조금이라도 풀기 이번주에 정리한 내용 CSS 실무 테크닉 ",
    "date": "2022-09-25",
    "slug": "likelion-frontend-week4",
    "title": "멋사 프론트엔드 스쿨 4주차 회고"
  },
  {
    "content": "4주만에 적는 회고록 회고 지금까지 있었던 일 연구실 업무로 열심히 개발하던 설문 웹페이지 드디어 완성했습니다.데모 페이지난관이 너무나 많았는데 완성하니 아주 뿌듯해요. TypeScript는 이제 많이 익숙해진 것 같아요.혼자 처음부터 끝까지 개발하는게 쉽진 않았지만 기존에는 잘 없던 특이한 유형의 설문조사를 구현했고, (슬라이더, 영상 선택 및 점수 부여하기 등 두가지 유형) Python으로 개발돼있던 복잡한 로직의 일관성 검사 로직을 TypeScript로 성공적으로 마이그레이션 해냈어요.이 일 때문에 정말 바쁘게 지냈는데, 막상 끝내고나니 뭔가 허전한...나름 여러가지 자잘한 코딩도 많이 했던거같아요. 확실히 4주 전보다 많이 성장했단게 느껴져요.멋사 팀 분배를 위한 테스트도 보고, 당근마켓 인턴도 지원해보고, 프로그래머스 데브매칭도 도전해봤어요. 아직 결과가 나온건 아무것도 없지만 모두 좋은 경험!! 데모 페이지난관이 너무나 많았는데 완성하니 아주 뿌듯해요. TypeScript는 이제 많이 익숙해진 것 같아요.혼자 처음부터 끝까지 개발하는게 쉽진 않았지만 기존에는 잘 없던 특이한 유형의 설문조사를 구현했고, (슬라이더, 영상 선택 및 점수 부여하기 등 두가지 유형) Python으로 개발돼있던 복잡한 로직의 일관성 검사 로직을 TypeScript로 성공적으로 마이그레이션 해냈어요.이 일 때문에 정말 바쁘게 지냈는데, 막상 끝내고나니 뭔가 허전한... 기억에 남는 일 팀원분들이 '저 덕분에 ~를 이해할 수 있었다' 같은 말을 해줄때 엄청 뿌듯했어요. 다른 분들께 제가 아는걸 설명하면서 저 자신도 개념을 정리하는게 저한테 잘 맞는 공부법인거같았는데, 회고조원들도 좋았다고 해주셔서 다행이에요. 아쉬웠던 점 아쉬운건 없어요! 매일 매일 성장하고 있다는 느낌이 드는 요즘입니다.굳이 꼽자면 코테 준비를 철저히 못한것...? 할 일과 다짐 코테 준비 열심히 계속하자!개인 프로젝트, 팀 프로젝트 모두 무사히 잘 진행될 수 있도록 열심히!!번아웃 조심하자. 몸은 엄청 피곤한듯... ",
    "date": "2022-11-14",
    "slug": "likelion-frontend-week11",
    "title": "멋사 프론트엔드 스쿨 11주차 회고"
  },
  {
    "content": "매번 Git을 편하게 쓰고 싶어서 GUI로만 다뤄왔는데, Git 명령어를 정리해 CLI 환경에서도 Git을 얼마든지 사용할 수 있게 공부했습니다. Git이란 공식 문서 소스코드, 파일 등의 변경 내역을 저장하는 분산 버전 관리 시스템Git을 기반으로 하는 버전 관리 호스팅 서비스들이 많이 나와 있습니다. 대표적으로 GitHub, Bitbucket, Gitlab 등이 있습니다. 여기에서는 용어 설명보다는 명령어 위주로 기록하려고 합니다. Git을 처음 설치한 경우 GitHub 연결 2021년 8월 13일부터 비밀번호가 아닌 token이나 SSH로만 연결이 가능하게 바뀌었습니다. GitHub에서 token을 발급받거나, SSH 키를 등록하는 등의 과정을 거쳐야 합니다. 참고로, master라는 기본 브랜치 이름은 main으로 바꿔 사용하는 추세라고 합니다. 노예제를 떠올리게 한다는 이유라고 하네요. git clone 원격 저장소의 코드를 로컬로 받아오는 명령어입니다. git clone과 git remote가 헷갈릴 수 있는데요, git remote add origin는 특정 원격 저장소의 레퍼런스(origin)를 만드는 명령어이고, 여기에 git push -u origin main을 하면 origin 원격 저장소의 main 브랜치에 로컬에서 현재 선택돼 있는 브랜치를 연결한다는 의미입니다. 반면 git clone은 클론 대상인 원격 저장소를 복사해서 새로운 저장소를 로컬에 생성합니다. 그래서 git init 명령어를 사용해 저장소를 새로 시작할 필요가 없습니다. 따라서 타인의 저장소를 클론해 온 후, git remote add로 내 저장소와 연결하면 내 저장소에 push가 가게 됩니다. 자주 쓰이는 명령어 git pull 원격 저장소에 업데이트 된 데이터를 받아오고, 병합합니다. 코드 수정 후 push 하려는데 다른 사람이 이미 push해서 pull 받아야 하는 경우 이 경우 그냥 push하면 pull을 받지 않았기 때문에 오류가 발생합니다. 아래의 방법 중 하나로 병합하면 됩니다. git add, commit, push 원격 저장소와 로컬 저장소의 싱크가 맞지 않아 로컬 저장소로 강제로 맞추고 싶다면 아래처럼 --force 옵션을 추가하면 됩니다. 혼자만의 저장소일 때만 쓰고, 절대로 협업시에는 사용하면 안됩니다. ",
    "date": "2022-09-01",
    "slug": "git-cli-summary1",
    "title": "Git CLI 명령어 정리 1"
  },
  {
    "content": "둘째주가 되니까 슬슬 계획대로 안되기 시작합니다... 회고 여전히 정신없는 한 주가 또 지났는데, 언제나 그랬지만 이번주도 전혀 계획한대로 흘러가지는 않았어요!ㅠㅠ 이번 주에 있었던 일 블로그에 '시리즈' 기능을 붙이고 조금 더 시멘틱하게 바꿔봤어요.글 제목 위에 보시면 있는 조그맞게 있는 글씨가 바로 시리즈...입니다...ㅎㅎ,,,블로그 글 쓰다가 오 이거 필요하겠는데? 싶으면 쓰던 글 내팽겨치고 기능 개발하고 하다보니 TIL을 거의 못썼던게 좀 아쉬워요.시리즈가 있는 글에는 글 말미에 시리즈의 다른 글이 보이는 기능까지만 완성되면 이젠 정말로 글 내용에 집중하기로...매일 코테 한 문제씩은 풀었어요! 이건 좀 뿌듯멋사 붙캠 최종과제를 벌써 시작한 분이 계시다길래... 일단 자극받아서 저도 레포를 열어만 뒀어요. 흐흐처음으로 디자이너의 시안대로 웹사이트를 개발하는 과제, 1만 시간의 법칙을 JS까지 완성했어요. 다음주에 멘토님의 피드백을 받기로 했는데 기대됩니다.회고조 코드리뷰를 위한 깃헙 레포를 열고 협업 방법을 세워서 공유했어요. 방법 설명을 최대한 열심히 하려고 했는데 다들 잘 해주셔서 뿌듯해요. 저도 Git을 CLI 환경에서 사용하는 데에 아주 조금이나마 더 익숙해질 수 있어서 좋았어요. 글 제목 위에 보시면 있는 조그맞게 있는 글씨가 바로 시리즈...입니다...ㅎㅎ,,,블로그 글 쓰다가 오 이거 필요하겠는데? 싶으면 쓰던 글 내팽겨치고 기능 개발하고 하다보니 TIL을 거의 못썼던게 좀 아쉬워요.시리즈가 있는 글에는 글 말미에 시리즈의 다른 글이 보이는 기능까지만 완성되면 이젠 정말로 글 내용에 집중하기로... 기억에 남는 일 종찬님께 낸 과제중에 이런것도 대응이 됩니다를 어필하려고 간단하게 추가로 해봤던 내용이 종찬님의 '뭐임' 폴더에 들어가는 영광...ㅠㅠ 넘 부끄러웠어요 아쉬웠던 점 자바스크립트 딥다이브 스터디에서 시간맞춰 인증하지 못했어요. 이번주는 이런 식으로 시간 분배를 잘 못했던 것 같아서 너무 아쉬워요.TIL을 많이 정리하지는 못했던것도 아쉬워요,, 그래도 1일 1커밋은 지켰당 다음주 할 일과 다짐 이제 매일 아침에 운동...!! 꼭 할겁니다최종과제를 조금이라도 시작해보려고 해요.회고조 미팅을 진행해보려고 해요. 이번주에 정리한 내용 HTML Living Standard 1HTML Living Standard 2 ",
    "date": "2022-09-12",
    "slug": "likelion-frontend-week2",
    "title": "멋사 프론트엔드 스쿨 2주차 회고"
  },
  {
    "content": "드디어 JS 본격적으로 시작!! 회고 이번 주에 있었던 일 타스 집필팀 계획을 잡았습니다. 집필팀에서 기술 도우미(?)를 맡기로 했는데 도움이 될 수 있도록 더 열심히 해야겠네요!Sass 오류 잡고 공식 문서 contribution 도전하기: 알고보니 이미 공식 문서에 해당 내용이 있더라고요ㅎㅎ 비록 PR은 거절당했지만 좋은 경험이었습니다.이력서 특강에 맞춰서 수정하기천하제일 이력서 만들기 경진대회에 제출한 디자인을 바탕으로 내용을 채워봤습니다! 이력서 링크 각 기술별로 어떤것들을 할 수 있는지 서술도 추가하면 좋을 것 같아요.이력서 페이지 개발하면서 Tailwind를 처음으로 제대로 써봤는데 정말 신세계... 왜 좋다좋다 하는지 알 것 같아요.흐물이는 흐물흐물 캐릭터 만들기 (결과물) 천하제일 이력서 만들기 경진대회에 제출한 디자인을 바탕으로 내용을 채워봤습니다! 이력서 링크 각 기술별로 어떤것들을 할 수 있는지 서술도 추가하면 좋을 것 같아요.이력서 페이지 개발하면서 Tailwind를 처음으로 제대로 써봤는데 정말 신세계... 왜 좋다좋다 하는지 알 것 같아요. 기억에 남는 일 큰 오픈소스 프로젝트에 기여하기를 처음으로 도전해봤는데, 아쉽게도 실패했지만 정말 좋은 경험이었어요!! 다음엔 꼭 더 좋은 내용으로 기여해보겠습니다.캐릭터 경진대회, 이력서 경진대회 일정 안밀리고 잘 제출한점은 저 자신을 칭찬하고 싶어요. 아쉬웠던 점 집안일을 잘 못해서 집 상태가…개인 프로젝트나 개인 공부 등 멋사 외적인 활동을 거의 못한게 너무 아쉬워요ㅠㅠ 할 일과 다짐 뭐라도 시작해보자… 개인 프로젝트…!!!블로그 글 최소 두 개 이상 작성하기TS 책 집필 시작하기 영웅님께서 하신 말씀 중 '열심히 사는 것'과 '잘 사는 것'은 다르다는 말이 기억에 남아요. 지금까지 바쁘게만 해오고, 잘 하진 못한게 아닌가 다시 한번 돌아보면서 이번주부터는 바뀌어보려고 합니다!! 이번주에 정리한 내용 SVG 사용법 정리내용이 너무 부실하고 실속없어서 추후 글을 좀 보완해야 할 것 같아요. 과제하면서 제 글만 참고하고 해보려고 했더니 별로 도움이 안되더라고요.Sass 버전에 따라서 Equality Operator의 작동 결과가 달라진다? 내용이 너무 부실하고 실속없어서 추후 글을 좀 보완해야 할 것 같아요. 과제하면서 제 글만 참고하고 해보려고 했더니 별로 도움이 안되더라고요. ",
    "date": "2022-10-03",
    "slug": "likelion-frontend-week5",
    "title": "멋사 프론트엔드 스쿨 5주차 회고"
  },
  {
    "content": "코테 준비 본격적으로 시작한 주! 회고 이번 주에 있었던 일 연구실 업무가 막판에 몰려서 열심히 개발중입니다.지난주 회고를 작성하지 못한 이유도 연구실 + 멋사를 병행하다보니 정신도 없고 조금 지쳤었어요ㅠㅠ그래도 설문 페이지가 점점 완성도를 갖춰가고 있어서 뿌듯함을 느끼고 있습니다.Next를 활용해 개발하긴 했으나 오버스펙으로 개발한 것 같아서 조금 후회스럽기도 합니다.Tailwind CSS와 styled-components를 둘 다 사용하겠다는 바보같은 선택은 대체 왜 한건지!!설문자의 응답이 유효한지 여부를 검사하는 로직을 넣고, 백엔드에 결과를 전송하는 부분만 개발하면 마무리 될 듯 해요.백엔드를 맡은 친구가 제 시간 안에 완성해줄지 조금 걱정되네요.드디어 코테 문제를 풀어보기 시작했어요.일단은 프로그래머스 Lv.2만 쭉 풀어보고 있어요.풀리긴 하는데 뒤로 갈수록 시간이 늘어나고 있어요...ㅎㅎ 지난주 회고를 작성하지 못한 이유도 연구실 + 멋사를 병행하다보니 정신도 없고 조금 지쳤었어요ㅠㅠ그래도 설문 페이지가 점점 완성도를 갖춰가고 있어서 뿌듯함을 느끼고 있습니다.Next를 활용해 개발하긴 했으나 오버스펙으로 개발한 것 같아서 조금 후회스럽기도 합니다.Tailwind CSS와 styled-components를 둘 다 사용하겠다는 바보같은 선택은 대체 왜 한건지!!설문자의 응답이 유효한지 여부를 검사하는 로직을 넣고, 백엔드에 결과를 전송하는 부분만 개발하면 마무리 될 듯 해요.백엔드를 맡은 친구가 제 시간 안에 완성해줄지 조금 걱정되네요. 일단은 프로그래머스 Lv.2만 쭉 풀어보고 있어요.풀리긴 하는데 뒤로 갈수록 시간이 늘어나고 있어요...ㅎㅎ 기억에 남는 일 토요일에 GDSC Job Fair를 다녀왔어요. 여러 스타트업 부스 돌아다니면서 열심히 볼펜 수집해왔어요ㅋㅋ스타트업으로의 취업을 고려하고 있었는데 어떤 기준으로 기업을 바라볼지 저만의 관점을 찾을 필요성을 느꼈어요.코클(Cochl)이라는 기업의 인턴으로 지원해보고 싶다는 생각이 들었어요. 스타트업으로의 취업을 고려하고 있었는데 어떤 기준으로 기업을 바라볼지 저만의 관점을 찾을 필요성을 느꼈어요.코클(Cochl)이라는 기업의 인턴으로 지원해보고 싶다는 생각이 들었어요. 아쉬웠던 점 멋사 외적인 공부를 추가로 하지는 못했어요.연구실 업무를 마쳐야 하다보니 역대급으로 늦게잤어요. 매일 서너시에 자니까 낮에 수업도 졸고ㅠㅠㅠ 할 일과 다짐 계속해서 코테 꾸준히 풀어보자!!이번주는 그래도 조금이라도 일찍 자보자ㅠㅠ연구실 일 마무리짓자! 이번주에 정리한 내용 없음 😭 JS 과정 들어오니 블로그 글 작성할 거리도 잘 안보이네요...ㅎㅎ 빨리 웹브라우저 렌더링 과정 블로깅 해야하는데!! ",
    "date": "2022-10-17",
    "slug": "likelion-frontend-week7",
    "title": "멋사 프론트엔드 스쿨 7주차 회고"
  },
  {
    "content": "'값(value)', '표현식(expression)', '문(statement)' 등의 정확한 정의가 무엇인지 알아봅니다. 값(value) 값(value)은 표현식(expression)이 평가(evaluate)돼 생성된 결과를 말합니다. 평가란 식을 해석해 값을 생성하거나 참조하는 것을 의미합니다. 아래의 식은 '평가'돼 '값' 30을 생성합니다. 모든 값은 데이터 타입을 가지고, 메모리에 비트의 나열로 저장됩니다. 이렇게 저장된 값은 데이터 타입에 따라 다르게 해석됩니다. 위 코드에서 변수 value에 할당되는 것은 10 + 20이 아닌 그 평과의 결과인 30입니다. 값은 이 코드처럼 식을 통해 생성할 수도 있지만, 값을 생성하는 가장 기본적인 방법은 리터럴을 이용하는 것입니다. 리터럴(literal) 리터럴(literal)은 사람이 이해할 수 있는 문자 혹은 약속된 기호를 이용해 값을 생성하는 표기법(notation)을 말합니다. 이 코드에서 3은 단순히 숫자 3이 아니라 '숫자 리터럴'입니다. 사람이 이해할 수 있는 아라비아 숫자를 사용해 숫자 리터럴 3을 넣으면 JS 엔진은 이를 평가해 숫자 '값' 3을 생성합니다. 즉 리터럴은 사람이 이해할 수 있는 문자 또는 기호('', \"\", ,, ., [], {} 등)로 표기한 코드를 의미합니다. 값을 생성하기 위해 미리 약속한 일종의 표기법인 것입니다. 리터럴을 통해 다양한 타입의 값을 생성할 수 있습니다. 표현식(expression) 값으로 평가될 수 있는 모든 문(statement)을 말합니다. 표현식이 평가되면 새로은 값을 생성하거나 기존 값을 참조하게 됩니다. 방금 살펴본 리터럴도 값으로 평가되기 때문에 그 자체로 표현식입니다. 문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다는 점을 알아둡시다. 문(statement) 프로그램을 구성하는 기본 단위이자 최소 실행 단위를 말합니다. 명령문이라고도 부르며, 문의 집합이 곧 프로그램이고, 문을 작성하고 순서에 맞게 배치하는 것이 프로그래밍입니다. 하나의 문은 여러 토큰으로 구성됩니다. 이 때 토큰이란 문법적인 의미를 가지고 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미합니다. 여기에서 const, sum, =, 1, +, 2, ; 각각이 바로 토큰입니다. 세미콜론 ;은 문의 종료를 나타내는데 이는 생략이 가능합니다. JS 엔진에 문의 끝이라고 예측되는 지점에 자동으로 세미콜론을 붙여주는 ASI(Automatic Semicolon Insertion) 기능이 있기 때문입니다. ASI에 의존해도 될지 말아야 할지는 논쟁거리입니다. 대부분은 세미콜론 사용을 권장합니다. 표현식인 문과 표현식이 아닌 문 표현식은 문의 일부일 수도 있고, 그 자체로 문이 될 수도 있습니다. 값으로 평가될 수 있는지 없는지를 생각해보면 쉽게 구분할 수 있습니다. 표현식인 문은 값처럼 사용할 수 있습니다. ",
    "date": "2022-09-12T19:09:00+09:00",
    "slug": "deep-dive-ch5",
    "title": "딥다이브 5장: 표현식과 문"
  },
  {
    "content": "블로그의 navbar를 리뉴얼하는 과정에서 다크모드 스위치에 부여한 position fixed가 navbar 기준으로만 동작하는 문제를 해결하고자 했습니다. 문제상황 블로그의 navbar 디자인을 아주 살짝 바꾸고 있었는데, 화면이 작아질 경우 다크모드 스위치의 위치를 뷰포트 우하단으로 옮기고자 아래의 스타일을 추가했습니다. 그런데 이상하게도 아래처럼 동작했습니다.  .darkmode-switch 요소가 뷰포트 기준이 아닌 navbar 기준으로 위치하고 있는 상황으로 보였습니다. .darkmode-switch 요소는 navbar의 자식 요소긴 하나, position: fixed; 를 부여하면 뷰포트 전체를 기준으로 위치하도록 할 수 있을 거라고 생각했는데, 왜 이런 일이 벌어진걸까요? MDN 문서를 확인해보자 MDN 문서 (position: fixed;) MDN 문서에 따르면 fixed는 뷰포트의 초기 컨테이닝 블록, 즉 루트 요소를 기준으로 배치되도록 하는 property가 맞습니다. 그러나, 이런 내용이 있습니다. 요소의 조상 중 하나가 transform, perspective, filter 속성 중 어느 하나라도 none이 아니라면 뷰포트 대신 그 조상을 컨테이닝 블록으로 삼습니다. (perspective와 filter의 경우 브라우저별로 결과가 다름에 유의) 블로그의 navbar에는 backdrop-filter: blur(15px) 가 부여돼 있었는데 이로 인해 원치 않은 동작을 일으킨 것입니다. 즉 아래같은 상황인거죠.  부모 요소에 filter property를 지정한 상황입니다. 아마 위 예제의 핑크 박스(.child 요소)의 위치가 브라우저별로 다르게 보일 것입니다. 테스트해보니 Blink 엔진에서는 .parent 안에 위치하고, Webkit 엔진에서는 우하단에 위치하는 것을 확인할 수 있었습니다. (크롬과 사파리로 각각 본 포스트를 열어 직접 확인해보세요!) 즉, Blink 엔진에서는 부모의 filter property가 none이 아닐 때 자식에 position: fixed;를 부여하면 부모를 컨테이닝 블록으로 삼기 때문에 생기는 문제였습니다. Webkit 엔진에서는 문제가 없겠지만 Blink 엔진에서도 제대로 동작해야 하기에 다른 방법을 사용해 해결해보기로 했습니다. 해결 아이디어 부모 요소에 backdrop-filter property를 부여한 것이 원치 않는 동작을 일으키는 원인이 됐으므로 이를 제거하고, backdrop-filter를 부여할 배경 역할의 가상 요소를 추가하면 해결될 것입니다. 해결 코드 새로 만든 가상 요소에 z-index: -1; 을 줘서 .navbar-container가 생성하고 있는 stacking context(쌓임 맥락) 기준으로 가장 밑에 위치하도록 했습니다. navbar 안의 다른 요소들과 가상 요소는 형제 관계에 놓이기 때문에 문제가 해결됩니다. 앞선 예제로 예를 들면 아래와 같은 코드가 될 것입니다.  이제 Blink 엔진에서도 .child 요소의 위치가 원하던대로 뷰포트 기준 우하단에 위치하고 있습니다. 결과  이제 원하던대로 잘 동작하네요! ",
    "date": "2022-11-01",
    "slug": "filter-position-fixed",
    "title": "filter를 주면 position fixed 동작이 달라져요!"
  },
  {
    "content": "블로그의 썸네일과 Open Graph Image를 매번 만드는 것은 여간 귀찮은 일이 아닙니다. Heroku, React, Express로 이 이미지를 자동으로 생성하는 api를 개발해봤습니다. Intro 블로그 글들에 썸네일이 없어 횡한데, 그렇다고 매번 썸네일을 만드는건 개발자답지 못한 방식이겠죠. 이걸 한번 자동화해보려고 합니다. 오늘은 그 첫 단계로 title, subtitle을 받아 썸네일 이미지를 생성하는 api를 만들었습니다. 방법론 TypeScript 환경으로 Express 서버 개발React Component로 html을 생성, react-dom/server의 renderToString() 함수를 이용해 생성된 html을 stringify했습니다.string으로 바뀐 html을 puppeteer 패키지를 활용해 이미지로 바꿉니다.respons head의 Content-Type을 image/png로 지정해줬습니다.image의 사이즈를 동적으로 바꾸는 것은 어렵지 않은 문제이지만 우선은 MVP 개발이므로 흔히 쓰이는 1200 X 630으로 고정했습니다.Heroku로 서버 Deploy원래는 간편하게 Vercel을 이용해 Deploy하려고 했으나, AWS Lambda의 50mb 용량 제한으로 불가능했습니다. 이에, Heroku로 배포하는 방법으로 선회했습니다.한글 폰트 깨짐 issue가 발생해, NotoSansKR 폰트를 static 파일로 읽어오는 코드를 추가했습니다.Deploy시 Heroku에서 puppeteer를 사용할 수 있도록 해주는 buildpack을 추가해줬습니다. TypeScript 환경으로 Express 서버 개발 React Component로 html을 생성, react-dom/server의 renderToString() 함수를 이용해 생성된 html을 stringify했습니다.string으로 바뀐 html을 puppeteer 패키지를 활용해 이미지로 바꿉니다.respons head의 Content-Type을 image/png로 지정해줬습니다.image의 사이즈를 동적으로 바꾸는 것은 어렵지 않은 문제이지만 우선은 MVP 개발이므로 흔히 쓰이는 1200 X 630으로 고정했습니다. Heroku로 서버 Deploy 원래는 간편하게 Vercel을 이용해 Deploy하려고 했으나, AWS Lambda의 50mb 용량 제한으로 불가능했습니다. 이에, Heroku로 배포하는 방법으로 선회했습니다.한글 폰트 깨짐 issue가 발생해, NotoSansKR 폰트를 static 파일로 읽어오는 코드를 추가했습니다.Deploy시 Heroku에서 puppeteer를 사용할 수 있도록 해주는 buildpack을 추가해줬습니다. 결과 Sample API https://og-img-generator-server.herokuapp.com/og/타이틀/서브타이틀  해결할 점 Heroku의 한계로 api가 이미지를 응답하는 속도가 매우 느립니다. (10초정도) 따라서, 실제로 사용하려면 다른 방법을 강구하거나, getStaticProps()에서 처리해 주어야겠습니다.좀 더 발전시켜서 유연한 Thumbnail / Open Graph Image Generator를 개발해보고 싶습니다. 2022.08.11 약간의 변경점이 있었습니다. 이 글을 참고해주세요! ",
    "date": "2022-08-09",
    "slug": "react-express-og-gen",
    "title": "Heroku + React + Express로 Open Graph Image, Thumbnail Generator 개발하기"
  },
  {
    "content": "Mixed Content 에러를 알아보고 해결했습니다. 발생한 문제 연구실 업무로 개발중인 설문 웹페이지에서 마지막에 설문 결과를 서버로 보내는 부분이 아래의 에러를 뿜으며 동작하지 않는 문제가 발생했습니다. Mixed Content: The page at 'https://goodrider-interview-web.vercel.app/submitted' was loaded over HTTPS, but requested an insecure resource 'http://geodb.uos.ac.kr/api/driver/post/survey'. This request has been blocked; the content must be served over HTTPS. /submitted 경로에서 POST 요청을 HTTP 프로토콜로 열려있는 백엔드 서버에 날리는 과정이었는데요! 해석해보면 이런 내용인거죠. 요청을 날리는 웹은 HTTPS로 로드되고 있는데, 요청을 받는 웹은 보안이 취약한 HTTP 프로토콜로 이뤄져 있어서 내가 막아줬어! 보안을 걱정해주는건 고마운데, 곤란한 상황이죠. 백엔드의 API를 HTTPS로 제공하면 베스트겠지만 서버를 건드릴 수 없는 경우에는 어떻게 해결할 수 있을까요? Mixed Content가 뭐야? 우선 Mixed Content가 뭔지부터 제대로 알고 가는게 첫 단계입니다. MDN 문서 간단하게 말하면 HTTPS로 제공되는 웹페이지에서 HTTP 프로토콜로 받은 컨텐츠를 포함하고 있는 경우 이 컨텐츠를 Mixed Content라고 부릅니다. 이 경우 웹페이지는 부분적으로만 암호화돼있는 상태인거고, 결국 암호화되지 않은 부분은 미들맨 공격(man-in-the-middle attack)에 노출됩니다. HTTP와 HTTPS의 차이를 더 확실하게 알고 있다면 깊은 이해가 가능할 것 같아요. 간단하게 설명하면 HTTPS는 패킷으로 데이터를 주고받는 프로토콜인 HTTP에 중간에 패킷을 가로채 데이터를 가져가거나 수정하지 못하게 암호화 계층(TLS)을 추가한 프로토콜입니다. 어떻게 해결할까? - 프록시로 접근해보자. 다행히도 저는 이 오류를 접하기 전에 '프록시 서버(Proxy Server)'라는 개념을 알고 있었습니다. 프록시 서버는 서버와 클라이언트 사이에 위치하면서 클라이언트 대신 서버와 통신해 응답을 돌려주는 중간 서버입니다. CORS 문제, 보안상 이유 등으로 프록시 서버를 사용할 수 있습니다. 프록시 서버는 서버에 요청을 날릴 때 클라이언트에 관한 그 어떤 데이터도 제공하지 않기 때문입니다. 설문지 웹페이지는 Next.js로 개발됐기 때문에, Next.js 웹 서버 자체를 프록시 서버로 활용해 문제를 해결할 수 있을 것이라고 생각했습니다. 찾아보니 아래의 방법으로 프록시를 설정할 수 있다고 합니다. next.config.js next.config.js에 요청 path와 연결해야 할 URL을 이런 식으로 넣으면 됩니다. rewrite()라는 함수로 넣기 때문에 유동적으로 바꿀수도 있습니다. 위 설정을 통해 클라이언트는 https://goodrider-interview-web.vercel.app/api/post 라는 URL로 http://geodb.uos.ac.kr/api/driver/post/survey 라는 엔드포인트에 접근할 수 있게 됐습니다. ",
    "date": "2022-10-31",
    "slug": "nextjs-mixed-content-proxy",
    "title": "Next.js에서 Mixed Content 에러 해결하기 (feat. Proxy)"
  },
  {
    "content": "Array.includes() 메서드에 넣을 수 있는 값의 타입은 제 생각과 달랐습니다. 어떻게 하면 더 논리적인 타입을 사용해 대응할 수 있을까요? 코드 RESTAURANT_TYPES라는 ReadonlyArray를 선언하고, 이를 활용해 RestaurantType을 선언했습니다. isRestaurantType은 인자로 넘어온 값이 RestaurantType인지 여부를 확인하는 타입 가드입니다. 확인하는 방법은 보시다시피 간단합니다. includes 메서드를 활용해 str을 RESTAURANT_TYPES가 가지고 있는지를 체크하는겁니다. 하지만, 간단해 보이던 이 코드는 사실 오류를 내뿜는 코드입니다. 12번째 줄 return문의 RESTAURANT_TYPES.includes(str)에서 이런 에러가 발생합니다.  includes의 타입 즉 string 배열이라면 인자의 타입 또한 string이어야 하고, number 배열이면 인자의 타입 또한 number여야 하는겁니다. 위에서 보여드렸던 오류는 RESTAURANT_TYPES 배열이 \"한식\" | \"일식\" | \"양식\"의 유니온 리터럴 타입을 가지고 있기 때문입니다. 8번째 줄에서 str는 string으로 타입이 좁혀졌지만, 그것 조차 모자랐던거죠. 타입 선언 덧씌우기 오류의 원인을 파악하고 저는 한가지 의문이 들었습니다. includes가 하는 일은 배열이 주어진 인자를 포함하고 있는지 여부를 확인하는거고, 그렇다면 includes에 들어올 수 있는 인자는 무엇이든 가능해야 하는게 맞지 않을까요? 배열이 어떻게 구성됐는지 알 수 없는 경우라면 더욱 더 이렇게 생각하는게 합리적이지 않을까요? 그런 생각에 이런 타입 선언을 덧씌워 사용하려고 했습니다. 이제 오류를 뿜지 않고, includes에 어떤 타입의 값이던 넣을 수 있습니다.  조금 더 우아하게? 하지만, 이렇게 타입 선언을 임의로 수정해서 사용하는건 문제가 발생할 가능성이 있다는 생각이 들었습니다. 조금 더 안전하게 처리하려면 결국엔 아래같은 방법이 그나마 유효할겁니다. 다만 이렇게 할 경우 str이 \"한식\" | \"일식\" | \"양식\" 타입이 맞다고 단언하고 진행된 결과이므로 논리적으로는 옳지 않은 선택이라는 생각이 듭니다. 위 코드 만으로는 str이 string 타입이라는 점만 보장됩니다. (물론 결과적으로 얻고자 하는건 얻을 수 있긴 하지만요.) .includes 메서드에 제네릭 타입이 적용됐다는건 \"배열에 들어갈 수 있는 원소 중에 특정 원소가 들어있는지 여부\"를 확인하고자 했던게 아닐까 라고 생각하고 다시 고민해봤습니다. 그래서 나온 결과는 아래와 같습니다. 타입 단언이 들어가있긴 하지만, RESTAURANT_TYPES는 ReadonlyArray<string> 타입이라는 점은 확실하게 보장된 사실이므로 논리적 비약이 없는 코드입니다. 결론 사실 마지막에 타입 단언문의 위치에 대해 고민했던 부분은 어떻게 보면 아무런 의미 없는 일이었을지도 모릅니다. 함수 외부로 단언문을 넘긴다던지 하는 문제도 아니었고 결국 이 코드를 작성하는 나 자신만 알고 넘어갔을 확률이 높은 부분이니까요. 두 방법 모두 (거의) 똑같은 결과를 주고 있기도 합니다. 다만, 이런 부분 하나 하나 고민한다는 것 자체가 타입스크립트 개발자로서 한 단계 더 나아갈 수 있는 좋은 버릇이라는 생각이 듭니다. 어떻게 하면 더 논리적이고 섬세한 타입을 사용할 수 있을지 항상 고민해보고 또 좋은 내용이 있다면 간단하게 기록 해봐야겠습니다. ",
    "date": "2023-03-22",
    "slug": "includes-type-consider",
    "title": "includes의 타입은 어떻게 대응하는게 좋을까"
  },
  {
    "content": "멋사 프론트엔드 스쿨에서의 첫 주를 돌아봤습니다. 회고 프론트엔드 개발자가 되기로 마음은 먹었지만, 솔직히 막학기를 휴학까지 해가며 풀타임 부트캠프를 다니게 될 줄은 몰랐어요. 지금까지는 한 적 없었던 과감한 결정이었기에 혹시 나랑 맞지 않는 선택이었다면 어쩌지 하는 걱정과 함께 시작한 주였습니다. 정신없는 일주일을 보낸 후 회고를 적고 있는 지금은 정말 잘한 결정이었다고 과거의 저를 칭찬하고 싶어요. 이번 주에 있었던 일 고등학교 졸업 이후 5년만에 처음으로 5일 연속 9시 전에 일어났어요... 시차적응중...그동안 여러 개인 프로젝트를 해보며 HTML이나 CSS는 알고있다고 생각했는데 완전히 기초를 놓지고 있었다는걸 깨달았어요.특히 Semantic Markup이 어떤 의미이고 왜 필요한지 확실히 공부한 점과 금요일에 들은 이종찬 강사님의 CSS 기초 특강이 정말 좋았어요.Semantic Markup 실습을 위해 본 블로그의 HTML 요소들을 고쳤습니다. 그동안 수많은 <div>와 <span>을 남발하고, <h1>을 두개, 세개씩 쓰고 했던걸 보며 정말 엉망으로 하고있었구나 싶었어요. 지금은 꽤 Semantic해진 것 같은데, 나중에 한 번 피드백 받아보고 싶네요.display: flex;를 남발한 CSS도 지속적으로 고쳐나갈 예정입니다.멋사 FE 스쿨 3기의 회고 8조 조장을 맡게 됐습니다. 회고 활동 뿐만 아니라 같이 성장하는 동료가 될 수 있도록 최선을 다하겠습니다!!스터디를 두개나 들어가서 '함께 자라기', '모던자바스크립트 딥다이브' 이렇게 책을 두 권 샀어요. 특히 딥다이브는 꼭 한번 공부해야겠다 생각했는데 이 참에 공부하게 돼서 좋네요.멋사 온라인 모각코용으로 게더타운을 열었는데 많이 들어와주셨어요.코테 챌린지 두 개 신청했어요. 당연히 붙진 못하겠지만 목표가 생기면 코테공부에 도움이 될 것 같았어요. (Python에서 JS로 코테 언어 바꾸는것도 심각하게 고민중) 특히 Semantic Markup이 어떤 의미이고 왜 필요한지 확실히 공부한 점과 금요일에 들은 이종찬 강사님의 CSS 기초 특강이 정말 좋았어요.Semantic Markup 실습을 위해 본 블로그의 HTML 요소들을 고쳤습니다. 그동안 수많은 <div>와 <span>을 남발하고, <h1>을 두개, 세개씩 쓰고 했던걸 보며 정말 엉망으로 하고있었구나 싶었어요. 지금은 꽤 Semantic해진 것 같은데, 나중에 한 번 피드백 받아보고 싶네요.display: flex;를 남발한 CSS도 지속적으로 고쳐나갈 예정입니다. 기억에 남는 일 들어봤다 => 배웠다 => 해봤다 => 다르게 해봤다의 단계를 밟아 성장하자. 이번주에 들었던 말 중 이게 가장 기억에 남아요. 아 또 종찬님께서 종찬님 특강을 듣고 정리한 제 블로그 글을 봐주시고 좋아요 눌러주신것도 기억에 남아요. 지금의 글을 초고라고 생각하고 떠오를 때마다 고쳐나는 것도 엄청 공부가 될거란 조언을 주셨어요. 다음주 일정, 할 일과 다짐 일정 월요일부터 원티드 TypeScript 프리온보딩 챌린지가 시작돼요.무리하지 않고 할 수 있는 만큼만 참여할거에요.거의 매일 GDSC UOS 신입 면접에 면접관으로 참여해요. 무리하지 않고 할 수 있는 만큼만 참여할거에요. 할 일과 다짐 목요일에 '함께 자라기' 스터디가 있어요.목요일까지 딥다이브 4, 5챕터 공부할거에요.매일 코테 두 문제 이상 풀거에요.가능하다면 멋사 과제를 시작해볼거에요. 이번주에 정리한 내용 emmet(에멧) 정리!Git CLI 명령어 정리 1CSS 기본 다지기 ",
    "date": "2022-09-04T01:00:00+09:00",
    "slug": "likelion-frontend-week1",
    "title": "멋사 프론트엔드 스쿨 1주차 회고"
  },
  {
    "content": "코딩테스트를 준비하며 정리한 유용한 Python3 문법 / 모듈들입니다. input 입력 개수가 한 개여도 input()보다 sys.stdin.readline()이 더 빠르다. 타입캐스팅 없이 문자열로 사용할 경우 반드시 .rstrip()함수를 호출해 줄바꿈 기호를 제거해야 한다. append 빈 리스트에 append보다는 초기화된 리스트에 인덱스로 접근해 입력하는것이 더 빠르다. list.append()의 반환은 null이다. print 줄바꿈할 때는 print()가 아니라 \\n을 이용해 한번에 출력하자. sorted key 속성으로 정렬 기준을 명시할 수 있다. reverse 속성으로 정렬을 뒤집을 수 있다. sorted()보다 list.sort()가 더 빠르다. 단, 이 경우 반환값은 null이다. itertools itertools.permutations iterable 객체에서 r개의 데이터를 뽑아 일렬로 나열하는 모든 경우(순열)를 계산해준다. itertools.combinations iterable 객체에서 r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모든 경우(조합)를 계산해준다. itertools.product iterable 객체에서 r개의 데이터를 중복하여 뽑아 일렬로 나열하는 모든 경우를 계산해준다. itertools.combinations_with_replacement iterable 객체에서 r개의 데이터를 중복하여 뽑아 순서를 고려하지 않고 나열하는 모든 경우를 계산해준다. random random()은 0 ~ 1을 리턴한다. 범위 지정 난수는 random.randrange(a, b)이며, a이상 b 미만 난수를 리턴한다. random.shuffle(a)는 iterable 객체 a를 섞는다. random.choice(a)는 iterable 객체 원소 중 하나를 뽑는다. collections collections.Counter dict를 이용한 카운팅이 필요할 때 써먹으면 아주 유용하다. dictionary를 확장하고 있기 떄문에 dict type의 API를 모두 사용할 수 있다. Counter().most_common() 메서드를 사용하면 데이서 개수가 많은 순으로 정렬된 배열을 리턴한다. collections.defaultdict 디폴트값이 정해지는 dict collections.deque Queue를 구현할 수 있는 라이브러리이다. 데이터의 삽입, 삭제가 list에 비해 효율적이다. dict sort dict를 Key 기준으로 정렬하기 - dict.items()는 [(key, value), ...] 형식의 Tuple Pair로 이루어진 리스트를 리턴한다. dict.items()와 sort()의 key 인자를 적절히 사용하여 원하는 정렬이 가능하다. 투플 리스트를 이용해 생성 투플로 이뤄진 리스트를 이용해서도 생성할 수 있다. zip() 함수와 같이 이용하면 강력하다. map(function, iterable) iterable의 각 원소를 function에 대입해 함수를 실행한다. map을 리턴하므로 list 혹은 tuple로 형변환해 사용해야 한다. function에 lambda함수도 대입이 가능하다. filter(function, iterable) function의 값에 따라 iterable을 filter하는 함수. filter를 리턴하므로 list 혹은 tuple로 형변환해 사용해야 함. map과 마찬가지로 lambda함수를 사용하는것이 편할 것. zip() 여러개의 iterable들을 인자로 받아 각 객체의 원소를 tuple의 형태로 묶어 iterable로 반환한다. 여러 그룹의 데이터를 한 번의 루프로 처리할 수 있다. zip()을 이용해 묶은 데이터를 다시 해체할 수도 있다. math math.floor() 버림 math.ceil() 올림 enumerate 예시 보면 바로 알 수 있음 겁나 유용함 ",
    "date": "2022-08-01",
    "slug": "python3-syntax-summary",
    "title": "코테용 Python3 문법 / 모듈 정리"
  },
  {
    "content": "Visual Studio Code는 제가 가장 좋아하는 IDE입니다. VSC의 '단축키'를 정리했습니다. 단축키는 생산성에 아주아주 큰 영향을 미치니, 꼭 알아두시길 바랍니다. 저는 MacOS를 사용하므로 Mac 기준으로 정리했지만, Command 키는 Control 키, Option 키는 Alt 키로 바꾸면 Windows에서도 대부분의 단축키가 작동할겁니다. 어떤 역할을 하는 키인지 글만으로는 알기 어려울 수 있지만, 제가 직접 사용해보고 '이것만은 정말 알아야한다'는 키들만 모았으니 꼭 시도해보세요. 단축키를 하나만 더 알아도 생산성은 배로 늘어납니다. 새로 알게된 단축키가 있을 때마다 갱신하겠습니다. 추가할만한 단축키가 있다면 댓글 부탁드립니다. VSC 설정이 어떻게 돼있냐에 따라 단축키가 다를 수 있습니다. 저장(Command + s)같이 당연히 알만한 단축키는 생략했습니다. 멀티 커서 관련 멀티 커서 Option(⌥) + 커서를 놓고 싶은 곳 클릭 여러 군데에 커서를 놓을 수 있습니다. 멀티 커서(키보드로) Command(⌘) + Option(⌥) + 위쪽 or 아래쪽 화살표 멀티 커서(일직선인 경우) 시작 부분에 커서를 놓고, Option(⌥) + Shift(⇧) + 선택이 종료되는 커서가 놓일 부분 클릭 가지런하게 놓인 연속적인 여러 줄에 대해 멀티 커서를 간편하게 만들 수 있습니다. 선택한 줄들의 맨 마지막으로 커서 이동 여러 줄을 드래그로 선택하고, Option(⌥) + Shift(⇧) + i 문자열 선택 같은 문자열들 선택 문자열을 선택하고, Command(⌘) + d 선택한 문자열과 같은 문자열을 멀티커서로 하나씩 늘려가며 선택합니다. 정말 정말 많이 사용합니다. 문자열 끝까지 선택 Command(⌘) + Shift(⇧) + 오른쪽 or 왼쪽 화살표 문자열 큰 단위로 선택 Option(⌥) + Shift(⇧) + 오른쪽 or 왼쪽 화살표 멀티 커서와 함께 사용하면 강력한 기능입니다. 여러 줄들이 문자열의 길이는 다른데 구성은 같다면 이 단축키로 원하는 단위만큼 멀티 선택 할 수 있습니다. 문자열 사각형으로 선택 Option(⌥) + Shift(⇧) + 여러 줄 드래그 여러 줄을 그냥 드래그하면 그 줄 전체가 선택되지만, 문자열을 사각형으로 선택하면 정확히 선택한 부분만 선택됩니다. 커서 이동 모든 이동 단축키는 hift(⇧)와 같이 사용하면 선택이 됩니다. 큰 단위로 이동 Command(⌘) + 오른쪽 or 왼쪽 화살표 작은 단위로 이동 Command(⌘) + 오른쪽 or 왼쪽 화살표 문서 맨 위 / 아래로 이동 Command(⌘) + 위쪽 or 아래쪽 화살표 기타 VSC Settings Command(⌘) + , 자동완성 확인하기 Ctrl + Spacebar 혹은 Command(⌘) + i 들여쓰기 / 내어쓰기 선택된 부분이 있는 경우 들여쓰기: 조절할 줄들을 선택하고(일부만 선택해도 됨), Tab내어쓰기: 조절할 줄들을 선택하고(일부만 선택해도 됨), Shift(⇧) + Tab 선택된 부분이 없는 경우 들여쓰기: Command(⌘) + ]내어쓰기: Command(⌘) + [ 커서가 있는 줄을 위 / 아래로 이동 옮기고 싶은 줄에 커서를 놓고, Option(⌥) + 위쪽 or 아래쪽 화살표 여러 줄을 선택한 상태로도 가능합니다. Refactoring시에 유용하게 쓰입니다. 한 줄 복사 / 삭제 복사: Shift(⇧) + Option(⌥) + 위쪽 or 아래쪽 화살표삭제: Shift(⇧) + Command(⌘) + k 새로 파일 열기 Command(⌘) + NCommand(⌘) + S파일명 입력 코드 스니펫 만들기 Command(⌘) + P>snippet 입력원하는 언어 선택해서 config json 수정 코드 스니펫 string에서 $숫자는 스니펫을 사용할 때 탭을 누르면 해당 위치로 순서대로 이동합니다. UPDATED ON 22.09.13 ",
    "date": "2022-08-16",
    "slug": "useful-vsc-shortcuts",
    "title": "유용한 VSC 단축키 정리"
  },
  {
    "content": "바람직한 웹 개발자는 Vanilla JS를 잘 다룰줄 알아야 합니다. Single Page Application을 React.js 등 프레임워크의 도움 없이 Vanilla JS로 개발해보겠습니다. Intro 제가 제일 좋아하는 쌤인 니꼬쌤께서는 항상 바닐라 자바스크립트의 중요성을 강조하십니다. 아무리 프레임워크를 잘 다뤄봤자 바닐라 JS를 잘 모른다면 이해도도 떨어지고, 프레임워크에 지나치게 의존적인 개발자가 될 위험이 있다는 말씀인거죠. 마침 지금 2차를 준비중인 멋쟁이 사자처럼 웹 프론트엔드 2차 과제 중 바닐라 JS로 SPA를 만드는 과정이 있어 따라해보며 정리하려고 합니다. 목표 저는 이 강의를 참고해 코인 순위를 보여주는 SPA를 만들어보고자 합니다. 강의에서는 정말 페이지가 하나뿐인 앱을 만들며 SPA를 표방했지만, 저는 Router까지 구현해보겠습니다. 사용하는 API는 Coinpaprika API입니다. 개발 실습 환경 구축 우선 아래의 형태로 기본적인 html 코드를 작성해줍니다. root div를 하나 만들고, data fetch 함수를 하나 선언해줬습니다. 이제 여기에 컴포넌트를 하나 하나 추가해가면 됩니다. 참고로, VSC의 Live Server라는 extension을 사용하면 매 번 저장할 때마다 바뀌는 코드의 내용을 auto reload하며 편하게 코딩할 수 있습니다. 컴포넌트 관리는 innerHTML을 넣기 보다는 이렇게! root에 코인 목록을 넣고싶다고 가정해보겠습니다. <ul> element를 root div 안에 추가하는 건데요. 가장 간단한 방법은 그냥 직접 html을 작성해서 innerHTML로 넣어주는거겠죠. 이렇게요! 하지만 이렇게 작성하면 코드의 일관성을 유지하기 어렵고, 모듈화를 통한 컴포넌트의 재사용을 할 수 없다는 단점이 있습니다. 때문에 아래의 방법처럼 작성합니다. 추후 css작업을 위한 클래스명을 적절히 부여하며 api를 사용해 10위까지의 코인이 보이는 메인 페이지 코드를 완성하겠습니다.  css 작업을 하기 전이라 보기 별로지만 코인 이름, 심볼, 순위까지 표시가 잘 되고 있습니다. SPA Router with JS 보통 Single Page Application들은 Routing을 할 때 실제 URL에 해당하는 html을 찾는 대신, 이걸 '낚아채서' URL 경로에 따라 올바른 컨텐츠를 동적으로 보여줍니다. Browser History를 이용하는 방법이 가장 보편적인데, 이 때 알아둬야 하는 api들은 다음과 같이 있습니다. History.pushState()Window의 popstate eventWindow의 DOMContentLoaded event 각각에 대한 설명은 링크된 MDN docs를 참고해주세요. 완벽한 Router를 개발하는 것은 웹서버 개발과 연관돼 있어 간단하게 개발하려면 hashed route등을 사용해야 합니다. 제가 개발하려고 하는 것은 coinId별로 달라지는 nested route로 약간 골치아프니, 실습을 위해 간단하게만 구현해보겠습니다. 방법론 먼저, router.js를 아래처럼 작성합니다. 정확하게 개발하려면 onpopstate 부분을 조금 손봐줘야 하겠지만, 본 앱은 단 두 개의 페이지로만 이뤄지므로 home()을 렌더링하도록 했습니다. 다음으로는 home.js, coinDetail.js를 각각 이렇게 짜줍니다. home.js coinDetail.js 보시다시피 window.history.pushState()를 이용해 history에 push해주면서 route를 관리합니다. 마지막으로, index.html에서 router.js를 불러와 initiating 합니다. index.html 핵심 로직은 완성됐습니다. 이제 css작업을 하면 됩니다. (css는 본문에서 생략하겠습니다. 코드를 보고 싶으시다면 여기를 참고해주세요.) 결과물 아래가 결과물입니다. 직접 눌러보세요. 잘 작동하네요! ",
    "date": "2022-08-15T22:30:00+09:00",
    "slug": "javascript-only-spa",
    "title": "JavaScript만으로 SPA 개발해보기"
  },
  {
    "content": "Sass를 공부하던중 저 혼자 Equality Operator의 작동 결과가 다른것을 알게 됐습니다. 문제 아주 간단한 코드입니다. 전자의 경우 당연히 true가 나와야 할 것이고, 후자의 경우에도 true가 나오는게 당연할거라고 생각했습니다. 공식 문서에는 true라고 돼있습니다. 그런데...  보시다시피 @debug 1 != 1px;가 false가 나오고 있습니다. 1 == 1px 이라고...?? 버전을 체크해보자  제가 사용한 node-sass의 버전입니다. node-sass는 7.0.3으로 최신 버전이 맞는데, 밑에 libsass라는 Sass Compiler의 버전이 3.5.5라고 나와 있습니다. LibSass 버전 3.6.5 변경사항 LibSass는 Sass 코드를 컴파일 할 수 있는 컴파일러로, C와 C++로 만들어진 라이브러리입니다. 즉 node-sass는 libsass의 도움을 받아 .scss 코드들을 .css로 변환해주고 있는 것입니다. (node-sass를 wrapper(=implementer)라고 부르는 이유입니다.) LibSass Repo 그런데 위 레포지토리를 보면, 가장 최신 버전은 21년 5월에 올라온 버전 3.6.5 입니다. 대체 어떤게 달라졌기에 3.5.5에서는 1 == 1px이라고 했다가, 1 != 1px로 바뀐걸까요? 버전 3.6 대의 Changelog를 한번 살펴보다가 버전 3.6.5의 수정 내역중 이런 문구를 발견했습니다.  밑에서 네번째 줄에 보시면 Fix edge case regarding unit-less number equality as object keys 라는 문구가 있습니다. 해석하면 '단위가 없는 숫자의 동일성을 객체의 키로 인식하는 edge case 수정' 정도가 될 것 같습니다. (edge case란 디버깅 혹은 단위 테스트에서 사용되는 용어로 여기에서는 '특이 케이스'정도로 생각할 수 있겠습니다.) 제 레벨에서는 이해하기 어려운 문제이지만, 일단 조금 읽어본 바로는 Sass 컴파일러 내부에서 unordered map 형식의 데이터는 equality check에서 hash 싱크 체크를 건너 뛰는 문제가 있는 것 같았습니다. 관련 issues 이슈 넘버 3094 이슈 넘버 1667 그러다보니 한 쪽이 unit-less일 경우 반대쪽의 단위로 이상한걸 막 써놔도 숫자만 같으면 같다고 판단해버립니다...  결론: Dart Sass를 쓰자 저같은 초보는 깊게 이해할 수는 없으니 'LibSass 버전 3.6.5에서 Equality Operator 관련 변경사항이 있었구나' 정도만 알고 넘어가도 좋겠습니다. 다만, 이 과정에서 또 알게된 중요한 사실은 LibSass가 deprecated 됐다는 점입니다. Sass 공식 문서에서는 Dart Sass를 이용할 것을 권장하고 있습니다.  Mac에서 Dart Sass 설치하기 공식 문서 저는 MacOS 환경을 사용하고 있으므로, 공식 문서에서 소개하고 있는 홈브루를 이용하는 방식으로 설치할 수 있습니다. 홈브루가 설치돼 있다면 간단하게 이렇게만 입력하면 끝입니다. Ruby Virtual Machine (RVM)이 설치된 환경이라면 ruby-sass를 모든 가상환경에서 지워줘야 합니다! ruby-sass도 deprecated 됐습니다. 가장 최근 버전은 1.55.0입니다!  package.json의 scripts를 아래와 같은 형식으로 변경하고 이제 아래의 코드를 다시 돌려보면...  짜잔~! 이제 잘 나오네요! 🙌🙌 Sass 공식문서 Contribution도 노려봤습니다 sass-site 레포지토리에 issue 올리고 PR 날려봤습니다. 어떻게 될지는 모르겠지만 이렇게 대형 프로젝트에 기여해보려고 한건 처음이라 두근두근 하네요! 10/4 업데이트: PR 실패ㅠㅠ 알고보니 해당 내용이 이미 공식 문서에 토글 버튼으로 숨어있더라고요ㅎㅎ 비록 성공하지는 못했지만 좋은 도전이었고 앞으로 오픈 소스 기여에 계속 도전해보겠습니다!! ",
    "date": "2022-09-29T18:09:00+09:00",
    "slug": "sass-equality-op-version",
    "title": "Sass 버전에 따라서 Equality Operator의 작동 결과가 달라진다?"
  },
  {
    "content": "true == 'true'는 false인 이유가 뭘까요? 자바스크립트 동등 연산자(==)의 작동 방식을 제대로 알아봤습니다. true == 'true'는 false입니다. 딱 직관적으로 생각했을 때는 좌변은 true니까 참이고, 우변은... 비어있지 않은 String이니까 참이...고... 그러면 true? 라는 생각이 들 수밖에 없습니다. 근데 이 기가막힌 JS는 저희가 행복해지는걸 두고보지 않죠.  대체 왜 이런걸까요?? MDN 문서를 살펴보자 MDN 문서 (한국어 문서는 최신 내용이 아님에 유의해주세요.) ==는 느슨한(Loose) 의미의 같음을 비교하는 연산자입니다. 자바스크립트 엔진은 == 연산자를 만나면 내부적으로 일종의 '형 변환' 과정을 거친 후 비교합니다. 자세히는 이 순서대로 동작합니다 (동등 연산자 연산이 완료될때까지 계속 반복됩니다.): 양 변이 같은 타입이라면 ===(일치 연산자)처럼 동작합니다.객체라면 같은 객체여야만 trueString이라면 같은 순서대로 문자들이 놓여있을때만 trueNumber라면 같은 값일때만 true, 둘 중 하나라도 NaN이라면 false참고로 +0과 -0은 같은 값으로 취급됩니다.Boolean, BigInt이라면 같은 값일때만 trueSymbol이라면 같은 symbol을 reference하고 있을때만 true둘 중 하나가 null 혹은 undefined라면:나머지 하나도 null 혹은 undefined: true그 이외의 경우: false둘 중 하나가 객체이고, 다른 하나가 원시형이라면 toPrimitive(), valueOf(), toString() 등의 메서드들을 사용해 객체를 원시형 값으로 바꿉니다.객체를 원시형으로 바꾸는 과정은 조금 복잡할 수 있습니다. 자세한 과정은 여기를 참고해주세요!위 단계를 거쳤다면 이제 양 변이 모두 원시형 데이터인 상태일겁니다. 이 다음부터는 케바케로 동작합니다.양 변이 같은 타입이면 1번 방법을 따릅니다.둘 중 하나만 Symbol이라면 false둘 중 하나만 Boolean이라면 Boolean 데이터를 Number로 바꿉니다.Number vs String 꼴이라면 String을 Number로 바꿉니다.Number vs Bigint 꼴이라면 numberic 값을 비교합니다.Number가 Infinity 혹은 NaN이라면 falseString vs BigInt 꼴이라면 BigInt() 생성자로 String을 BigInt로 바꿉니다.형변환에 실패한다면 false 객체라면 같은 객체여야만 trueString이라면 같은 순서대로 문자들이 놓여있을때만 trueNumber라면 같은 값일때만 true, 둘 중 하나라도 NaN이라면 false참고로 +0과 -0은 같은 값으로 취급됩니다.Boolean, BigInt이라면 같은 값일때만 trueSymbol이라면 같은 symbol을 reference하고 있을때만 true 참고로 +0과 -0은 같은 값으로 취급됩니다. 나머지 하나도 null 혹은 undefined: true그 이외의 경우: false 객체를 원시형으로 바꾸는 과정은 조금 복잡할 수 있습니다. 자세한 과정은 여기를 참고해주세요! 양 변이 같은 타입이면 1번 방법을 따릅니다.둘 중 하나만 Symbol이라면 false둘 중 하나만 Boolean이라면 Boolean 데이터를 Number로 바꿉니다.Number vs String 꼴이라면 String을 Number로 바꿉니다.Number vs Bigint 꼴이라면 numberic 값을 비교합니다.Number가 Infinity 혹은 NaN이라면 falseString vs BigInt 꼴이라면 BigInt() 생성자로 String을 BigInt로 바꿉니다.형변환에 실패한다면 false Number가 Infinity 혹은 NaN이라면 false 형변환에 실패한다면 false 예시에 적용해보자 true == \"true\" 좌변이 Boolean이므로 Number로 바꿉니다.1 == \"true\";Number vs String 꼴이므로 String을 Number로 바꿉니다.1 == NaN;우변이 NaN이므로 false입니다. 2 == \"2\" Number vs String 꼴이므로 String을 Number로 바꿉니다.2 == 2;양 변이 같은 타입이므로 값을 비교하면 true입니다. ",
    "date": "2022-10-05",
    "slug": "js-equality-implicit-conv",
    "title": "자바스크립트 동등 연산자(==)의 암시적 변환 작동 방식"
  },
  {
    "content": "연구실 과제용 웹페이지 개발중 복잡한 모양의 if else 구문이 필요한 경우가 있었는데, 어떻게 하면 더 보기 좋은 코드가 될지 고민했습니다. 리팩토링할 코드 연구실 과제로 개발중인 설문 페이지에서는 사용자가 입력한 답안이 유효한지 여부를 판단하는 로직이 들어갑니다. 그 중, 숫자를 하나 받아 숫자의 크기에 따라 증감된 값을 리턴하는 함수가 필요했습니다. 실제 코드는 아래와 같습니다. numToChange라는 변수 하나를 가지고, 역수인지 여부를 판단 후 (역수라면 분모가) 1 ~ 9 범위 내에서 증감하도록 하는 코드입니다. 다중 if else문이 들어가는 탓에 보기에 굉장히 복잡합니다. 어떻게 하면 if else문을 제거하고 가독성을 높일 수 있을까요? 조건문 클린코딩 방법 리팩토링에 앞서 조건문과 관련된 클린코딩 기법, 설명들을 찾아봤습니다. 아래의 예제들은 Clean Code In A Nutshell에 있는 코드입니다. 단순한 조건문이라면 삼항 연산자를 사용하자! 단순한 조건문이라면 조건문을 사용하기보다 삼항 연산자로 바꿔쓰는게 좋습니다. 삼항 연산자는 다중으로 쓰지 말아요! 하나의 코드블록으로 이뤄진 다중 조건문을 피하자! 코딩을 하다보면 특정 값이 nullish한지 여부를 확인하는 로직이 자주 필요합니다. 이 때 하나의 코드블록 (if문 만으로 이뤄진)으로 구성된 다중 조건문을 작성하기 쉽상인데요, 이럴땐 아래의 테크닉을 사용하도록 합니다. 특정 조건이 다중 조건문에서 반복적으로 나오면 논리 연산자로 줄이자! 위 예제에서는 할인 여부를 판단하기 위한 조건문이 공통된 if 조건문을 가지고 있습니다. 이럴 경우 공통된 부분을 밖으로 빼고, &&과 || 연산자를 적절히 사용해 이렇게 간결하게 나타낼 수 있습니다. 복잡한 계산이 필요한 조건은 함수로 분리하자! 이 규칙에서 저는 '클린 코드란 코드를 줄이는 것이 아닌 가독성과 유지보수성을 향상시키고자 하는 과정'임을 알 수 있었습니다! 적용해보기 코드 전반부 클린코드 전 클린코드 후 코드 후반부 클린코드 전 클린코드 1단계 후 *단순한 조건문이라면 삼항 연산자를 사용하자!*는 법칙에 따라 아래처럼 바꿨습니다. 여전히 부족한 부분이 보입니다. 한번 더 리팩토링해보겠습니다. 클린코드 2단계 후 필요없는 변수(increasedElement, decreasedElement) 제거하고, 범위를 판단하는 부분을 배열로 변경해 구간 순서대로 직관적으로 볼 수 있도록 했습니다. 이 때, 배열 안에 수식이 위치하면 가독성에 문제가 생길것을 감안해 numToChange의 증감 값을 나타내는 increasedNum, decreasedNum 상수를 추가 선언했습니다. 또한, numToChange === 1인 경우 빠르게 결과를 리턴해 이후 이 경우의 수는 생각하지 않아도 되게끔 했습니다. 클린 코드가 문제가 아니다 이렇게 중첩된 조건문을 많이 제거하고, 꽤 '고급 기술처럼 보이는' 코드를 짰습니다. 그런데, 그래도 반복되는 코드가 계속 눈에 밟혔습니다. 내가 지금 비효율적인 로직을 짠게 아닐까? 그렇게 뚫어져라 쳐다보다가, 중요한 사실을 하나 깨달았습니다. 저 코드는 필요없는 판단을 포함하고 있었습니다. 문제를 발견한 부분은 이곳입니다. numToChange에 따라 숫자 범위마다 인덱스를 부여하고 incrementArr, decrementArr에 인덱스와 매치해 결과값을 얻고자 한 부분입니다. 하지만 잘 생각해보면 리턴의 increasedElement를 얻기 위해 필요한 판단은 numToChange >= 8 뿐입니다. 마찬가지로 decreasedElement를 얻기 위해 필요한 판단은 numToChange <= 2 뿐이고요. 이런 아이디어에 기반해 최종적으로 아래의 코드가 됐습니다. 완성된 함수의 전체적인 모습은 다음과 같습니다. 처음에 비하면 훨씬 간결한 모습입니다. 생각 정리 처음 리팩토링을 시작할 때는 조건문을 줄이는데에 치중했지만 그 과정 덕분에 로직의 중복되는 부분을 찾아 더 효율적인 코드를 완성했습니다. 그러나 다음에 다시 비슷한 코드를 마주친다면 무조건 if else를 줄이겠다는 시선으로 바라보기보다 중복되는 판단이 있지는 않은지를 중점적으로 찾아야겠다는 생각이 들었습니다. 다중 조건문에서 비슷한 코드가 반복된다면 분명 로직이 반복되고 있다는 뜻이라는걸 알았으니까요! ",
    "date": "2022-11-05",
    "slug": "refactor-complex-if",
    "title": "복잡하게 구성된 if문 리팩토링하기"
  },
  {
    "content": "점점 포스트 수가 많아져서 뿌듯하긴 한데, 가끔 제가 쓴 글을 찾기가 어렵더라고요. 그래서 이번엔 검색 기능을 직접 구현해보기로 했습니다. 어떻게 개발할까 husky pre-commit hook으로 커밋할 때 자동으로 캐시를 생성Next.js에 검색용 API 엔드포인트 추가 (Fuzzy 검색 간단하게 적용해보기)검색바 구현 (디바운싱과 쓰로틀링 비교해보기) 가장 좋은 방법은 아닐순 있어도 우선 목표를 달성하고, 추후 조금씩 최적화하면 될 것 같습니다. 캐시를 생성하자! 제 블로그는 아래의 순서로 포스트를 렌더링합니다. 마크다운 파일을 읽어옵니다.읽어온 내용을 HTML로 파싱합니다. (remark를 활용합니다) 이 때, 파싱의 결과는 string입니다.파싱한 내용을 마크다운용 스타일이 적용된 styled-component에 dangerouslySetInnerHTML로 넣습니다. 검색 기능을 구현하려면 모든 포스트에 대한 내용을 가지고 있는 일종의 캐시가 필요합니다. 저는 이 캐시를 매 커밋 직전에 자동으로 생성하고자 합니다. 이를 위해 아래의 파일을 생성했습니다. 우선 파일 내용을 읽어와야 합니다. 저는 이미 마크다운을 읽고 HTML로 파싱하는 함수를 만들어 쓰고 있었으므로, 해당 함수들을 활용해 HTML로 파싱된 내용을 불러옵니다. 그렇게 파싱된 HTML string은 18번째 줄에서 Document Object로 파싱됩니다. 노드 환경에서 DOM API를 사용하기 위해 jsdom 모듈을 활용했습니다. 그 후, 필요한 요소를 querySelectorAll()로 가져오고, 각 요소를 돌며 textContent를 추출해 postsCache에 담습니다. 15번째 줄에 보시면 마크다운 string으로부터 HTML string을 생성하는 markdownToHtmlForCache()가 비동기 함수이므로 postsData.map()을 Promise.all()로 감싸줍니다. 마지막으로 postsCache를 cache.json에 저장합니다. 이 다음 개발할 API에서 이 json 파일을 캐시로 사용하려고 합니다. Top-level await를 썼으면 더 보기 좋았겠지만 Next.js와는 독립적으로 동작할 부분 때문에 전체 프로젝트의 설정을 바꾸고 싶지는 않아 즉시 실행 함수로 작성했습니다. 이제 이 cache.ts를 실행하는 명령어를 pre-commit 훅으로 추가해주면 됩니다. cache.ts 실행을 위해 tsx를 devDependency로 추가했습니다. 검색용 엔드포인트를 만들자 우선, 검색용 API를 개발하기 앞서서 한가지 생각해볼 문제가 있습니다. 많은 서비스들이 검색시 '대충 입력해도 원하는걸 찾아 보여주는' 자동완성 기능을 제공합니다. 저는 이것처럼 사용자의 입력값이 완벽하지 않아도 찾고있을 가능성이 있는 글을 보여주는 기능을 붙이고 싶습니다. Fuzzy 간단하게 적용해보기 참고한 태곤님 블로그 포스트 Fuzzy 알고리즘은 이를 구현할 때 쓸 수 있는 방법중 하나입니다. 두 문자열의 유사성을 파악해서 유사도가 높은지 여부를 판단하는 식입니다. 관련해서 복잡한 알고리즘 이론들이 많이 나와있지만 저는 최대한 간단하게 접근하면서 제가 직접 바꿀 수 있도록 태곤님 블로그에 나온 방법을 적용, 일부 코드를 조금 수정했습니다. (대소문자 둘 다 대응할 수 있도록, title과 content 두가지를 기준으로 찾을 수 있도록) 태곤님 포스트는 꼭 읽어보세요! 간단하면서도 흥미롭더라고요😁 다만 마지막에 longestDistance가 긴 순으로 정렬하는것이 좋은 반응을 얻었다는 의견을 소개해주셨는데, 왜 그런지 궁금하긴 했습니다. 저는 짧은 순으로 쓰기로 했습니다. 아래는 제가 수정한 코드입니다. 프론트엔드단에서 match된 string에 따로 스타일을 줄 수 있도록 배열로 분리하고, 어느 부분이 match된건지를 알리는 matchedOne 프로퍼티를 넣었습니다. 태곤님의 로직을 그대로 적용하면 longestDistance에 제한이 없어 content같이 긴 문구에서는 아주 길게도 match를 찾는 이슈가 발생해 해당 부분도 예외처리를 추가했습니다. 엔드포인트 실제 엔드포인트 구현 부분은 fuzzy.ts에서 모든 로직을 수행하고 있어 매우 간단했습니다. API 데모 (query = \"next\") 다음 포스트에선 이렇게 개발한 API를 활용해 실제 블로그에 적용해보겠습니다. ",
    "date": "2022-11-26T04:09:00+09:00",
    "slug": "blog-search-feature-part1",
    "title": "블로그에 검색 기능을 구현해보자 1"
  },
  {
    "content": "Next.js를 이용해 이쁜 블로그를 개발했는데, 아직 댓글 기능이 없네요. 외부 서비스를 이용하지 않고 직접 개발해보려고 합니다. Intro 보통 블로그를 개발할 때 사용하는 댓글 플랫폼으로는 Utterance, Disqus 등이 있습니다.   Utterence가 이쁘고 Markdown 입력도 가능해서 좋은데, 깃헙 로그인만 지원하는 문제가 있습니다. (댓글들은 특정 레포지토리의 issue로 관리된다는 킬러 기능이 있긴 하지만요) 로그인 없이, 간단하게 댓글을 남길수만 있었으면 좋겠다! 불필요한 로그인을 강요하고 싶지 않았기에 간단하게 닉네임과 댓글만 입력하면 되는 댓글 기능을 개발해보고자 합니다. Firebase Firebase는 구글에서 제공하는 개발 플랫폼입니다. 저는 댓글을 저장하는 Backend로 아주 간편한 Firestore를 이용하기로 했습니다. Firebase Console에서 블로그 앱을 추가하며 시작합니다. DB Scheme Firestore는 요즘 핫한 NoSQL 클라우드 데이터베이스입니다. 일반적인 RDB와는 달리 Collection과 Document로 구성된 모양인데요, 저는 아래와 같이 설계했습니다. 추후 좋아요 등의 추가 기능이 필요하다면 comments collection 내의 docs들에 data를 붙여주면 됩니다. 개발 환경 설정 Firestore의 데이터 접근 규칙을 약간 손봐주고, 다음으로 할 일은 블로그에 firebase module을 불러오는 일입니다. 저는 아래와 같이 firebase와 firestore를 initialize하는 코드를 추가했습니다. firebaseConfig에 들어갈 환경변수들은 .env로 관리합니다. 추후 Vercel에서 배포할 때 Vercel에 환경변수들을 추가해주면 됩니다. 개발 환경을 위해 로컬에도 .env파일을 root 디렉토리에 두었습니다. 참고로, Next.js에서 환경변수들 중 클라이언트에 노출돼도 되는 값들 앞에는 NEXT_PUBLIC_이라고 붙여줘야 합니다. 댓글 개발 시 댓글 데이터에 접근하는 주체는 Web Server가 아닌 클라이언트이므로 저는 이렇게 붙여줬습니다. Doc 생성, 수정, 삭제 이것 또한 정말 간단합니다. 예시로 Comment를 추가하는 코드를 보여드리겠습니다. 눈여겨 보실 부분은 commentCollectionRef입니다. collection, doc, collection, ... 이 반복돼 collection reference를 선언하고, 여기에 추가할 doc을 object형태로 넘겨주면 됩니다. 삭제나 수정 또한 간단합니다. 생성과는 달리 collection이 아닌 특정 doc에 대한 레퍼런스를 선언하고, deleteDoc(), updateDoc() 함수를 사용하면 됩니다. updateDoc()에서는 수정되는 data만 object에 넣어주면 됩니다. (기존에 없던 key에 대한 데이터여도 updateDoc()을 이용해 추가할 수 있습니다.) Doc 실시간 업데이트 Firestore의 강력한 기능 중 하나는 바로 '실시간 업데이트'가 가능하다는 점입니다. 저는 댓글을 불러오는 부분에 아래와 같이 코드를 작성해 실시간으로 수정되는 데이터를 불러오도록 했습니다. onSnapshot() 함수로 실시간 업데이트하길 원하는 collection을 지정하면 됩니다. 저는 거기에 더해 댓글을 생성시간순으로 정렬하고, 랜덤으로 생성된 doc의 id를 추가로 읽어왔습니다. 댓글 기능 개발, CSS 작업 이후로는 끝없는 CSS와 기능 개발의 연속입니다. 딱히 어려운 부분이 없는 로직이라 고민 자체는 오래 걸리지 않았는데, 이것 저것 구현할 것이 있다보니 시간이 조금 걸렸습니다. 특히, 비밀번호를 요구해야 하는 부분 때문에 코드가 조금 더러워졌는데, 추후 클린코드 한번 싹 해줘야겠습니다. 자세한 코드는 본 블로그 레포지토리를 참고해주세요. 결과물은 여러분이 보고 계시는 이 아래의 댓글창입니다. 원하던 모습이 나온 것 같아요. 댓글 비밀번호 설정, 수정 혹은 삭제 시 비밀번호 입력 등이 잘 구현돼서 아주 만족합니다. 보안은 취약하지만 이정도면 간단한 블로그 댓글 기능으로 충분합니다. ToDos 댓글별 좋아요 카운터답글 기능댓글 Pagenation 특히 댓글 Pagenation은 가장 먼저 추가로 개발해야 할 부분입니다. 아직 블로그 글조차 Pagenation이 안되고 있으니, 추후 해당 기능 개발 시에 같이 완성해 나가야겠네요! ",
    "date": "2022-08-04",
    "slug": "blog-comment-feature-firebase",
    "title": "블로그에 Firebase로 댓글기능 개발하기"
  },
  {
    "content": "멋쟁이 사자처럼에서 진행하는 프론트엔드 스쿨 부트캠프 3기에 최종 합격했습니다. 앞으로 4달 간 오로지 코딩 공부에 전념할 예정입니다! 멋쟁이 사자처럼 프론트엔드 스쿨에 지원하기까지 후기에 앞서서 제가 어떻게 멋쟁이 사자처럼 프론트엔드 스쿨에 지원하게 됐는지 적어보려고 합니다. 이 이야기는 제가 멋사 부트캠프 지원서나 자기소개 영상에 담은 내용이기도 해요. 나는 프론트엔드뿐이야 저는 올 해 1학기에 4학년으로서 공간정보공학과 졸업작품으로 동선을 고려한 All-in-One 일정 관리 서비스 크로스플랫폼 앱을 개발했습니다.(작품 링크) 앱은 Flutter를 이용해 개발했는데, 일정 블록을 Drag & Drop으로 삭제, 순서를 변경하거나 Hold & Drag로 일정 시간을 조정할 수 있는 타임라인 Widget을 개발했던 부분이 가장 뿌듯했습니다. 게다가 평소에 벡터 그래픽을 취미로 만들 정도로 디자인에도 관심이 있었기 때문에 프론트엔드 개발에 공을 들였고, 단기간에 개발한 앱 치고 꽤 멋진 모습이 됐습니다.  졸업작품은 무사히 개발을 마쳐, 서울시립대학교 도시과학대학 공동작품전에서 도시과학대학장상이라는 좋은 성과를 거둘 수 있었죠! 작품을 개발하며 깨달은 것이 하나 있다면, 제 길은 프론트엔드 개발자라는 것입니다. 비즈니스 로직을 구현하는 백엔드 개발자도 매력적인 직업이였으나, Flutter를 이용해 앱을 다채롭게 꾸며가는 과정이 너무나 즐거웠어요. 그래서, 드디어 프론트엔드 개발자로서의 길을 걸어가기로 다짐했습니다. 마음을 먹고 가장 먼저 했던 일은 네이버에서 진행하는 부스트캠프에 지원하는거였어요. 2차 코테까지는 갔는데 아쉽게도 광탈...ㅎㅎ 정사원으로 가주겠어 네이버 독학, 개인 프로젝트로 한 발짝 더 그 후, 본격적으로 JavaScript, Html, CSS는 물론, React.js와 부수적인 기술들을 독학했습니다. 저는 무언갈 배우면 하나 하나 다져가기보다는 바로 프로젝트를 진행해서 직접 부딪히며 익히는 성격이라 기초만 다진 채 금연을 도전하는 사람들을 위한 금연 타이머를 개발했습니다.  Github Repo사용해보기 멋진 결과물이었지만 무언가 부족한 느낌이 들었죠. 아직 여러모로 어설프기도 하고, 내가 개발을 온전히 내 것으로 컨트롤하고 있다는 느낌이 부족했어요. 공부한 내용을 정리하고 기록할 공간이 있어야겠다는 생각이 들었죠. 그래서 개발했던게 지금 보고계시는 이 블로그입니다. Next.js를 사용해서 남들 다 쓰는 벨로그나 jekyll 템플릿 말고 정말 나만의 블로그를 만들겠다는 다짐을 가지고요. 블로그의 레이아웃은 물론 카테고리별 분류, 댓글 기능까지 모든 부분을 직접 개발했답니다. 부족해, 부족해... 여기까지는 탄탄대로였지만, 이 이후가 문제였습니다. 개발을 완전히 구현 위주로만 공부해왔기에 기본기가 부족하다는 느낌이 정말 강하게 들었거든요. 제가 좋아하는 노마드 코더의 니꼬쌤이 하신 말씀 중 이 구절이 뇌리에 강하게 박혔어요. 좋은 프론트엔드 개발자는 리액트의 도움 없이도 원하는걸 구현할 줄 알아야 합니다. 제 실력으로는 바닐라 JS로 모달창도 만들기 어렵겠다는 생각이 들자 너무 부끄러워지더라고요. 그동안 뭘 한걸까 싶고, 갈피를 잡기 어려웠습니다. 부족했던건 그뿐만이 아니었습니다. 개인 프로젝트는 충분히 해본 것 같은데, 팀 프로젝트를 진행해보고 싶어도 마음이 맞는 동료를 찾기가 쉽지 않았어요. 아예 모르는 분과 프로젝트를 시작하기에는 부담감이 컸고, 주변에는 저처럼 프론트엔드 개발자를 목표로 하는 분이 많지 않았거든요. 같이 개발자로서 성장할 친구들이 필요했습니다. 그래서 최근에 제가 이미 Data/ML팀 Core Member로서 활동중이던 Google Developer Students Club UOS에서 Frontend로 팀을 변경하기도 했어요. 휴학생 신분으로 2학기에 멋사 부트캠프와 병행할 예정이에요. 게다가, 인턴을 지원해보면서 느낀 점인데 생각보다 인턴을 뽑는 회사도 많지 않고, 제 이력서가 좋은 평가를 받지 못하는 것 같았어요. 그래서 멋사 부트캠프를 통해 멋진 회사들에 제 이름을 알리고 멋사의 도움을 조금 받아서 스타트업에서 인턴을 해보고 싶기도 해요. 기본기를 다지자 네, 이런 생각 끝에 저는 멋쟁이 사자처럼 프론트엔드 스쿨에 지원하게 됐습니다. 4개월동안 빡 집중해서, 바닐라 JS의 달인이 되겠다는 목표로 열심히 달려보려고요. 4개월이라는 짧은 기간동안 틈틈히 GDSC활동도 하고, 멋사에서 만난 분들과 팀 프로젝트도 하고, 면접 준비에 코테 준비까지 하겠다는게 지금 계획이긴 한데...ㅎㅎ 물론 계획대로 흘러가지는 않겠지만 정말 최선을 다 해서 열정을 쏟아보겠습니다. 멋사에서 빡공하고 멋사 연계 스타트업에서 인턴하자!! ",
    "date": "2022-08-23",
    "slug": "likelion-frontend-final-acceptance",
    "title": "멋쟁이 사자처럼 프론트엔드 스쿨 3기에 최종 합격하기까지"
  },
  {
    "content": "자바스크립트를 할줄은 알지만 기초가 부족하기에 완전히 바닥부터 다시 한번 자세하게 공부해보려고 합니다. [모던 자바스크립트 Deep Dive] 책을 읽으며 공부한 내용을 정리하겠습니다! 자바스크립트의 역사 자바스크립트는 1995년 넷스케이프의 브렌던 아이크가 개발한 브라우저용 경량 프로그래밍 언어입니다. 이듬해 마이크로소프트에서 JScript라는 파생 버전을 개발하며 브라우저에 따라 웹페이지가 정상적으로 동작하지 않는 크로스 브라우징 이슈가 발생하기 시작했습니다. ECMAScript 이에 넷스케이프에서 비영리 표준화 기구인 ECMA 인터네셔널에 JS의 표준화를 요청했습니다. 그렇게 탄생하게 괸 것이 표준화된 자바스크립트, ECMAScript입니다. let, const, 화살표 함수, 클래스, 모듈 등 범용 프로그래밍 언어로서 갖춰야 할 기능을 대거 도입한 ES6가 발표된 2015년 이후 비교적 작은 기능들을 매년 추가해 버전업하고 있습니다. JS와의 관계 자바스크립트는 프로그래밍 언어로서 기본 Core를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API(DOM, BOM, Canvas, XMLHttpRequest, fetch, WebStorage 등), Ajax 1999년, 자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능인 Ajax(Asynchronous JavaScript and XML)가 XMLHttpRequest라는 이름으로 등장했습니다. 이전에는 HTML 코드를 서버로부터 받아서 웹페이지 전체를 렌더링 하는 방식으로 작동했기에 페이지가 바뀌면 페이지 전체를 다시 렌더링했지만, Ajax의 등장 덕분에 변경이 필요한 부분만 한정적으로 렌더링 하는 방식이 가능해졌습니다. jQuery 2006년 등장한 jQuery는 DOM(Document Object Model)을 더 쉽게 제어할 수 있도록 도와주고, 크로스 브라우징 이슈의 해결에도 일조했습니다. 자바스크립트보다 배우기 쉽고 직관적이기 때문에 넓은 사용자 층을 순식간에 확보했습니다. V8 JavaScript Engine 2008년에는 구글에서 V8 자바스크립트 엔진을 발표했습니다. 그 뛰어난 성능 덕분에 웹 어플리케이션도 데스크탑 어플리케이션만큼 좋은 사용자 경험을 제공할 수 있게 됐습니다. V8 엔진으로 JS는 크게 발전하기 시작했으며 기존에는 웹 서버에서 수행되던 로직들이 대거 프론트엔드 영역으로 넘어오게 됐습니다. Node.js V8이 등장하고 이듬해 라이언 달이 V8 엔진으로 빌드된 Node.js 자바스크립트 런타임 환경을 발표했습니다. 브라우저의 JS 엔진에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서도 동작할 수 있게 돼, 자바스크립트 만으로도 프론트와 백을 모두 개발할 수 있다는 이점을 가져왔습니다. SPA Framework 규모가 크고 복잡해진 모던 웹 어플리케이션과 발맞춰 대두된 CBD(Component Based Development) 방법론을 기반으로 하는 SPA(Single Page Application)가 대중화되며, Angular, React.js, Vue.js 등 다양한 SPA 라이브러리/프레임워크들이 등장했습니다. 자바스크립트의 특징 자바스크립트는 웹 브라우저에서 동작하는 유일한 프로그래밍 언어로, 인터프리터 언어(interpreteer language)입니다. 모던 JS 엔진들은 인터프리터와 컴파일러의 장점을 결합해 비교적 느리다는 인터프리터 언어의 단점을 해결했습니다. 명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어TypeScript를 이용하면 더 강력한 객체지향 언어가 됩니다. 인터프리터 언어 vs 컴파일러 언어 interpreter language: runtime에 문 단위로 한 줄씩 중간 코드(intermediate code)인 바이트코드(가상 머신에서 실행하도록 만든 바이너리 코드, 실행 환경에 구애받지 않습니다)로 변환한 후 실행합니다. 실행 파일을 따로 생성하지 않고, 인터프리트 단계와 실행 단계가 분리돼있지 않다는 특징이 있습니다.compiler languange: 코드가 실행되기 전 단계인 compile time에 코드 전체를 한번에 머신 코드로 변환한 후 실행합니다. 실행 파일을 생성하고, 컴파일 단계와 실행 단계가 분리돼 있습니다. 미리 컴파일을 하니 일반적으로는 인터프리터 언어에 비해 더 빠릅니다. 대부분의 모던 브라우저들이 사용하는 인터프리터들은 명시적인 컴파일 단계를 거치지는 않지만 복잡한 과정을 거쳐 일부 코드를 컴파일하고 실행합니다. 따라서 요즘은 그 구분이 점점 모호해지고 있다고 합니다. ",
    "date": "2022-09-12T17:09:00+09:00",
    "slug": "deep-dive-start-js-intro",
    "title": "딥다이브 시작: 자바스크립트 intro"
  },
  {
    "content": "리액트를 사용할 때 '클린 코드'를 작성하려면 어떻게 해야 할까요? 직접 겪으며 느낀 점을 정리합니다. 프론트엔드 개발에는 정해진 답이 없습니다. 버튼 하나를 만들더라도 정말 다양한 방법을 사용할 수 있고, 그 중 어떤 방법이 가장 좋은 방법인지는 개발자의 판단에 달려있습니다. 프론트엔드 개발은 정답이 없는 문제를 해결하는 과정이라고 할 수 있습니다. 덕분에 적당한 근거와 기준을 가지지 않는다면 금새 혼란에 빠진 코드가 나오곤 합니다. 나중에야 어떻게 되든 지금 당장 에러를 뿜더라도 동작만 하면 상관 없다는 생각이 드는 순간 코드는 점점 더 나락으로 빠져듭니다. 이런 점이 프론트엔드 개발의 어려운 점이자 매력이라고 생각합니다. 사용자와 바로 마주하는 개발이기 때문에 가장 빈번하게 수정이 일어나는 곳도 프론트엔드입니다. (적어도 제 생각에는 그렇다는 뜻) 프론트엔드 코드의 수명은 상대적으로 매우 짧기에 처음 작성하는 개발자조차 본인의 코드에 애착을 버리기 쉽상이고, 그렇게 나온 코드는 누구나 보기 싫어하는 코드가 되어버립니다. 이렇게 탄생한 코드에 변경이 필요하면 있는 것을 수정하는 것보다 처음부터 다시 만드는 것이 더 빠를 때도 많습니다. 이런 이유로 프론트엔드 개발은 개발자의 역량과 치밀한 생각이 더욱 더 빛을 발하는 영역이기도 합니다. 엔지니어는 항상 제한된 자원을 가지고 최적의 정답을 찾으려고 노력합니다. 유지 보수가 쉽고 확장성이 좋은 코드를 작성하려는 시도도 이런 노력의 일부라고 할 수 있겠죠. 클린 코드가 그토록 유명해진 이유도 이런 욕심을 누구나 가지고 있기 때문이 아닐까요? 잘못 작성한 코드로 시간과 자원을 낭비하는 최악의 상황을 피하고 최소한의 공수로 최대한의 효과를 내는 방법을 찾는 것이 우리가 엔지니어로서 해야 할 일이라고 생각합니다. 한 편, 리액트를 사용할 때 더 좋은 코드를 작성하는 방법은 잘 정리된 문서가 많지 않습니다. 다시 처음으로 돌아가면 프론트엔드 개발에는 정해진 답이 없기 때문입니다. 그래서 지금까지 리액트를 다루며 제가 생각한 점을 정리해보고, 나중에 다시 돌아와서 과거의 나와 얼마나 생각이 얼마나 달라졌을지 비교해보며 나만의 가이드라인을 찾아보고 싶다는 생각이 들었습니다. 이번 글의 내용은 제 생각과 경험을 녹여낸 것일 뿐이고 이 글을 읽고계신 분의 생각과 다를 수 있습니다. 여러분의 의견도 많이 나눠주셨으면 좋겠습니다. 시작하기에 앞서, 자동 완성 사용을 생활화합시다. IDE는 개발자의 생산성을 다양한 방법으로 높여줍니다. 저는 VSCode를 사용하는데 VSCode에는 Trigger Suggest라는 자동 완성 기능이 있습니다. 이 기능을 사용하면 IDE가 코드의 맥락을 분석해서 자동으로 사용할 수 있는 값을 제안해줍니다.  덕분에 '이 함수에는 어떤 인자를 넘겨야 하는지' 고민하고 코드를 뒤적이는 시간을 비약적으로 줄일 수 있습니다. 저는 이 기능이 DX에 매우 매우 큰 역할을 한다고 생각합니다. 이걸 잘 쓰는건 물론이고, 제가 작성하는 코드도 suggestion이 잘 나오도록 하는 것이 중요합니다. 처음엔 성가실지 몰라도 한 번 제대로 해두면 미래의 나와 내 팀원이 편해집니다. 내가 지금 작성하는 코드의 인터페이스가 이상하지는 않은지 자연스럽게 점검할 수 있는 기회를 주기도 합니다. 클린 코드에 대한 얘기를 하는 글에 이 내용이 들어간 이유는 바로 다음 항목에 나옵니다. 타입스크립트 사용은 필수입니다. 타입스크립트는 개발자의 실수를 줄여주고 코드의 짜임새를 높여줍니다. 그러나 이런 원론적인 이유에 더해 리액트에서 타입스크립트를 사용하는 것이 필수인 이유가 있습니다. 버튼에 스타일을 입힌 Button 컴포넌트를 자바스크립트로 작성했습니다. props로 prop들을 묶어주고, button 요소에 전달해줘서 단순히 스타일만 입히고, 사용단에서 얼마든지 필요한 prop을 줄 수 있도록 잘 작성된 코드입니다. 이렇게 자유자재로 필요한 prop을 넘길 수 있죠. 이번에는 Button 컴포넌트의 구현을 전혀 모르는 동료 개발자가 제 컴포넌트를 사용하려 한다고 생각해볼까요? Button에는 어떤 prop을 넘겨줄 수 있는걸까요? 버튼이라는 네이밍을 가지고 있기 때문에 onClick 등등을 넘길 수 있겠구나 짐작하기는 쉽습니다. 그러나 아무리 그래도 찝찝하고, 지레 짐작해 넘겼다가 근처에서 에러라도 발생하면 애꿎은 Button 컴포넌트만 탓하며 결국 Button의 구현부를 뒤져보게 될겁니다. 이런 상황을 방지하기 위해 Button 컴포넌트의 인터페이스를 명확하게 정의해두는 것이 좋습니다. 그리고 이런 인터페이스를 정의하는 가장 좋은 방법은 타입스크립트를 사용하는 것입니다. 리액트는 bottom-up 방식으로 개발하는 것이 좋습니다. 리액트는 CDD, Component Driven Development를 위한 도구입니다. ",
    "date": "2023-11-30",
    "slug": "react-clean-code",
    "title": "리액트 클린코딩"
  },
  {
    "content": "실무에서 사용되는 여러 CSS 테크닉들을 익혔습니다. <input> 요소 체크박스 바꾸기  <select> 요소 커스터마이징 <select> 요소는 스타일링이 까다로워 아얘 따로 구현합니다. 다만, 모바일에서는 OS마다 형태가 매우 다르기 때문에 <select> 요소를 그대로 사용합니다.  스타일중 중요한 부분만 떼서 보겠습니다. .btn-select에 이런 property와 value를 부여해서 컨텐츠가 길어지면 ...으로 줄이도록 합니다. 같은 코드가 <option> 역할을 하는 <button> 요소에도 들어있습니다. 버튼 옆에 있는 삼각형 이미지는 background-image로 넣고, .on 클래스가 붙으면 바꿔줍니다. <article> 요소에 position: relative;를 주고 ul.list-selectives에 position: absolute;를 줘서 확실하게 <article> 요소에 붙도록 만들어줍니다. absolute 부분은 밑에 위치할 요소 위로 올라가게 되므로 활성화돼도 레이아웃이 깨지지 않도록 합니다. .btn-select에 .on 클래스가 붙으면 .list-selectives의 display property를 block으로 바꿔 보일 수 있도록 합니다. IR(Image Replacement) 테크닉 스크린리더나 브라우저를 위해 정보를 전달하는 텍스트를 넣으면서 디자인적으로는 보이지 않도록 하는 스타일입니다. 재현님이 추천하신 글 글 내용중 opacity property를 0으로 주면 스크린리더가 읽지 못한다는 말이 있는데, 현재는 읽어주는 것으로 확인됩니다. 이렇게 인터넷에서 얻는 정보들은 진위여부를 잘 알아봐야 합니다. 카카오 이미지 내에서 의미있는 텍스트의 대체 텍스트를 제공할 때 text-indent: -9999px;때문에 브라우저는 어찌됐든 -9999px까지 그려야 한다는 단점이 있습니다. (다만 성능 저하를 실제로 불러오는지에 대해서는 근거가 없다고 합니다.) 현재는 잘 사용하지 않습니다. 스크린리더가 읽을 필요는 없지만 마크업 구조상 필요한 경우 스크린리더는 width와 height가 0이라면 읽지 않는다는 점을 이용한 방법입니다. 이미지가 나오지 않을 때에도 대체 텍스트를 보여주고자 할 때 현재 카카오가 가장 많이 사용하는 방법입니다. 이미지가 나오지 않을 때 대체 텍스트를 보여주고자 하는 때란 언제를 말하는걸까요? 자주 쓰이지 않는 폰트로 구성된 문구 등이 들어가면 sprite 등의 기법을 써 이미지로 처리하는데, 이 때 이미지가 로드되지 않아도 텍스트가 보일 수 있도록 하기 위해 사용합니다. 네이버 IE 구버전에서는 인식하지 못하는 경우가 있기 때문에 margin: -1px;을 넣는다고 합니다. clip property를 이용해 요소를 잘라내기도 합니다. clip은 position: absolute;가 부여된 경우에만 사용할 수 있습니다. clip은 deprecated property이기 때문에 대체재인 clip-path: inset(50%);를 추가로 넣는것도 좋다는 강사님 의견이 있습니다. 쿠팡 애플 네이버와 비슷한 방법을 사용하고 있습니다. border, padding property도 지정해줘서 조금 더 범용성있게 사용하고자 한 듯 합니다. 에어비엔비 aria-label이라는 웹 접근성을 위한 최신 attribute를 사용하거나, 네이버와 비슷한 방법을 사용하고 있는것이 확인됩니다. 레거시 브라우저를 위해 조금 더 철저히 코드를 추가한 것을 볼 수 있습니다. CSS Sprite 기법 여러 조그마한 이미지를 하나의 이미지 파일에 모아 이미지 로드 부담을 줄이는 기법입니다.  이렇게 로드해온 이미지를 가지고 CSS에서 background-image로 적당히 잘라(position, width, height 이용) 사용하는 식입니다. CSS Sprites Generator Sprite 기법을 사용할 때 유의점 Sprite가 너무 크면 '판' 자체의 로드가 부담을 가해 여러 군데의 로드가 늦어질 수 있다는 문제가 있습니다. 변경사항이 있을 경우 수정이 까다롭다는 점도 단점중 하나입니다. 따라서, Sprite가 너무 커지지 않도록 무조건 한 '판'으로 모으기보다는 적절히 나누는것도 필요합니다. 추후 Webpack으로 해결이 가능한 문제이기도 합니다. Webpack은 이미지를 data format (base64) 으로 디코딩해 삽입해줍니다. 레티나 디스플레이 대응법 레티나 디스플레이는 화소 밀도가 높은 디스플레이(300PPI 이상)를 부르는 애플 LCD 제품의 브랜드 이름입니다. 고해상도 화면으로 기술이 발전하며 논리적 픽셀(CSS에서 표현하는 화소의 기본 단위)과 물리적 픽셀의 차이가 발생하게 됐습니다. 브라우저는 CSS에서 정의한 픽셀만큼 이미지를 렌더링하기에 원래 물리적 픽셀에 맞게 렌더링된 이미지가 논리적 픽셀의 크기만큼 커져버리게 됩니다. 화면에 그리고자 하는 이미지 사이즈의 두 배 되는 이미지를 넣으면 해결할 수 있습니다. 대신 이 때는 이미지의 사이즈를 조절하는 과정을 거쳐야 합니다. 예전에는 모바일의 경우 레티나 화면과 아닌 화면을 분리해서 개발했지만, 요즘엔 다 좋아져서 굳이 구분하지는 않는다고 합니다. ",
    "date": "2022-09-22T16:37:00+09:00",
    "slug": "css-practical-techniques",
    "title": "CSS 실무 테크닉"
  },
  {
    "content": "bundler의 대표주자 Webpack이 무엇인지, Core Concepts를 확실하게 정리해두려고 합니다. 본 글은 Webpack Docs와 생활코딩님의 강의를 참고해 작성했습니다. Overall webpack은 모던 JS 어플리케이션을 위한 static module bundler입니다. webpack이 앱을 처리할 때, 하나 이상의 진입점(entry point)에서 종속성 그래프(dependency graph)를 내부적으로 작성하고, 프로젝트에 필요한 모든 모듈을 하나 이상의 번들로 만듭니다. 조금 어려운 용어가 많습니다. 차근 차근 뿌셔보겠습니다. 뿌셔보기 webpack을 이해하려면 webpack이 개발되기 전의 상황을 보아야 합니다. bundler index.html src/hello.js src/world.js webpack이 없었을 때 모듈을 export, import하던 방법입니다. 각각의 자바스크립트에서 명시적으로 export해야만 word라는 변수를 사용할 수 있습니다. 여기에는 두가지 문제가 있습니다. 오래된 브라우저에서는 작동하지 않습니다.만약 모듈이 수 십, 수 백 개의 스크립트 뿐만 아니라 css, 이미지 등의 다른 정적 파일까지 있었다고 가정하면, 많은 컴퓨팅 파워가 들어갔을 것입니다. 이는 결국 부하를 발생시키고, 속도가 느려지니 사용자 경험이 안좋아질 것이고, 서비스를 제공하는 측에 입장에서도 비용이 많이 들게 됩니다. 이에, '웹에서도 모듈의 개념을 이용하자', '여러개의 파일을 하나로 묶어서 제공하자'라는 의견이 나와 개발된 것이 바로 bundler입니다. webpack은 bundler의 대표주자이고요. dependency graph 한 파일이 다른 파일에 종속될 때마다 webpack은 '종속성 그래프'를 자동으로 생성합니다. 이를 통해 이미지, 웹 폰트같은 코드 이외의 asset을 가져오고 어플리케이션의 종속성으로 제공할 수 있게 됩니다. webpack은 configuration file에 정의된 모듈 목록에서부터 처리를 시작합니다. 이를 진입점(start point)라고 부릅니다. 이 진입점으로부터 어플리케이션에 필요한 모든 모듈을 포함하는 종속성 그래프를 재귀적으로 구축하고, 모든 모듈을 소수의 bundle로 묶습니다. 이렇게 묶인 모듈들은 브라우저에서 번들 단위로 로드됩니다. Configuration File webpack의 configuration file을 그럼 실제로 한번 보겠습니다. webpack.config.js entry 내부적으로 생성되는 dependency graph를 어디서부터 만들기 시작할 지를 지정합니다. string | [string] 타입으로, 여러 entry point를 지정할 수 있습니다. default 값은 ./src/index.js입니다. output 출력 bundle 파일이 저장되는 경로와 파일 이름을 지정합니다. loader webpack의 핵심 기능이라고 볼 수 있습니다.  bundler는 이렇게 다양한 형태의 파일들을 간단하게 묶어주는 일을 합니다. 그 중에서도 webpack은 자바스크립트가 아닌 파일들조차 번들링을 해줍니다. 그 과정이 바로 loader를 통해 이뤄집니다. webpack을 얼마나 잘 다루는가에 대한 부분도 이 loader를 얼마나 다양하고 유연하게 사용할 수 있는가에 따라 갈린다고 합니다. 위의 config에 나와있는 .css를 load하는 부분은 아래의 패키지를 설치하면 사용할 수 있습니다. css-loader는 css를 모듈로서 불러올 수 있게 해주며, style-loader는 웹 페이지 안에 <style>태그로 주입해주는 역할을 합니다. 즉, css를 로드할 때 따로 .css 파일을 받아오지 않더라도 html 파일 내에 이미 스타일이 들어가 있는 상태로 오므로 두개로 나눠서 올걸 하나로 합쳐서 준다는 거죠! 정리하면 loader는 입력한 asset들을 어떻게 가공해서 bundle로 만들지를 담당하는 녀석들입니다. plugin loader는 모듈을 어떻게 만들어갈까에 대한 부분이었다면, plugin은 그렇게 만들어진 bundle에 추가적으로 어떻게 가공할 지를 담당합니다. plugin마다 사용법이 제각기 다릅니다. 대표적인 plugin인 HTMLWebpackPlugin을 사용해 보겠습니다. HTML 파일을 템플릿 등을 이용해 더 쉽게 생성할 수 있도록 도와주는 플러그인입니다. 앞서 보았던 webpack.config.js로 돌아가보면, plugins에 HtmlWebpackPlugin()을 명시해 준 것을 볼 수 있습니다. 이렇게 하면 output이 담기는 dist/에 index.html이 아래처럼 자동으로 생성됩니다. entry point가 여러개라면 <script> 태그도 여러개 생성됩니다. 마무리 모던 자바스크립트 어플리케이션과 떼 놓을 수 없는 존재인 bundler, webpack에 대해 간단히 알아봤습니다. 저는 webpack을 직접 사용할 일은 많지 않을거라고 생각해 깊게 공부하지는 않았지만, 언젠가 한번 정리해봐야겠다 싶었는데 유익한 시간이였습니다. webpack은 bundling 외에도 lazy loading, code splitting 등을 지원하는데 이 개념은 Next.js를 공부하면서 배웠던 내용이라 신기합니다. 참고로 Next.js는 webpack5를 이용하는데, 원한다면 직접 webpack의 config를 바꿀 수 있다고 하네요. ",
    "date": "2022-08-14",
    "slug": "what-is-webpack",
    "title": "Webpack이란?"
  },
  {
    "content": "자바스크립트의 변수를 간단히 알아봅니다. 변수(variable) 컴퓨터는 메모리를 통해 데이터를 기억하고, CPU를 통해 연산합니다. 메모리는 데이터를 저장할 수 있는 memory cell의 집합체입니다. cell 하나당 1 byte(= 8 bit)이며 1 byte 단위로 데이터를 저장하거나 읽습니다. 각 cell은 고유의 memory address를 가집니다. 컴퓨터가 10 + 20이라는 연산의 결과값 30을 메모리에 저장했다고 하면, 이 30이라는 값에 접근할 수 있는 방법은 30이 저장된 cell의 주소값을 통해 직접 접근하는 것입니다. 하지만, 주소를 통해 직접 값에 접근하는 것은 매우 위험한 일입니다. 따라서 JS는 개발자의 직접적인 메모리 제어를 허용하지 않습니다. 그렇기 때문에 변수(variable)이라는 개념이 필요합니다. 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 그 자체 혹은 그 메모리 공간을 식별하기 위해 붙이는 이름을 말합니다. 즉, 값의 위치를 가리키는 상징적인 이름입니다. 인터프리터가 알아서 메모리 공간의 주소로 치환해 실행합니다. 식별자(identifier) 변수 이름을 식별자라고도 부르는데, 어떤 값을 구별해 식별할 수 있는 고유한 이름을 말합니다. 여기에서 식별자 result에는 값 30이 저장돼 있는 메모리 주소를 기억합니다. 이를 값이 저장돼 있는 메모리 주소와 매핑 관계를 맺는다고 말하며, 이 매핑 정보 또한 메모리에 저장됩니다. 변수 이름 뿐만 아니라 함수, 클래스 등의 이름도 식별자입니다. 변수의 선언(variable declaration) 변수 선언은 값을 저장하기 위한 메모리 공간을 확보(allocate)하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)해 값을 저장할 수 있게 준비하는 것을 말합니다. 이 때 확보된 공간은 해제(release)되기 전까지는 누구도 사용할 수 없도록 보호됩니다. JS에서 변수를 선언할 때 사용할 수 있는 키워드는 var, let, const 등이 있습니다. 추후 정리할 여러 이유들로 인해 최근에는 var를 거의 쓰지 않지만, 종종 옛날에 작성된 코드들에서 사용됩니다. ES6에서 let, const 키워드가 추가됐다는 점을 알아둡시다. 변수를 선언만 하고 값을 할당하지 않으면 JS 엔진은 undefined라는 값을 암묵적으로 할당해 초기화하기 때문에 쓰레기 값이 확보된 메모리 공간에 있을 염려가 없습니다. undefined는 primitive value중 하나입니다. 선언문의 실행 시점과 호이스팅(hoisting) 변수 선언문보다 변수를 참조하는 코드가 더 앞에 있다면 어떻게 될까요? JS 코드는 인터프리터 언어기 때문에 한 줄씩 순차적으로 실행되므로 위 코드에서는 undefined가 출력될 것입니다. 여기서 중요한 점은 참조 에러(ReferenceError)가 발생하지 않는다는 것입니다. JS는 소스코드를 순차적으로 실행하기 전에 코드를 평가하며 실행하기 위한 준비를 합니다. 이 때, 모든 선언문을 코드에서 찾아 먼저 실행합니다. 그리고 평가 과정이 끝나면 선언문을 제외한 코드를 한 줄씩 실행합니다. 즉, 선언문이 runtime이 아닌 그 이전 단계인 평가 단계에서 먼저 실행되기 때문에 ReferenceError가 발생하지 않습니다. 따라서 선언문이 어디에 있든 있기만 하다면 언제든지 변수, 함수, 클래스 등을 참조할 수 있습니다. 이런 특징을 호이스팅이라고 부릅니다. 값의 할당(assignment) 변수에 값을 할당할 때는 대입 연산자 =를 사용합니다. 변수의 선언과 할당은 한 문으로 축약해 표현할 수 있지만, 주의할 점은 실제 실행될때는 변수의 선언과 할당 시점이 다르다는 것입니다. runtime 전에 name이 선언되므로 코드는 ReferenceError 없이 잘 실행됩니다. 그렇다면 여기에서 두 console.log는 각각 어떤 내용을 출력할까요? 이는 아래 순서로 실행된다고 생각하면 쉽게 예측할 수 있습니다. 값의 재할당(reassignment) let이나 var 키워드로 선언된 변수의 값은 재할당 될 수 있습니다. 위 코드가 실행되면, x 값은 undefined가 할당되고, 다음으로 10이 먼저 재할당됐다가 20이 재할당됩니다. 이 때 재할당 되는 값은 먼저 할당된 값이 저장돼 있던 메모리 공간에 덮어쓰는 것이 아니라, 새로운 메모리 공간을 확보하고 거기에 새로 할당된 값을 저장합니다. 매핑 정보가 사라진 undefined와 10은 가비지 콜렉터에 의해 자동으로 해제됩니다. (언제 해제될지는 예측할 수 없습니다.) garbage collector가 있는 언어를 managed language라고 부릅니다. C언어는 대표적인 unmanaged language이며 malloc(), free()같은 저수준 메모리 제어 기능을 제공합니다. 덕분에 개발자의 역량에 따라 최적의 성능을 확보할 수 있지만 치명적 오류를 일으킬 가능성도 늘어납니다. 반면 managed language는 알아서 메모리를 관리해주니 생산성은 높지만 성능 면에서 손실을 감수할 수밖에 없습니다. 식별자 naming convention 식별자를 naming할때는 주석을 달지 않고도 변수가 무엇인지 설명할 수 있는지를 잘 생각하며 정하면 좋습니다. 자주 쓰이는 컨벤션은 아래의 네가지가 있습니다. 일반적으로 변수나 함수의 이름에는 camelCase를, 생성자 함수나 클래스 이름에는 PascalCase를 사용합니다. ",
    "date": "2022-09-12T17:09:00+09:00",
    "slug": "deep-dive-ch4-variables",
    "title": "딥다이브 4장: 변수"
  },
  {
    "content": "4개월 간의 FE 스쿨 과정이 모두 끝났습니다. 지난 6일 멋쟁이사자처럼 프론트엔드 스쿨 3기 활동이 종료됐습니다. 살면서 이렇게 열심히 살았던 적이 없었다고 할 수 있을 정도로 정신없이 보낸 시간을 돌아보려고 합니다. 일단 감사 인사부터 마지막 날까지 열정적으로 수업해주셨을 정도로 너무나 멋진 위니브 강사님과 멘토님들을 만난 덕분에 정말 보람찬 4개월이었습니다. 멋쟁이사자처럼 운영진님들도 밤낮 없이 수강생들과 함께 해주셨기에 힘내서 달릴 수 있었습니다. 혹시 멋사 프론트엔드 스쿨 지원을 고민중이신 분들이 이 글을 읽으신다면 꼭 지원하시라고 강추드리고 싶습니다. 이런 부트캠프 없습니다 정말로... 어떤 일들이 있었나 글 특성상 광고처럼 보이는 문구들이 많이 들어갈것 같은데 광고 아닙니다...ㅋㅋㅋ 정말 느낀점 회고입니다. 무럭 무럭 자랐다 부트캠프에 지원하기 전과 비교했을 때 엄청나게 성장했다는게 체감됩니다. HTML, JS 등 FE 개발자로서 기본적으로 알아야 할 기술을 잘 습득했고, 제 코딩 역량의 기틀이 잡혔습니다. 부트캠프를 지원할 때 가장 걱정했던건 멋사 부트캠프 커리큘럼이 기본에 충실하게 계획돼 있었다는 점이었습니다. 나는 HTML이나 CSS, JS 기초는 이미 알고 있는데... 좀 더 다양한 스킬을 배우는 곳을 찾아볼까? 라는 고민을 많이 했었는데, 아주 거만한 생각이었다는걸 알기까지는 그리 오래 걸리지 않았습니다. (당장 이 블로그만 하더라도 아마 지난 8월달에 Validation을 돌렸다면 워닝으로 가득했을겁니다.) \"잘 알고있다는 생각은 버려야 한다\"는 교훈을 얻었습니다. 이렇게 기초를 다지는 기간을 이 시기에 가질 수 있었다는게 얼마나 다행이었는지 모릅니다. 덕분에 이제는 4개월 전에 느꼈던 실력에 대한 불안감은 사라지고, 자신감이 그 자리를 대신하게 됐습니다. 혼자였다면 Tailwind CSS나 Sass는 건드리지도 않았을텐데, 캠프 과정을 따라가며 FE 진영의 다양한 기술들을 골고루 맛볼수 있었기에 이 분야를 보는 시야도 넓어질 수 있었습니다. 다양한 분들을 만났다 매주 게더에서 모였던 회고조나 마지막 한달간의 팀 프로젝트때 새벽까지 만났던 팀원분들, 그 외 다양한 자리에서 만난 동료 수강생분들 모두 정말 좋은 인연이었습니다. 매일 아침부터 새벽까지 공부하는 와중에 모두 살갑게 대해주셔서 외롭지 않을 수 있었습니다. 중간 중간에 멘탈이 나갔을 때도 격려해주신 덕분에 힘도 났고, 여기에서 만나뵌 분들은 앞으로도 계속 소통하고 싶습니다. 리더십을 길렀다 정말 감사하게도 회고조나 팀 프로젝트 모두 리더로서 활동하는 경험을 쌓을 수 있었습니다. 칭칭이(칭구칭긔들, 도움이 필요한 동료와 함께 문제 상황에 대해 고민하는 활동) 스터디를 열어보기도 했었습니다. 회고조에서는 어색한 분위기를 깨고 친해지려고 노력하면서 부드럽게 말하는 방법을 익혔고, 팀 프로젝트에서는 힘겨운 프로젝트에서 다 같이 갈 수 있는 방법을 많이 고민했습니다. 모두 좋은 분들만 만나서 회고조장이나 팀장으로서 활동하는데 어려움이 전혀 없었다는게 아쉽다면 아쉬운...ㅋㅋㅋ 사람 운이 정말 좋았다는 생각을 많이 했습니다. 내 생각을 말하는 연습을 정말 많이 했다 멋사에서 활동하면서 제가 가장 적극적으로 임했던건 지식 나누기였던 것 같습니다. 캠프 들어오기 전까지 독학 기간이 긴 편이었기에 다른 분들께 도움을 드릴 수 있겠다 싶었고, 회고조원 분들께 제가 아는 내용을 자주 설명했습니다. 그러다가 50여 분의 동료 수강생들께 간단한 리액트 프로젝트 개발 강의를 해드릴 기회가 있었는데, 강의가 끝나고 여러 분들께 감사 인사를 따로 받아서 정말 뿌듯했습니다. 팀 프로젝트를 하면서도 팀원분들께 리액트 기초를 조금씩 설명드렸는데, 다들 좋아해주셔서 더 신나서 얘기했던 기억도 있습니다. 매번 '강의'를 시작하면 최소 서너시간은 걸렸는데, 목은 아팠지만 들어주시는 분들께 도움이 되고 있다는게 느껴져서 자꾸 더 하고싶더라고요. 덕분에 남을 이해시킨다는 기쁨을 알게됐고, 지식을 나누는 개발자가 돼고 싶다는 꿈을 꾸게 됐습니다. 덤으로 기술과 관련된 내용을 정확한 용어로 말하는 방법도 익힐 수 있었습니다. 이 부분은 나중에 기술 면접에서 크게 도움이 될 것 같습니다. 이력서가 정말 좋아졌다 부트캠프에 지원했던 이유중에는 취업도 있었습니다. 취준중에 가장 속을 썩였던건 이력서였습니다. 내가 한 일을 정리하는게 생각보다 쉽지 않았고, 실제로 이력서 합격률도 많이 낮았고요. 그래서 부트캠프에서 주최한 정원희 개발자님의 이력서 특강이나, 위니브 강사진 분들께 이력서 피드백을 적극적으로 받으려고 했습니다. 특히 원희님 특강은 이력서를 100명의 동료 수강생분들께 오픈하고 실시간으로 피드백을 받아야 했기에 처음엔 부끄러웠지만, 다른 분들 피드백도 보면서 제 이력서를 고쳐나갈 수 있었던게 정말 좋았습니다. 마지막에는 좋은 피드백을 받아 뿌듯했고, 제가 보기에도 제 이력서의 완성도가 많이 올라갔다는 생각이 듭니다. 마무리 진짜 멋사 FE 스쿨 부트캠프 듣기를 정말 정말 잘했습니다. 부트캠프 선택도 정말 기가막혔고, 어딘가에 소속됐다는 안도감으로 흘러가는 시간에 대한 압박은 덜고 기초 중심으로 공부하는 시간을 가졌던게 조금 오버해서 제 20대 신의 한 수 였다고 생각합니다. 단순히 지식만 쌓은게 아니라 소프트 스킬적인 측면에서도 성장했던 좋은 시간이었습니다. 이제 정말 취준생으로서 다시 달려갈 일만 남았습니다. 나중에 취업하게 되면 그동안 있었던 일들 마저 적어보기로 하고, 오늘 회고는 여기까지!! ",
    "date": "2023-01-15",
    "slug": "likelion-frontend-final-retro",
    "title": "멋사 프론트엔드 스쿨 마무리 회고, 앞으로 나는...?"
  },
  {
    "content": "지난 포스트에 이어서 검색 기능을 마저 구현해봤습니다. Debouncing과 Throttling을 비교해봤습니다. 검색바를 구현하자 이제 API도 준비됐겠다, 검색바만 구현하면 완성입니다. 검색바 스타일 프로토타입 스타일을 완성했습니다. 검색바가 열렸을 때 transition이 끝난 후 input 요소에 포커스가 갈 수 있도록 transition 시간만큼 setTimeout을 이용, 약간의 딜레이를 준 후 input 요소에 포커스하도록 했습니다. 검색바는 width값을 조절해 나왔다가 들어가도록 했는데, 이 과정이 Reflow를 일으킬 수 있으나 position: absolute를 줘 그 영향을 최소화했습니다. 검색 내용을 fetch하면 되는데... 이제 사용자가 입력할 때 입력한 값을 기반으로 API를 fetch하면 됩니다. 그런데, 단순히 사용자가 값을 입력할 때마다 요청을 날린다면 불필요한 API Call이 과도하게 많아질것입니다. 이럴 때 사용할 수 있는 기법이 바로 Throttling과 Debouncing입니다. 각각 어떤 기법인지에 대한 설명은 생략하고 테스트해본 결과를 보겠습니다. 기본 이벤트  키를 입력할때마다 이벤트가 트리거되고있습니다. Throttling 테스트  일정 시간만큼 cool down 시간을 가지고 이벤트가 트리거됩니다. Debouncing 테스트  useEffect()를 활용해 debouncing을 구현했습니다. 입력이 끝나지 않으면 setTimeout()에 들어가는 콜백이 실행되지 않고, 입력이 끝난 후 일정 시간이 지나야 콜백이 실행됩니다. 저는 API Call을 최소화하고싶기 때문에 debouncing 기법을 사용하도록 하겠습니다. 쿼리를 넘기고 데이터를 받아오기 쿼리 param을 넘겨서 탐색 결과를 받아옵니다. 이후 이 데이터를 가지고 데이터를 갱신합니다. 이후 검색 결과를 나타낼 마크업과 스타일을 완료하면 됩니다. Troubleshooting 하지만 한번에 다 잘되면 불안한 것이 개발자죠... 계속 여러 검색어로 테스트를 해본 결과 특정 검색어를 입력하면 탐색 로직이 완료되는데까지 비정상적으로 긴 시간이 걸리는 것을 확인할 수 있었습니다. 정확한 이유는 알 수 없었지만 블로그 글 내용에서 탐색하는 부분을 제외했을 때는 해당 이슈가 발생하지 않는 것으로 보았을 때, 긴 글들을 대상으로 매치되는 부분을 탐색하는 데 시간이 오래 걸리는 조합이 있는 것 같았습니다. 이런 경우 content에 대한 탐색을 중단하고 title에 대한 탐색 결과만 리턴하길 원했는데 그렇게 만드는 과정이 쉽지 않았습니다. JS 동기 함수의 시간이 너무 오래 걸릴 경우 error를 throw하기 Fuzzy Search를 진행하는 함수는 동기 함수인데, 어떻게 하면 실행 시간을 측정하고 timeout error를 띄울 수 있을까요? 원래는 이런 방법으로 처리해보고자 했습니다. getFuzzyPostData()의 두번째 인자로 title만 확인할지 여부를 결정하는 boolean을 받도록 수정하고 위의 코드를 작성했습니다. Promise.race()를 써서 타임아웃을 확인하는 Promise와 getFuzzyPostData()중 어느쪽이 먼저 resolve되는지 확인하고, 그 결과에 따라 필요한 처리를 하도록 분기한 것입니다. getFuzzyPostData()를 async로 만들면 위 코드가 제대로 동작할줄 알았습니다. 그러나, 동기적 동작을 하는 코드는 결국 동기적으로 실행됐고, 동기적 코드가 실행되는 중에는 비동기가 실행되고 있는 queue system에서 내뱉은 handler에 절대로 도달하지 못하기에 문제가 해결되지 않았습니다. 따라서, 탐색 중간 중간에 누적 동작 시간을 확인해 Timeout인지 여부를 직접 확인하는 방향으로 바꾸기로 했습니다. 실제 탐색을 진행하는 findFuzzyPostData()에 각 탐색마다 시작 시간과 현재 시간의 차가 TIMEOUT보다 큰지 여부를 확인하고, 크다면 Error를 throw하도록 했습니다.  원하던대로 시간이 너무 오래 걸리면 title만 가지고 탐색한 결과를 리턴하고 있습니다! 🙌🙌 Vercel Serverless Function Timeout Error 그렇게 행복한 상상을 하며 deploy를 했지만 역시나 배포는 호락호락 하지 않았습니다 😂  'ㅂㄹㄱ에 검색 기능을 구현해보자'라는 검색어를 넣었을 때 생긴 문제입니다. Hobby 계정(무료 계정)에 제공하는 최대 Timeout은 10초라고 하니, 제가 잡지 못한 예외가 또 있는 것이 분명했습니다. 다시 고민해보니 생각하지 못한 케이스가 두가지 있었습니다. 위 로직대로라면 최소한 하나의 Post의 content에 대해서는 일단 match를 찾아야 합니다. 즉, 그 하나의 Post에 대해 match를 찾을 때 시간이 10초 이상 걸린다면 Timeout 에러를 뒤늦게 throw하게 되는겁니다. 또한, A, B, C 의 세 문서가 있다고 가정했을 때 A, B까지는 TIMEOUT보다 덜 걸렸으나 C를 검사할 때 TIMEOUT을 한참 뛰어넘는 시간이 걸리는 경우도 있었을겁니다. 이 문제를 해결하기 위해 저는 두가지 해결책을 고민했습니다. CacheDB의 순서를 content가 적은 순으로 나열합니다. 그러면 길이가 짧아 검사에 시간이 많이 걸리지 않는 포스트부터 검사하므로 edge case에 대응할 여지가 더 많이 생길 것입니다. (위의 두번째 문제에 대한 해결책)TIMEOUT을 줄입니다. Sol1. CacheDB의 순서를 content가 적은 순으로 나열하기 이후 npm run cache로 새 캐시를 생성해 다시 테스트해보니 일단 문제가 됐던 'ㅂㄹㄱ에 검색 기능을 구현해보자'라는 문구에 대한 문제는 해결됐습니다. 그런데, 그 과정에서 새로 알게된 문제가 또 있습니다. 제가 사용한 Fuzzy 로직으로는 초성이 세 개 이상이면 무조건 Timeout이 되고 있었습니다. 포스트가 많아질수록 이 문제는 더 심해질텐데 추후 content에 대해 match를 어떻게 하면 더 효율적으로 찾을 수 있을지에 대해 공부해봐야 할 것 같습니다. Sol2. TIMEOUT 줄이기 Sol1을 통해 문제를 해결했으므로 Sol2는 사용하지 않기로 했습니다. TIMEOUT을 줄이면 줄일수록 content에 대한 검색을 수행할 가능성이 더 줄어들어 제가 원하는 퀄리티 높은 검색을 구현할 수 없기 때문입니다. 그렇지만 앞으로 추가적인 문제가 발생한다면 최후의 방법으로 이걸 써야 할 것 같습니다. 결과물  우선은 원하던대로의 결과물이 잘 나왔습니다. 매칭된 부분을 하이라이트도 해주고 있어서 만족스러워요! 왕뿌듯 ",
    "date": "2022-11-27T01:30:00+09:00",
    "slug": "blog-search-feature-part2",
    "title": "블로그에 검색 기능을 구현해보자 2"
  },
  {
    "content": "GPT는 개발자를 대체할 수 있을까요? 주니어 개발자로서의 제 생각을 정리해봅니다. 결론 결론부터 말씀드리면, 제 생각은 그렇다 입니다. 그럼 저는 더이상 필요 없는 사람이 된걸까요? 주니어 개발자로서 제가 GPT를 바라보는 관점을 짧게 정리해보겠습니다. GPT GPT는 Generative Pretrained Transformer의 약자입니다. LLM(Large Language Model)의 일종으로, transformer 알고리즘을 활용한 인공 신경망을 사용하여 인간과 같은 텍스트를 생성하는 자기 회귀 언어 모델입니다. 조금 더 자세한 원리를 보고싶다면 이 아티클을 추천드립니다. 간단하게 요약하면 특정 토큰 뒤에 올 수 있는 토큰들의 확률을 계산하여 가장 높은 확률을 가진 토큰을 선택하고, 그 다음 토큰을 예측하는 방식입니다. 즉, '나는' 뒤에 '밥을'이라는 토큰이 나올 확률이 높다고 판단하면 '나는 밥을' 이라는 문장을 생성하는 것입니다. 주니어 개발자와 GPT 이미 수많은 개발자들이 GPT의 도움을 받아 개발하고 있습니다. 저 또한 GitHub의 Copilot을 사용하고 있는데, 개발 생산성이 어마무시하게 올라갔다는 점을 직접 느끼기도 했죠. 테스트 코드를 작성할 때 ChatGPT의 도움을 적극적으로 받고 있기도 합니다. 주니어 개발자인 저로서는 GPT 덕분에 더 좋은 코드를 더 빠르게 배우고 적용할 수 있게 됐고, 더 많은 시간을 학습에 투자할 수 있었습니다. Copilot의 도움은 아주 똑똑한 '자동완성' 기능처럼 여겨졌고, ChatGPT는 제 곁에서 24시간 코드 리뷰를 해주는 친구처럼 느껴졌습니다. 그러나, 처음엔 그리 친근하게 다가오지는 않았습니다. GPT가 주는 공포 GPT는 확률에 따라 다음에 올 토큰을 결정하는 모델입니다. context만 적절히 주어진다면 '인간이 적었을' 문장을 자동으로 생성해주는 효과를 가져오는거죠. 제가 하는 일이 과연 이와 크게 다를까요? '로그인 기능을 만든다'는 context가 주어졌을 때, 'Modal 컴포넌트를 만든다'는 세부 구현 사항을 떠올리는건 결국 확률에 따라 다음 토큰을 결정하는 것과 다를 바가 없는것이 아닐까요? 이런 생각에 처음 GPT를 마주했을 때는 공포를 느꼈습니다. 아직 나는 내 커리어를 제대로 시작해보지도 않았는데, 이미 내 일을 대체할 수 있는 기술이 나왔다는 사실에요. 하지만 이런 공포는 오래 가지 않았습니다. 소프트웨어 공학자가 하는 일은 무엇인가 소프트웨어 공학자가 하는 일은 무엇일까요? 저는 이 질문에 대해 다음과 같이 생각합니다. 소프트웨어 공학자는 문제를 정의하고, 이를 해결하는 컴퓨터 소프트웨어의 설계, 개발, 유지 보수, 관리를 하는 사람이다. 시대가 변하면서 우리가 사용하는 기술만이 진보했을 뿐, 우리 주위의 문제를 컴퓨터로 해결한다는 점은 변하지 않았습니다. 2000년대 초반 웹 개발자는 PHP를 사용해 문제를 해결했고, 2010년대 웹 개발자는 SPA 웹 개발을 통해 문제를 해결했죠. 그리고 2020년대 초반 웹 개발자인 저는 GPT를 사용해 문제를 해결하고 있습니다. GPT 또한 하나의 도구일 뿐입니다. GPT가 제가 하는 일을 대체할 수 있다는 사실에 공포를 느끼는 것은, PHP가 제가 하는 일을 대체할 수 있다는 사실에 공포를 느끼는 것과 다를 바가 없다는 생각이 들었죠. 아무리 더 진보한 AI가 나오더라도, 문제를 제시하고 명령을 내리는 사람은 여전히 사람일 것입니다. (문제 정의까지 AI가 해준다면 그 땐 이미 '노동'이란것 자체가 사라졌을거라고 생각합니다.) 소프트웨어 공학자가 하는 일이 무엇인지에 대한 정의가 바뀌지 않는 이상, 도구만 바뀔 뿐 제가 할 일은 변하지 않을 것입니다. 마부와 자동차 자동차 산업은 영국에서 시작되었지만, 지금은 아무도 영국 자동차 브랜드가 무엇이 있는지 알지 못합니다. 왜 그럴까요? 증기기관 시대로 접어든 19세기, 당시 대중교통을 담당했던 마차업계는 증기 자동차의 등장에 강력하게 반발했습니다. 마부 조합은 증기 자동차를 규제하라며 영국 의회에 청원을 끊임없이 넣었고, 증기 자동차의 경쟁 업계인 철도업계도 이에 합세했죠. 결국 영국 의회는 증기 자동차에 마차보다 10배나 높은 통행세를 물리고, 증기 자동차의 최고 속도를 제한했습니다. 심지어 '위험하다'는 이유로 붉은 깃발을 든 신호수가 차량 앞을 걸어가며 신호하도록 규제하기까지 했습니다. 이런 규제는 1800년대 후반까지 이어졌고 결국 영국 자동차산업은 쇠퇴하게 되었습니다. 관련 글 우리는 마부가 될 것인가? 자동차 앞에 빨간 깃발을 들고 걸어야 했다니 지금 보면 참 웃긴 일입니다. 한 편으로는 비슷한 신세에 놓인 개발자로서 그 당시 마부들이 느꼈을 공포감이 이해가 되기도 합니다. 그러나, 기술의 발전은 거스를 수 없는 흐름입니다. 우리가 아무리 회피하고 억제해도 결국 인간을 더 편하게 해주는 기술의 등장은 막을 수 없습니다. 자동차의 등장을 마부들이 막을 수 없었던 것처럼요. 그렇다면 주니어 개발자로서 어떤 자세를 취하는 것이 옳을까요? 1. 기술의 발전을 두려워하지 말자 기술의 발전은 두렵지 않습니다. 기술의 발전은 우리를 더 편하게 해줍니다. 우리가 하는 일을 더 쉽게 해줍니다. 우리가 하는 일을 더 재미있게 해줍니다. 1990년대에는 구글이 없었습니다. 당시의 개발자들이 정보를 얻을 수 있었던 곳은 책과 동료 개발자 뿐이었습니다. 선배님들에 비해서 지금의 우리는 얼마나 편리한 삶을 살고 있는지 깨달아야 합니다. 2. 기술에 대한 흥미를 잃지 말자 GPT가 아니더라도, 우리를 편리하게 해주는 기술은 앞으로도 계속해서 등장할 것입니다. 그런 기술들에 대한 흥미를 잃지 말아야 합니다. 흥미를 잃으면 우리는 더 이상 발전할 수 없습니다. 신기술들에 대해 호기심을 갖고, 적극적으로 배워야 합니다. 그렇지 않으면 우리는 마부가 될 수 밖에 없습니다. 3. 더 넓은 시야를 갖자 도구의 발전은 가장 작은, 단순한 작업부터 우리를 조금씩 대체하기 시작합니다. 어쩌면 2년 안에 HTML/CSS 작업을 하지 않아도 되게 될지도 모릅니다. 그러나 서비스의 흐름, 사용자의 니즈, 비즈니스의 목표 등을 이해하고 이를 기술로 구현하는 일련의 작업을 설계하고 관리하는 일을 AI가 대체하는 것은 더 먼 미래의 일이 될 것입니다. 더 좋은 아키텍처는 무엇일지, 어떻게 하면 더 큰 비즈니스 임팩트를 가져올 수 있을지 등을 고민하는 힘은 우리가 가질 수 있는 가장 강력한 무기입니다. 인간이 가진 문제를 컴퓨터로 해결하는 과정에서 내가 지금 하고 있는 일은 어떤 단계일까요? 가장 말단의 구현보다는 가장 최상위의 설계에 관심을 갖고 생각하는 힘을 기르는 것이 주니어로서 가져야 할 가장 중요한 자세라고 생각합니다. 마무리 GPT의 등장은 개발자 뿐만 아니라 거의 모든 직군의 일자리를 위협하고 있습니다. 그러나 기술의 발전을 두려워하고 억제하려고 하는 사람과, 기술의 발전을 흥미롭게 생각하고 적극적으로 배우려고 하는 사람, 과연 어느 쪽이 '마부'로 남게 될까요? '승객을 목적지에 데려다준다'는 궁극적인 목표가 다르지 않다면 우리가 타는 것이 말인지 자동차인지는 그리 중요하지 않았던게 아닐까요? 😄 ",
    "date": "2023-07-10",
    "slug": "how-should-a-dev-deal-with-gpt",
    "title": "주니어 개발자로서 GPT를 바라보는 관점"
  },
  {
    "content": "\"코드를 서로 나누고 피드백을 주고받는 공간이 있었으면 좋겠다!\"는 생각으로 Share it! 이라는 커뮤니티를 개발했는데, 어떻게 하면 더 빠른 로드 시간을 달성할 수 있을지 고민했습니다. Share it! 서비스 링크  코드를 자유롭게 나누고 리뷰와 질문을 남기는 공간이 있으면 좋겠다는 생각에 개발한 간단한 커뮤니티입니다. TypeScript, React, styled-components 등을 기술 스택으로 사용했습니다. React Helmet 모듈을 사용해 SEO도 최대한 챙겨보고자 했습니다. 백엔드는 Firebase와 Express로 개발했습니다. (댓글을 남기면 글 작성자에게 메일을 보내는 기능을 위해 Express를 사용했습니다. node-mailer 모듈을 썼습니다.) 배포는 간편하게 Vercel로 했습니다. 테스트를 해봤는데요 개발한건 좋은데, 페이지 로드가 빠르지 않다는 느낌이 들었습니다. 가장 처음 배포했던 버전 링크 성능을 객관적으로 측정해보고 어느 부분이 문제일지 확인하기 위해 Lighthouse로 검사해봤습니다. 외부의 영향을 최소화하기 위해 크롬 시크릿 모드에서 테스트를 진행했습니다.  보시다시피 성능 점수가 개선이 필요하다고 평가되는 점수대인 70점대를 기록하고 있었습니다. 보고서의 내용을 자세히 보니 이런 문제가 있었습니다.  성능 점수가 90점보다 높으면 '좋음' 평가를 받습니다. 이를 목표로 조금씩 개선해봤습니다. Time to Interactive 말 그대로 사용자가 웹페이지와 상호 작용이 가능한 시점까지 걸린 시간을 의미합니다. TTI 시간이 0.36초로 보통 수준이 나왔습니다. TTI에 특히 큰 영향을 미칠 수 있는 한 가지 개선 사항은 불필요한 JavaScript 작업을 연기하거나 제거하는 것입니다. JavaScript를 최적화할 수 있는 기회를 찾아보세요. 특히, 코드 분할로 JavaScript 페이로드를 줄이고 PRPL 패턴을 적용하는 방법을 고려하세요. 타사 JavaScript를 최적화해도 일부 사이트에서 상당한 개선이 이루어집니다. - Web.dev 상호 작용까지의 시간 내용중 발췌 이를 개선하기 위해서는 코드 분할을 활용해 JS 페이로드를 줄여야 합니다.  보고서에서도 이 방법을 추천해주고 있습니다. Lazy Loading 이를 위해 저는 React에서 제공하는 React.lazy를 사용하기로 했습니다. 리액트 18부터 정식 런칭된 기능으로, 다이나믹 import를 일반적인 컴포넌트처럼 쓸 수 있도록 해줍니다. 공식 문서에 있는 샘플 코드입니다. 이렇게 하면 해당 컴포넌트가 필요할 때가 돼서야 그 컴포넌트가 사용하는 코드를 로드하기 때문에 최초 접속 시의 로드 시간을 줄일 수 있습니다. (자세한 내용은 공식 문서의 내용을 참고해주세요.) 이를 활용해 아주 간편하게 lazy loading을 구현할 수 있었습니다. Router에서 아래처럼 사용했습니다. 개선 결과 Lazy Load 적용 후 배포 버전 링크 개선된 부분 성능 점수가 향상되었습니다. (77점 => 82점)TTI가 20% 개선되었습니다. (3.1s => 2.5s)Largest Contentful Paint 시간이 17% 감소했습니다. (3.6s => 3.0s)메인 코드의 크기가 32% 감소했습니다. (286.5KiB => 196.0KiB)Total Blocking Time이 20% 감소했습니다. (100ms => 80ms) Tradeoff 스크립트 요청 수가 1개에서 3개로 늘었습니다. 한 번에 받았던 스크립트 파일을 여러 파일로 나눠 받고 있는 것입니다. Largest Contentful Paint 개선할 점이 아직 남았습니다. Largest Contentful Paint가 3초를 기록했습니다. LCP는 Lighthouse에서 점수를 계산할 때 25%라는 큰 가중치를 주는 항목인데, 로드 시작 시점부터 페이지의 메인 콘텐츠가 로드됐을 가능성이 있을 때까지 걸린 시간을 말합니다. 즉 LCP는 사용자가 실질적으로 페이지를 사용할 수 있는 시점까지 얼마나 걸리는지를 측정하는 요소입니다. Lighthouse의 연구에 따르면 2.5초 ~ 4초는 중간 등급인 '개선 필요함'에 해당합니다. Share it!은 그럼 어떤 요소가 페이지의 로드를 방해하고 있을까요? 보고서를 보니 이 부분들이 눈에 띄었습니다.    CSS는 Render Blocking Resource입니다. Share it!은 Pretendard라는 웹 폰트를 불러와 쓰고있는데, 이 폰트의 사이즈가 너무 크기에 폰트를 로드하는 CSS의 동작 시간이 길어졌고, 이게 브라우저가 화면을 그릴(paint) 때 필요한 CSSOM의 생성을 늦춘 것입니다. 개선하려면 네트워크를 더 빠르게 만들거나, 웹 폰트의 용량을 줄여야 하는데 네트워크를 개선할 수는 없으니 폰트의 용량을 줄이는 방향으로 생각해봤습니다. 서브셋 폰트 참고할만한 네이버 D2 글 저는 Pretendard에서 제공하는 서브셋 폰트를 적용했습니다. 서브셋 폰트는 한글의 모든 글자를 담는 대신 불필요한 글자를 제거하고 사용할 글자만 남긴 폰트입니다. 영어는 26개 알파벳으로 이루어져 있다. 영문 폰트에는 대소문자를 포함해 총 72자의 글자가 필요하다. 하지만 한글은 자음, 모음의 조합으로 구성되어 있다. 모든 경우를 조합하면 한글의 글자 수는 11,172자나 된다. 그래서 한글 폰트 파일은 영문 폰트 파일보다 용량이 크다. (...중략) 불필요한 글자를 폰트에서 제거하고 사용할 글자만 남겨 둔 폰트가 서브셋 폰트다. 글자의 개수가 줄었기 때문에 서브셋 폰트는 용량이 작다. - 네이버 D2 글 중 발췌 서브셋 폰트를 불러올 때 웹 폰트를 사용하지 않고 직접 웹서버에서 서빙하는 방식으로 변경했으며, 아래의 코드를 적용했습니다. font-display 프로퍼티를 swap으로 줘서 폰트 로드가 덜 됐을때도 글자는 보이게 했으며, src 프로퍼티에 fallback 폰트로 woff를 줘 woff2를 지원하지 않는 브라우저에서도 Pretendard 폰트를 쓸 수 있도록 했습니다. 거기에 더해, local을 최우선 src로 줘서 사용자의 기기에 이미 Pretendard가 설치돼 있다면 그걸 불러오도록 했습니다. (참고로 테스트 기기에는 해당 폰트가 설치돼있지 않습니다.) 개선 결과 폰트 최적화 후 배포 버전 링크 개선된 부분 성능 점수가 90점 위로 올랐습니다. (82점 => 91점)TTI가 40% 개선되었습니다. (2.5s => 1.5s)LCP가 40% 감소했습니다. (3.0s => 1.8s)FCP가 조금 줄었습니다.Total Blocking Time이 50% 감소했습니다. (80ms => 40ms)Network Payload의 크기가 대폭 감소했습니다. (3736KiB => 1628KiB) Tradeoff 폰트를 불러오는 Request Chain에서 Maximum Critical Path Latency가 검사 할 때마다 널뛰기를 합니다. Vercel에서 제공하는 무료 웹서버의 한계인 것 같은데, 추후 CDN을 통해 배포하는 방식 등으로 개선할 필요가 있습니다. 결론 최종적으로 원하던 결과였던 90점 이상 맞기는 달성했습니다. 이후 웹 접근성 관련 문제들이나 잘못 작성된 마크업들을 수정해 아래의 결과를 얻을 수 있었습니다.  조금 더 나아가고 싶은 부분 성능과는 별개의 이야기지만, 동적으로 사용자들이 데이터를 올리는 커뮤니티 특성상 sitemap.xml을 어떻게 생성해줘야 할지 고민이 많이 됐습니다. 다른 서비스들은 이런 경우 sitemap을 어떤 식으로 생성하는지 궁금해서 찾아보니 사용자가 글을 올릴 때마다 새로운 sitemap을 생성한다고 하더라고요. 이 부분도 추후 더 개선해보고 싶습니다. ",
    "date": "2022-11-23",
    "slug": "optimize-shareit-performance",
    "title": "개인 프로젝트 Share it!의 성능 최적화하기"
  },
  {
    "content": "개발자로서 첫 커리어였던 Wavve Tech Internship을 통해 얻은 것들을 정리해봅니다. 인턴십 지난 5월 중순 10주간의 Wavve Tech Internship이 끝났습니다. 개발자로서 처음으로 현업을 경험하게 됐던 만큼 설렘을 가지고 시작했고, 끝까지 그 설렘을 잃지 않고 열심히 달렸습니다. 아쉽게도 웨이브에서 더 이어가지는 못하게 되었지만, 인턴십을 겪기 전과 비교해보면 아주 큰 성장을 할 수 있었던 시간이었습니다. 이번 글에서는 인턴십을 통해 얻은 것들을 정리해보려고 합니다. 1. 개발자가 협업하는 방법 취업을 준비하며 개인 프로젝트 위주로만 했던 제게 인턴십에서 경험한 '협업'은 정말 새로웠습니다. Jira와 Confluence, Slack을 제대로 협업에 활용해본건 처음이었기에 조금 헤매기도 했죠. 덕분에 개발자가 협업하는 방법을 진지하게 고민하게 되었습니다. 인턴십 전에는 문서화를 최소화하고 코딩에 온전히 시간을 쏟는 것이 좋다고 생각했는데, 같이 일할 때는 좋은 문서 하나가 불필요한 커뮤니케이션 비용을 비약적으로 줄일 수 있다는걸 깨달았습니다. 또한, 테크스펙 작성이 결국 내 목표와 구체적인 방법을 고민하는 과정이었기에 더 나은 방향을 찾을 수 있었고, 오히려 더 빠르게 개발할 수 있었습니다. 테스트 코드가 가지는 의미도 다시 한번 생각해보게 되었습니다. 테스트 코드는 내가 작성한 코드가 정상적으로 동작하는지를 검증하기 위한 것이 아니라, 동료에게 내 코드의 동작을 설명하는 '문서'라고 생각하고 접근했을 때 더 의미가 있었습니다. 같이 일할 때 가장 중요했던건 팀원과 내가 같은 방향을 바라보고 있다는 것을 끊임없이 확인하고 믿을 수 있어야 한다는 것이었습니다. 애자일 방법론을 가지고 개발하는 조직에서는 끊임없이 목표를 정하고 구현하는 과정을 반복하기 때문에, 팀원들과의 효율적이고 효과적인 의사소통이 필수적이었습니다. 웨이브는 일하는 방식 2.0이라는 이름으로 이제 막 애자일 방법론을 도입하기 시작한 곳이었습니다. 덕분에 100여 명 남짓 되는 거대한 개발 조직이 어떻게 애자일하게 일하는 방법을 그려가는지를 맛보는 특별한 경험을 할 수 있기도 했었습니다. 2. Done is Better than Perfect 웨이브 인턴십이 끝나고 제가 따로 요청드려 받은 피드백은 이런 내용이었습니다. 개발 능력이 뛰어나고 가진 지식을 나누는 것을 잘 하며, 구조를 분석하거나 개선하려는 의지가 강하다. 그러나 업무의 핵심에서 벗어날 때가 있다. 저는 주어진 목표까지 도달하는 과정에서 조금이라도 더 나은 방법이 보인다면 적극적으로 도입하는 '버릇'을 가지고 있습니다. 이런 버릇은 개발자로서 좋은 점이기도 하지만, 나쁜 점이기도 했습니다. 완벽한 코드를 작성하려고 끊임없이 고민하다보면, 결국 목표를 달성하지 못하고 시간만 낭비하게 되는 경우가 많았습니다. 물론 그 과정에서 얻게 된 인사이트는 값졌고, 더 나은 코드를 작성할 수도 있었지만, 같은 시간이 주어졌을 때 결과물의 양적 측면에서 떨어지게 된다는건 분명한 사실이었습니다. Done is Better than Perfect. 페이스북 COO인 셰릴 샌드버그가 언급한 말이라고 하던데, 이 말이 뜻하는 바가 무엇인지 알게 됐습니다. 우리의 고객인 '회사'에 비즈니스 임팩트를 가져다 줄 수 있는 방법은 우선 동작하는 프로덕트를 만들어 내고, 그 후에 더 나은 코드로 리팩토링 해나가는 것이었습니다. 또한, 아직 생기지 않은 문제를 대비한 코드를 작성하는 것이 항상 좋은것만은 아니란 점을 깨달았습니다. 코드의 유지보수성이나 확장성을 고려해 작성하는 것은 좋은 습관이지만, 그것이 불필요한 과정이 되어버리면 오히려 개발 속도를 늦추는 요인이 될 수 있었습니다. 3. 팀 플레이어 '코드를 왜 이렇게 작성했는지'에 대한 가장 좋은 대답은 '팀원을 위해서'에요. 기술 멘토님께서 해주신 가장 기억에 남는 말입니다. 인턴십 기간동안의 제 경험을 예로 한번 들어보겠습니다. 서버와의 통신을 우리는 vue-query(react-query와 같음)로 핸들링하고 있었는데, 제가 맡은 '현재 시청자 수 표시' 파트를 개발하면서 에러를 어떻게 처리할 것인지에 대한 고민이 들었습니다. 이를 해결하기 위해 Suspense를 활용한 QuerySuspense라는 컴포넌트를 설계하고 팀에 제안했습니다. QuerySuspense는 experimental 기능이었으나, 제가 판단하기에 이미 충분히 안정화된 기능이었습니다. 그러나, 여기에는 두가지 문제가 있었습니다. 목표한 바(현재 시청자 수 표시)와 크게 관련이 없는 기능이다.내가 직접 테스트해본 적이 없기 때문에 사용했을 때 어떤 이슈가 발생할 지 알 수 없다. 1번은 앞서 언급한 류의 문제였고, 어떻게 보면 그렇지 않다고 할수도 있는 부분입니다. 그러나 2번은 곰곰히 생각해 보면 심각한 문제였습니다. 제가 제안한 기술을 과연 우리 팀도 충분히 이해하고 있을까요? 그리고, 이 기술을 사용했을 때 발생할 수 있는 이슈를 충분히 예측할 수 있을까요? 이런 의문을 가지고 팀원들과 함께 논의를 거쳤고, 결국 QuerySuspense를 사용하지 않기로 했습니다. 무언가 새로운 기술을 사용한다면, 제가 먼저 테스트를 해보고 도입해도 되겠다는 확신을 가졌을 때 팀에 제시해야 한다는 것을 배울 수 있었던 경험입니다. 그렇지 않다면 혼자 해도 되었을 트러블슈팅을 모두가 하게 될 것이고, 결국 팀 전체에 피해를 가져오고 말게 될겁니다. 방어적 프로그래밍 방어적 프로그래밍(Defensive programming)이라는 용어가 있습니다. (위키피디아) 방어적 프로그래밍은 팀 플레이어로서 중요시해야 하는 가치중 하나입니다. 내가 작성한 코드는 팀원이 이해하기 쉬워야 하며, 예상치 못한 경우에도 예상 가능한 동작을 해야 합니다. 시니어님의 코드를 보며 감탄했던 부분은 바로 이런 요소들이었습니다. 환경 변수를 로드하는 아주 간단한 코드조차도 시니어님은 항상 방어적으로 작성하셨습니다. 위의 두 코드는 같은 동작을 합니다. 그러나, 두번째 코드는 process.env.API_KEY가 undefined일 경우를 대비해 기본값을 설정해주는 방어적인 코드입니다. 사실 이렇게 하면 코드에 기본 API KEY가 하드코딩되는 문제가 있습니다. 그러나, 사내에서만 사용하는 코드라는 점을 고려하면 이는 큰 문제가 아닙니다. 이렇게 하면 .env를 준비하지 못한 경우에도 코드의 정상 동작을 보장할 수 있다는 장점이 있습니다. 즉, 환경 변수를 로드하는 것 하나 조차 팀원의 실수를 방지하는 코드를 작성하셨던 것입니다. 코드를 무작정 분리하는 것이 능사는 아니다. 관련이 있는 코드는 묶고, 그렇지 않은 코드는 분리하면 코드의 가독성과 유지보수성은 높아집니다. 그러나, 아무 생각 없이 이를 적용하다 보면 오히려 더 복잡하고 이해하기 어려운 코드가 되기 쉽상입니다. 예를 들어, 타입 선언을 코드와 분리하는 것은 신중하게 고려 후 적용해야 합니다. 아래와 같은 코드가 있다고 가정해보겠습니다. 아마 옛날의 저였다면 StringToIntegerOptions 타입을 앱의 루트에 위치한 types 디렉터리에 넣으려고 했을겁니다. util-options.ts라는 파일명을 지어주고 '아 나는 코드를 분리했어!' 하며 만족해했겠죠. 그러나, 이렇게 하면 코드의 가독성이 떨어집니다. stringToInteger 함수를 사용하는 개발자는 StringToIntegerOptions 타입을 사용하기 위해 util-options.ts 파일을 찾아봐야 합니다. 이렇게 되면 코드를 이해하는데 더 많은 시간이 소요됩니다. 코드를 분리해 오히려 이해하기 어렵게 만들어버린 것입니다. 항상 '내 코드를 팀원이 읽는다면 어떤 느낌일까?'를 고민하며 개발하는 것이 중요합니다. 이번 인턴십을 거치며 제가 얻은 멋진 인사이트 중 하나입니다. 마치며 콘텐츠웨이브 테크 인턴십은 제게 많은 것을 느끼게 해줬습니다. 팀원들과 함께 일하며 배운 것들이 많았고, 무엇보다도 개발자로서 앞으로 내가 어떤 것에 집중해야 하는지에 대한 방향성을 얻을 수 있었습니다. 주어진 과제를 해결하기 위해 긴 시간 토론하고, 리뷰할 수 있었던 것도 정말 좋았습니다. 물론 야근은 피할 수 없었지만ㅋㅋㅋ 그래도 후회 없는 경험이었습니다😄 제가 개발자가 되기로 한 이유는 세상의 문제를 내 힘으로 풀어낼 수 있는 능력을 가지는 것에 대해 매력을 느꼈기 때문입니다. 다 같이 힘을 합쳐 문제를 해결해야 한다면 제 개인이 아닌 팀의 입장에서 문제를 바라봐야 한다는 점을 절대 잊지 말아야겠습니다. 웨이브 카페테리아에서 보이는 여의도 빌딩 뷰 멋지더라구요ㅋㅋ 멀리 한강도 살짝 보임 ",
    "date": "2023-06-29",
    "slug": "internship-retro",
    "title": "내가 인턴십을 통해 얻은 것"
  },
  {
    "content": "콘텐츠웨이브에서 개발자로서 첫 발을 내딛게 됐습니다!! 인턴 합격을 기념하며 짧은 취준기를 회고해 봤습니다. 짧은 취준기 지난 1월 초 멋사 프론트엔드스쿨 부트캠프를 마치고 본격적인 취준이 시작됐습니다. 사실 부트캠프 수료 한 달 전부터 여러 기업에 지원하고 있었는데 타율이 좋지는 않았습니다. 두달간 약 40여 곳에 지원했고 서류합격을 한 곳은 5곳 정도였습니다. 하ㅏㅎ 그 와중에 저를 슬프게 했던 이런 경우도 있었죠.  서류는 합격했는데 코테에서 자꾸 미끄러진 인턴 도전들입니다. 특히 두 번째 경우는 분명 좋은 점수를 받았는데도 떨어져서 너무 아쉬웠어요. 이런 일들이 있었어요 (기적같이) 토스 1 ~ 3년 차 직무 코테를 붙어서 과제 전형을 보는 경험이 경험이 자신감을 줌과 동시에 나 자신에 대한 기대감을 지나치게 불어넣었다는 생각이 드네요. 항상 겸손하자...ㅠㅠ프로그래머스에서 진행된 데브매칭, Spring Coding(인턴 프로그램) 진행총 15곳 지원, 코테와 과제는 통과했지만 한 곳 제외 모두 장렬히 전사그룹바이 First100 프로그램 참여해서 스카웃 제안받기(를 원했으나 아무도 안 해주셨음)슥삭 슈퍼패스 통과해서 면접 제안 기다리기 (물론 아무도 연락 안 옴)로켓펀치 취준컴퍼니 2기 합격해서 현직자분들과의 커피챗. 무료로 집무실 쓸 수 있는 게 정말 좋았어요.멋사에서 만난 분들과 면접 스터디하기멋사에서 창업하신 팀에 프론트엔드 개발 직무 지원하기2차 기술면접에서 탈락했습니다. 아무래도 기업 규모가 작다 보니 저를 유일한 프론트엔드 개발자로 두어야 했는데, 조금 무리가 있지 않을까라는 뉘앙스로 말씀을 드렸었어요. 그런 모습이 자신감이 떨어지는 지원자로 비치게 만들었던 것 같아요.현직 시니어 프론트 개발자님께 이력서 피드백받기프론트엔드 개발에 깊이를 더하기 위한 노력이 보이지 않는다는 마음 아픈 피드백을 받았어요 🥲 흐헝 누구보다 진심인데ㅠ피드백 주신걸 참고해서 프론트 중심으로 내용이 강조되도록 이력서를 갈아엎고 있었어요. 이 경험이 자신감을 줌과 동시에 나 자신에 대한 기대감을 지나치게 불어넣었다는 생각이 드네요. 항상 겸손하자...ㅠㅠ 총 15곳 지원, 코테와 과제는 통과했지만 한 곳 제외 모두 장렬히 전사 2차 기술면접에서 탈락했습니다. 아무래도 기업 규모가 작다 보니 저를 유일한 프론트엔드 개발자로 두어야 했는데, 조금 무리가 있지 않을까라는 뉘앙스로 말씀을 드렸었어요. 그런 모습이 자신감이 떨어지는 지원자로 비치게 만들었던 것 같아요. 프론트엔드 개발에 깊이를 더하기 위한 노력이 보이지 않는다는 마음 아픈 피드백을 받았어요 🥲 흐헝 누구보다 진심인데ㅠ피드백 주신걸 참고해서 프론트 중심으로 내용이 강조되도록 이력서를 갈아엎고 있었어요. 이후 웨이브 인터뷰 과정과 동시에 한 스타트업의 면접도 진행했어요. 블록체인 서비스를 개발하는 기업이라 web3.js 라이브러리 관련 이야기를 할 수 있어서 참 즐거웠습니다. 이후 감사하게도 과제전형 안내를 받았지만 Wavve Tech Internship에 합격해서 더 이어가지 않기로 했습니다. 취준과 관련 없는 일들도 했죠 GDSC UOS에서 타입스크립트 스터디이펙티브 타입스크립트로 진행하고 있는데 너무너무 재밌어요ㅋㅋChatGPT에 빠지기ChatGPT를 잘 쓰는 방법을 더 깊게 파보고 싶어서 관련 커뮤니티에 들어갔어요.이걸 활용한 서비스를 빨리 만들어보고 싶어서 (취준 때문에 떠오른 아이디어인) 이력서 기반 면접 예상 질문 생성기를 개발했어요. (쓸만하니까 한번 구경 와주세요ㅎㅎ) 생각보다 좋은 반응을 얻어서 제 레포들 중에 처음으로 Star 16개 이상을 받았어요.리액트 컴포넌트 라이브러리 개발제가 좋아하는 개발자님을 따라 Storybook 공부용으로 개발하기 시작했던 건데 지금은 제 토이 프로젝트들에서 쓸만했던 컴포넌트들을 모으고 있어요.디자인 시스템이란 게 얼마나 설계하기 까다로운 건지 깨달았어요...ㅋㅋ처음으로 Rollup으로 라이브러리를 번들링 하고 배포해 봤어요. 많은 분들이 사용하시는 라이브러리를 개발하고 싶다는 목표가 생겼어요.GDSC UOS Branding 팀프로젝트Storybook을 활용한 문서화 및 컴포넌트 스타일 정제를 담당하고 있습니다.추후 로그인 로직 개발이 완료되면 로그인 부분도 맡게 될 것 같아요.GDSC UOS FE 2월 테크톡 진행다양한 CSS 처리 방식(ex: styled-components, Sass, Tailwind, ...)에 대해 이야기 나눴습니다.멋사 팀프로젝트 마무리, 멋사 FE 3기 톡방 열기TDD 공부하고 관련 포스팅 작성하기 이펙티브 타입스크립트로 진행하고 있는데 너무너무 재밌어요ㅋㅋ ChatGPT를 잘 쓰는 방법을 더 깊게 파보고 싶어서 관련 커뮤니티에 들어갔어요.이걸 활용한 서비스를 빨리 만들어보고 싶어서 (취준 때문에 떠오른 아이디어인) 이력서 기반 면접 예상 질문 생성기를 개발했어요. (쓸만하니까 한번 구경 와주세요ㅎㅎ) 생각보다 좋은 반응을 얻어서 제 레포들 중에 처음으로 Star 16개 이상을 받았어요. 제가 좋아하는 개발자님을 따라 Storybook 공부용으로 개발하기 시작했던 건데 지금은 제 토이 프로젝트들에서 쓸만했던 컴포넌트들을 모으고 있어요.디자인 시스템이란 게 얼마나 설계하기 까다로운 건지 깨달았어요...ㅋㅋ처음으로 Rollup으로 라이브러리를 번들링 하고 배포해 봤어요. 많은 분들이 사용하시는 라이브러리를 개발하고 싶다는 목표가 생겼어요. Storybook을 활용한 문서화 및 컴포넌트 스타일 정제를 담당하고 있습니다.추후 로그인 로직 개발이 완료되면 로그인 부분도 맡게 될 것 같아요. 다양한 CSS 처리 방식(ex: styled-components, Sass, Tailwind, ...)에 대해 이야기 나눴습니다. 웨이브 인턴 채용 과정  1월 말, 2023 Wavve Tech Internship 공고를 보고 Web Developer 직무에 지원했습니다. 다른 분께서 지원하신다길래 저도 관심을 갖고 찾아보게 됐는데, Wavve의 밝고 활기찬 개발 문화가 느껴지는 글을 보고 꼭 가고 싶다는 생각이 들었어요. 특히 애자일 방법론을 이제 막 도입하며 여러 시행착오를 겪고 이를 공유하는 모습이, 겉보기식의 개발 문화가 아닌 실질적인 시스템을 만들어가고자 하는 의지가 느껴져서 정말 좋았습니다. Web Developer, Backend, AOS/iOS 부분에서 각각 인턴을 모집했고, 저는 Web Developer 직무로 지원했습니다. 서류 합격 후 코딩 테스트 감사하게도 서류에 통과해 코딩 테스트를 봤습니다. 테스트는 프로그래머스를 통해 시행됐습니다. 사방을 찍어 보내고, 웹캠을 켜두고, 휴대폰 카메라도 마이크 포함 켜두는 등 매우 엄중하게 진행됐죠. 문제 난이도도 엄중했습니다. 저는 JS로 응시했는데 4문제 120분이 주어졌고, 2솔 후 한 문제에 매달리다가 미완성 부분에 대한 설명을 주석으로 달고 시험이 종료됐어요. 이때까지만 해도 또 코테에서 탈락하겠다..ㅠ라는 생각으로 마음을 비우고 있었습니다. 인터뷰 준비하기 코테 종료 며칠 후 메일이 왔는데, 인터뷰 과정을 안내해 주시는 내용이었습니다. 정말 기쁘기도 하면서 며칠 남지 않은 면접에 손에 땀이 났던 순간이에요. (그 와중에 다른 기업에서도 면접이 잡혀서 두배로 떨렸어요ㅋㅋ) 기술적인 부분은 인턴이기에 깊은 내용보다 기본기를 물어보실 거라는 생각이 들었고, 인터넷에 흔히 돌아다니는 FE 기술면접 대비 자료들을 쭉 훑어보면서 기억을 되살렸어요. 이력서를 기반으로 많은 질문을 해주시리라 믿고 면접 질문 생성기를 만들어서 면접을 준비했는데, 지금 와서 생각해 보면 이렇게 입을 푸는 연습을 했던 게 큰 도움이 됐습니다. 인터뷰 대면으로 보는 면접은 처음이었는데 엄청 떨렸습니다. 로드뷰로 미리 건물을 보고 갔지만 직접 눈으로 보니 정말 멋있었고, 덕분에 긴장은 배가 됐죠... 우황청심원을 미리 마시고 갔는데 아무 효과 없더라고요. 면접은 1대 4로 진행됐고, 모두 프론트 개발자분들이셨습니다. 자기소개를 하는데 제 떨림이 목소리로 그대로 전달돼서 면접관님께서 떨지 말라고 말씀해 주실정도였지만 이후 기술 얘기가 시작되며 마음이 편해졌습니다. 덕분에 TMT 모드로 말하고 싶었던 건 마음껏 말씀드리고 왔어요. 개발을 정말 좋아한다는 점을 최대한 어필하려고 노력했어요. 다행히 예상했던 대로 기술적인 부분에서 딥한 질문은 없었고, 이력서 위주의 면접이 진행됐습니다. 왜 개발자가 되고 싶은가처럼 개발에 대한 제 열정을 확인하는 물음들과, 왜 웨이브에 지원했는가같이 웨이브에 대해 진심인지를 확인하는 질문들도 이어졌어요. 나중에 집에 와서 면접을 복기해 봤는데, \"왜 이렇게 대답했을까?\" 하는 이불킥 모먼트들이 자꾸 떠오르더라고요...ㅜㅜ 그렇게 일주일을 메일함만 쳐다보며 지냈습니다. 최종합격  그리고 합격했습니다 🎉🎉 마무리 이제 월요일부터 10주간의 인턴이 시작됩니다. 제 첫 커리어를 이렇게 좋은 기회로 시작할 수 있게 돼 정말 기뻐요!! 두 달이라는 짧은 취준 후 인턴을 하게 됐는데, 인턴이 끝나면 다시 취준생이 될지 웨이브에 정직원으로 당당하게 다니게 될지는 모르겠지만 이렇게 멋진 곳에서 개발자로 활동할 수 있다는 것 자체가 행복하네요 😁 열심히 불태우고 오겠습니다 🔥 ",
    "date": "2023-03-03",
    "slug": "contentwave-intern-job-hunt",
    "title": "콘텐츠웨이브 Web Developer 인턴 합격하기까지 짧은 취준기 회고"
  },
  {
    "content": "CSS 기본기를 다지는 시간을 가졌습니다! 목표  오늘은 이런 페이지를 만들어보며 마크업의 기초를 다져보겠습니다. HTML, CSS를 짜기 전에 Remind 코딩을 할 때는 작은 조각들을 만들어 합쳐나가지만, 마크업을 짤 때는 꼭 큰 덩어리부터 만들어야 합니다. CSS 기본 initial value, User Agent Stylesheet 모든 CSS Property에는 지정하지 않아도 주어지는 디폴트 값이 있습니다. 이런 값을 initial value라고 합니다.  User Agent Stylesheet라고 브라우저에서 정한 기본값도 있습니다. 이건 initial value와는 다릅니다.  여기에서 'wow'를 컨텐츠로 가지고 있는 div는 User Agent Stylesheet에서 정한 body의 margin: 8px;에 영향을 받고 있는 것을 볼 수 있습니다. 각 브라우저의 User Agent Stylesheet 크롬 기본 제공 스타일파이어폭스 기본 제공 스타일 브라우저에서 제공하는 User Agent Stylesheet는 개발자가 의도하지 않은 결과를 낳을 위험이 있으므로 reset하는 과정이 필요합니다. margin: initial같이 initial 키워드를 사용하면 property에 따른 initial value가 들어가고, 또는 임의로 값을 부여해도 됩니다. height, width height와 width의 initial value는 auto입니다. 그럼 width: auto;와 width: 100%;는 어떻게 다를까요? 다음 예시를 보겠습니다.  즉, width: auto;는 브라우저가 계산한 자식(자신)의 margin, padding, border등을 고려해 유연하게 부모가 제공하는 최대 컨텐츠 영역 너비만큼을 줍니다. 반면, width: 100%;는 부모가 제공하는 최대 컨텐츠 영역을 가져오고, 거기에 마진을 더합니다. 더 자세한 내용은 여기에 정말 잘 설명돼 있습니다. height: auto;는 자식(자신)이 가지는 컨텐츠 높이만큼 유연하게 가져갑니다. 부모를 기준으로 정하는 width와는 달리 자식(자신)을 기준으로 한다는 점이 포인트입니다. box-sizing 요소의 사이즈를 결정하는 방법을 정하는 프로퍼티입니다. initial value는 content-box입니다. value를 border-box로 바꾸면 어떻게 달라지는지 아래의 예시를 보겠습니다.  즉, content-box는 컨텐츠의 크기를 width와 height로 정한 후 거기에 padding과 border를 더해 박스의 크기를 결정하고, border-box는 padding과 border를 포함한 크기가 width와 height가 되도록 컨텐츠 영역을 유연하게 조정합니다. Block-level elements MDN 문서 Block-level elements는 일단 한 줄을 확보하고, 요소의 크기만큼 차지하도록 한 후, 나머지는 잉여공간으로 둡니다. 아래의 예시로 확인하겠습니다.  여기에서 각 div들은 Block-level elements이므로 한 줄이 주어집니다. margin으로 auto를 주면 브라우저가 계산 후 가용한 잉여공간을 최대로 채울 수 있는 값이 부여됩니다. margin이 주어지지 않은 default div는 왜 왼쪽에 있는걸까요? <html> 요소의 attribute로 lang='ko'가 주어져 있으므로, Global attribute로 dir=\"ltr\"(left to right)이 부여돼있기 때문입니다. div가 Block-level elements인 이유는 User Agent Stylesheet에서 display: block;을 부여하고 있기 때문입니다. 대표적인 Block-level elements로는 <div>, <ul>, <li>, <h1> ~ <h6>, <p> 등이 있습니다. 단축 속성, shorthand property 위 예시에서 margin: 0 auto;, margin: auto;처럼 쓰는 방식을 shorthand property라고 부릅니다. 시계방향으로 값을 부여할 수 있으며, 두개만 적으면 위아래-좌우, 하나만 적으면 모든 방향으로 값이 들어갑니다. 이 때, 두 방법 모두 요소가 가운데로 정렬되는 이유는 위아래 잉여 영역은 0이므로 모든 방향으로 auto를 넣어도 위 아래로의 margin은 0이 들어가기 때문입니다. CSS Selector MDN 문서 Id Selector는 체계적으로 스타일을 관리하는 데에는 좋지 않은 방법이므로 보통 사용하지 않습니다. combinator는 \" \"(space), >, ~, + 등이 있는데 아래와 같이 사용합니다. 참고로 브라우저의 CSS Parser는 Selector의 맨 오른쪽부터 체크합니다. 이를 고려해서 적절한 Selector를 입력해야 합니다. text-align: center;  이런 HTML이 있다고 하면, div.header 안의 요소들을 가운데 정렬하는 방법은 어떤게 있을까요? div.header를 가운데 정렬했듯 margin: auto;를 이용하면 될까요? Inline elements MDN 문서 Block-level elements와 달리 Inline elements는 컨텐츠의 흐름을 바꾸지 않고, 요소를 정의하는 태그로 감싼 공간만 차지하는 요소입니다. 위 예시에서 <h1>과 <p>는 모두 Block-level elements이고, <img>와 <h1>, <p>로 감싸여있는 텍스트(=텍스트 노드)들은 Inline elements입니다. 이 때는 text-align: center;를 부모에 줘서 자식에 있는 Inline elements들을 가운데 정렬할 수 있습니다.  <h1>과 <p>에 background-color를 줘보면 왜 이렇게 되는건지 확실히 보입니다.  <div>, <h1> ~ <h6> 등은 '컨테이너'일 뿐이고, 그 안에 컨텐츠로 들어간 텍스트는 Inline elements라는 점을 헷갈리면 안됩니다. inline의 padding, margin Inline elements의 padding, margin property는 조금 신기하게 작동합니다.  이렇듯 Inline elements는 baseline을 기준으로 움직이는 요소들입니다. 따라서 baseline과 같은 방향이라면 margin이나 padding이 공간을 차지하고, 다른 방향이라면 생기긴 하는데 공간을 차지하진 않습니다. Inline elements는 컨테이너의 개념이 아니기 때문에 width나 height가 없습니다. 지정해줘도 작동 안합니다. 마크업 개행  HTML은 마크업을 할 때 개행한 경우 구분되는 요소로 생각하고 약간의 공백을 자동으로 부여합니다. 이 공백의 사이즈는 font-size에 따라 달라집니다. 이런식으로 우리의 편의를 위해 주는 기능을 쓰는건 좋지만, HTML로 스타일을 주는건 왠만하면 피해야 합니다. 상속 inheritance 앞선 예시에서 부모 요소에 준 text-align: center;가 자식 요소인 <h1>이나 <p>에도 전해진 이유는 property의 value가 상속됐기 때문입니다. 이렇게 상속이 되는 property와 그렇지 않은 property들이 있습니다. 상속이 되는 property는 대표적으로 text-align, color, font-size 등이 있는데... 이건 외울필요는 없고 상속이 되는게 합리적인 property인지 아닌지 생각해보면 됩니다. MDN 문서에서 검색해봐도 되고, 아니면 부딪혀보면 되죠... 상속받은 property의 value보다는 자식에서 지정된 value가 더 우선시됩니다. 상속은 하위 요소 모두에게 전파되며, inherit 키워드를 사용하면 background-color처럼 상속이 안되는 property도 억지로 상속받을수도 있습니다. inherited properties의 초기화 font-size는 상속을 지원하는 property입니다. 이런 property에 값을 지정해버리면 더이상 상속이 작동하지 않게 됩니다. 따라서 상속이 가능한 property는 inherit으로 초기화 해주는 것이 올바른 방법입니다. display property MDN 문서 Block-level elements를 inline화 하거나, Inline elements를 Block-level화 하는 등이 필요할 때 사용하는 property입니다.  원래 <a> 요소는 Inline elements이므로 padding이나 border property가 baseline이 아닌 위 아래 방향으로 영향을 줄 수 없습니다. 그러나 display: inline-block;을 부여해서 Inline elements임에도 Block-level elements처럼 작용되도록 만들었습니다. Margin Collapsing, 마진 병합현상  .child 코드를 보면 margin: 10px;를 줬으므로 A와 B 사이에는 20px의 마진이 생겨야 하나, 10px이 들어간 것을 볼 수 있습니다. 또한 A의 위와 B아래에도 각각 10px씩 공간이 있어야 하는데, 그 공간 없이 H모양이 돼버렸습니다. 이건 Margin Collapsing이 일어났기 때문입니다. 원래는 예쁜 디자인을 위해 의도된 현상입니다. 하지만 Margin Collapsing을 의도하지 않았을 경우를 대비해 어떤 조건에서 이 현상이 어떻게 발생하는지 알아둘 필요가 있습니다. Margin Collapse가 일어나는 정확한 조건이나 그 해결 방법은 생각보다 딥한 내용인 것 같아서, 추후 다른 포스팅으로 자세히 정리하겠습니다. 우선은 그 존재를 짚고 넘어가겠습니다. Selector Specificity 아래의 경우에는 어떻게 스타일이 적용될까요?  원래 style은 가장 마지막에 나온 코드가 적용됩니다. 그러나, 이 경우 더 구체적으로 선택했다고 평가되는 .text의 스타일이 적용됩니다. 이런 구체성을 Selector Specificity라고 부릅니다. 비슷한 예제로는 아래와 같은 상황이 있습니다. 같은 HTML에 아래의 CSS를 적용해보겠습니다.  .text와 .text.text가 차이가 없으므로 background-color: orange;가 적용될 것 같지만, 재밌게도 .text.text쪽의 스타일이 적용됩니다. VSC에서는 Selector 위에 마우스를 올리면 Specificity를 확인할 수 있습니다. CSS는 이렇게 내부적으로 Selector의 중요도를 평가해 일종의 '계단'을 만들어 스타일을 적용합니다. 이런 모습이 마치 폭포수같다고 해서 Cascading Style Sheet, CSS라는 이름을 가지게 된겁니다. 목표 페이지 개발 위 내용을 가지고 아래의 페이지를 완성했습니다.  링크 Codes HTMLCSS ",
    "date": "2022-09-02",
    "slug": "review-css-basics",
    "title": "CSS 기본 다지기"
  },
  {
    "content": "Context API와 전역 상태 관리 라이브러리에 대해 고찰해보고 직접 구현해봅니다. 리액트 상태 관리에 사용되는 여러 방법 리액트를 상태 관리에 사용할 수 있는 방법은 크게 두가지가 있습니다. state, props, Context API 등의 internal store를 사용하는 방법Redux, MobX 등의 external store를 사용하는 방법 전역 상태 관리가 필요한 경우, 외부 라이브러리의 도움을 받지 않으려고 한다면 Context API가 거의 유일한 방법입니다. 그러나, Context API는 전역 상태 관리에 그냥 사용하기엔 아쉬운 점이 많습니다. 전역 상태 관리에 Context API를 사용하기 까다로운 이유 Context API는 상태 관리를 위한 기능이라기 보다는 의존성 주입을 위한 API지만, 외부 라이브러리의 도움 없이 간단하게 지역적인 상태 관리를 구현하기에 좋은 도구입니다. 위와 같이 Context Provider로 감싸진 컴포넌트는 Context를 통해 상태를 사용할 수 있습니다. 다만, Context API는 '잘 사용하려면' 약간 까다롭습니다. 위의 UserContextProvider에서 value 객체는 매 렌더링마다 새로 생성됩니다. Context Provider는 얕은 비교만 수행하기 때문에 해당 컨텍스트의 값이 바뀌지 않았더라도 컨텍스트를 참조하는 모든 컴포넌트가 리렌더링 됩니다. 따라서 UserContextProvider의 부모 컴포넌트가 리렌더링되면 관련 없는 컴포넌트의 불필요한 리렌더링이 발생할 수 있습니다. 이러한 이유로, Context Provider에 전달되는 값이 원시값이 아니라면 React.useMemo를 사용해 값을 캐싱하는 것이 좋습니다. 또는 React.memo를 써서 Context Provider 자체의 리렌더링을 막는것도 방법입니다. 그러나 문제는 여기서 끝나지 않습니다. 앞서 언급한대로 Context API는 컨텍스트의 값이 바뀌면 해당 컨텍스트를 참조하는 모든 컴포넌트를 리렌더링 합니다. 그래서 컨텍스트의 값 중 일부 프로퍼티만을 사용하는 경우 그 프로퍼티의 값이 바뀌지 않아도 리렌더링은 피할 수 없습니다. 위 컴포넌트는 UserContext에서 주는 값 중 name만을 사용하고 있음에도 불구하고, age만 변경되어도 리렌더링 됩니다. 따라서, Context API에 값이 바뀔 수 있는 object value를 사용할 경우 최대한 컨텍스트를 쪼개써야 합니다. 극단적으로 가면 이렇게도 쪼갤 수 있겠죠. 더 가면 원시값 자체만을 컨텍스트 값으로 쓸 수도 있을거고요. 불필요한 리렌더링은 피할 수 있게 됐지만 너무 많은 컨텍스트가 생성돼 복잡도가 올라가고 관리하기 어려워졌습니다. 이렇게 Context API만을 사용하여 '전역' 상태를 관리하는 데는 여러 제약이 있습니다. 그래서 대부분의 프로젝트는 Recoil이나 Redux, zustand 등의 외부 라이브러리를 사용합니다. 제 생각에 Context API는 이름 그대로 어떤 컴포넌트가 참조할 수 있는 컨텍스트라고 접근하는게 좋을 것 같습니다. 특정 상태나 값이 어떤 스코프로 제한되면서도, 그 스코프 안에서는 자유롭게 사용할 수 있는 값이라고 생각합니다. 해당 컴포넌트가 필요로 하는 의존성을 모아둘 수 있으므로 코드의 가독성이나 테스트 용이성을 높여주는 도구이기도 합니다. 전역 상태 관리 라이브러리를 직접 만들어보자 저는 항상 전역 상태 관리 라이브러리가 대체 어떻게 동작하는걸까 궁금했습니다. 그래서 이번 기회에 전역 상태 관리 라이브러리를 직접 구현해보면서 그 동작 원리를 이해하고자 했습니다. Recoil의 API와 코드를 참고했으며, 실제 동작 원리는 조금 다를 수 있습니다. 이름은 very-simple-store입니다. 구경하기 이하의 내용은 실제 구현된 코드를 설명을 위해 단순화한 것입니다. 제가 이해한 만큼만을 가지고 개발한 라이브러리입니다. 혹시 잘못된 부분이 있다면 알려주시면 감사하겠습니다. 전역 상태를 어디에 어떻게 담고 관리할 것인가 전역 상태는 온전히 라이브러리에 의해서만 관리될 수 있어야 하므로, useRef를 사용해 리액트 외부에 위치하도록 합니다. 이 객체를 store라고 부르겠습니다. 이 store는 Context API를 통해 리액트 컴포넌트들이 공유할 수 있도록 합니다. 앱의 루트에 StoreRoot를 감싸주면 이 앱 어디에서든 접근할 수 있는 전역 상태가 준비됩니다. 전역 상태가 바뀔 때 컴포넌트를 어떻게 리렌더링할 것인가 전역 상태가 바뀌면 그 상태를 사용하는 컴포넌트만을 리렌더링 해야합니다. 이를 위해서는 두 가지가 필요합니다. 특정 전역 상태에 '구독'하는 기능특정 전역 상태가 바뀌었을 때 '구독'한 컴포넌트를 리렌더링하는 기능 특정 전역 상태에 '구독'하는 기능 very-simple-store에서는 각각의 전역 상태를 하나의 노드로 보고, StoreNode라는 이름을 붙였습니다. 구독하는 컴포넌트를 관리하기 위해 이런 프로퍼티들을 가지도록 했습니다. 이제 StoreNode를 생성하는 함수인 addStoreNode를 만들어봅시다. 이렇게 하면 아래와 같이 간편한 API가 완성됩니다. 특정 전역 상태가 바뀌었을 때 '구독'한 컴포넌트를 리렌더링하는 기능 리액트에서 리렌더링을 트리거하는 가장 간단한 방법은 setState를 호출하는 것입니다. 저는 제가 원하는 타이밍에 리렌더링을 일으키고자 하는 것이므로, 강제로 가짜 setState를 호출하는 Hook을 만들었습니다. 대부분의 라이브러리는 사실 리액트에서 제공하는 useSyncExternalStore 훅을 사용하고 있습니다. 여기에서는 데이터 흐름을 직접 제어하며 원리를 이해하기 위해 강제로 리렌더링을 일으키는 훅을 사용합니다. 이제 저 훅을 사용해 StoreNode의 값을 사용하도록 도와주는 useStoreNodeGetter를 만들어봅시다. forceUpdate가 실행되는 순간 이 Hook을 사용중인 컴포넌트는 리렌더링 됩니다. 19번째 줄에서 리턴되는 값은 리렌더링마다 다시 평가되므로 자연스럽게 최신 상태를 가져올 수 있습니다. 이번에는 StoreNode의 값을 변경하는 setter를 만들어주는 useStoreNodeSetter를 만들어봅시다. selector 구현 selector는 전역 상태를 읽고, 그 상태를 가공하여 새로운 값을 만들어내는 함수입니다. very-simple-store에서는 이 selector를 StoreSelectorNode라는 이름으로 구현했습니다. selector 등록 우선 전역 상태를 담고 있는 Store 객체에 selector를 추가할 수 있도록 합니다. selector 관련 타입은 이렇게 선언했습니다. selector가 의존하는 전역 상태를 _dependencies에 담고, selector의 리턴값을 value에 담습니다. Selector<T>는 실제 selector 함수의 타입입니다. 인자에 get이라는 getter 함수를 전달해 selector가 의존하는 전역 상태를 가져올 수 있도록 합니다. selector의 실제 구현 코드에 별다른 제약을 가하지 않았기 때문에, 전역 상태가 변경됐을 때 동작해야 하는 로직은 사용단에서 자유롭게 넣을 수 있습니다. 또한 Store 외부에서 바뀌는 값은 selector 내부에서 자연스럽게 사용할 수 없게 되므로, selector의 모양을 순수 함수로 강제해 줄 수 있다는 장점도 덤으로 얻을 수 있습니다. 이제 StoreSelectorNode를 생성하는 함수인 addStoreSelectorNode를 만들어봅시다. 아직 selector를 실행하지는 않았으므로 value는 undefined입니다. 이 부분에서 value의 초기값을 어떻게 처리할까 고민했는데, Selector Node를 선언한 것 만으로 selector가 실행된다면 문제가 생길 수 있다고 생각해 이렇게 처리했습니다. 다음으로 StoreSelectorNode의 값을 사용하도록 도와주는 useStoreSelectorNode입니다. 여기까지는 useStoreNode와 크게 다른 부분은 없습니다. useStoreNode때와 마찬가지로, forceUpdate가 실행되면 리턴문이 다시 평가되기 때문에 최신 상태를 가져올 수 있습니다. 다만 이 코드만으로는 아직 구현이 안된 부분이 있습니다. 전역 상태에 selectorNode를 등록하는 로직이 필요합니다. selector의 초기값을 평가하고, 의존하고 있는 전역 상태의 Set인 dependencies를 만들어 Store 객체에 등록합니다. 이렇게 정의된 registerSelectorNode를 useStoreSelectorNode에서 호출하면 됩니다. selector 구현 이제 selector를 트리거하고, selector에 넘겨줄 get 함수의 구현이 필요합니다. selector 함수는 전역 상태가 바뀔 때 실행되면 되므로, useStoreNodeSetter에서 전역 상태를 바꾸는 곳이 이 로직이 위치할 곳이 됩니다. async selector 구현 '상태 관리'에서 빼놓을 수 없는 기능 중 하나는 비동기 처리입니다. 앞서 구현한 selector가 비동기 함수를 지원하도록 개선해보겠습니다. 먼저 Selector 타입이 Promise도 리턴할 수 있도록 변경합니다. 이제 register시 비동기 처리를 추가합니다. selector를 트리거할 때도 비동기 처리를 고려해야 합니다. 상태가 바뀌지 않았다면 리렌더링을 하지 않도록 최적화 전역 상태가 바뀌지 않았다면 구독중인 컴포넌트를 리렌더링 할 필요 없습니다. 이를 고려하면 무거운 selector의 불필요한 실행도 방지할 수 있습니다. 리액트 내부 구현중에도 비슷한 로직이 있는데, 거기에서 차용한 아이디어입니다. 구현된 추가 기능 이상으로 핵심 로직 설명을 마칩니다. very-simple-store에서 제공하는 기능은 이 외에도 조금 더 있습니다. useCurrentStoreState: 현재 store 객체 전체를 확인할 수 있는 Hook입니다. 이를 위해 store 자체에서도 subscribe 기능을 제공하도록 했습니다.일부 코드의 고도화: Store와 관련된 로직은 모두 Store 객체 내부에 캡슐화 하고, Store 객체를 사용하는 컴포넌트들은 Store 객체의 메서드를 호출하는 방식으로 구현했습니다. 이렇게 하면 Store 객체의 내부 구현이 바뀌어도 사용자에게는 영향을 주지 않습니다. 실제 코드를 보고 싶으시다면 여기를 참고해주세요. 마치며 Recoil의 API와 내부 구현에서 영감을 받아 직접 간단한 형태의 전역 상태 라이브러리를 구현해봤습니다. 여러 로직을 고민해보며 실제 코드가 왜 그렇게 구현됐을지 이해하는 과정이 재밌었습니다. selector가 StoreNode 뿐만 아니라 StoreSelectorNode도 가져올 수 있게 하고, React.useSyncExternalStore를 사용할 수 있도록 개선해 서버 사이드 동작에도 완벽하게 대응할 수 있도록 하는 등의 추가 기능도 구현해보고 싶습니다. ",
    "date": "2023-11-19",
    "slug": "global-state-management",
    "title": "리액트 전역 상태 관리 라이브러리 개발해보기"
  },
  {
    "content": "HTML Living Standard를 확실히 공부하고 Semantic HTML을 향해 한발짝 더 나가봤습니다! 시멘틱 마크업? 의미있는 HTML을 만들기 위한 노력입니다. 웹 에이전트, Web Agent Serch Engine의 DB를 구축하기 위해 인간을 대신해 정보 자원을 수집, 검색, 추론해 다른 에이전트와 상호 정보 교환 등의 일을 수행하는 지능형 에이전트로, 시멘틱 웹 기반 응용 서비스의 핵심 요소입니다. 이런 페이지가 있다고 하면 Web Agent는 Naver 밑에 오픈캐스트가 있고, 그건 다시 금주의 오픈캐스트와 오늘의 오픈캐스트로 나뉘는구나! 라고 생각합니다. 같은 페이지에 대해 똑같은 Text Node를 가진 <a>가 많이 있다면 아, 이 페이지의 컨텐츠가 인기가 좋구나, 이 페이지를 상단에 띄워줘야겠다고 생각하기도 합니다. 이렇게 컨텐츠까지도 시멘틱 마크업의 범주에 포함됩니다. 즉, 인터넷의 정보들을 컴퓨터가 이해할 수 있고, 그 정보를 가공할 수 있도록 하는게 Semantic Markup의 목적입니다. 웹 접근성을 향상시켜 정보의 격차를 줄이는 것도 목표중 하나입니다. HTML Living Standard 웹 표준을 정하고자 하는 단체는 대표적으로 W3C(World Wide Web Consortium)와 WHATWG(Web Hypertext Application Technology Working Group)가 있습니다. 2007년에 WHATWG에서 W3C측에 제안한 명세가 바로 HTML5입니다. 2019년부터 두 조직이 합의해 WHATWG가 내세우는 HTML Living Standard가 표준이 되었습니다. WHATWG 웹은 항상 진화하고, '완성'되지 않습니다. 이런 의미에서 살아있는 생물처럼 웹 표준도 시시각각 달라진다는 뜻으로 HTML Living Standard라고 부릅니다. 관련 기사 본 글에서는 HTML Living Standard의 요소들 중 자주 사용하는 요소들을 정리했습니다. 시작하기 전에 Remind 👀 : Markup은 항상 가능한 최소로, 간결하게 짜는 것이 좋은 습관입니다! Document element <!DOCTYPE html> DTD(Document type Definition)라고 불리며, 문서의 타입에 관한 정보를 나타냅니다. 이 요소가 없다면 브라우저는 quirks mode(호환 모드)로 HTML을 렌더링하게 되는데, 브라우저마다 구현 방식이 다르기 때문에 다르게 동작할 가능성이 있으므로 반드시 문서 최상단에 이 요소를 넣어줘야 합니다. MDN 호환 모드와 표준 모드 <html> HTML 문서의 최상단 요소로, 루트 요소라고도 불립니다. 다른 모든 요소들은 <html> 요소의 후손입니다. lang attribute를 통해 문서의 주 언어가 무엇인지 설정할 수 있으며, 이 값이 검색엔진과 스크린 리더의 작동에 영향을 미칩니다. Document metadata <head> 문서 메타데이터가 모이는 요소입니다. <title> 문서의 제목을 의미하며, 반드시 한번만 사용해야 합니다. <link> 외부의 자원을 문서와 연결하는 역할을 합니다. 스타일 시트, 파비콘 등 여러가지를 연결합니다. <meta> MDN 문서 문서의 메타데이터를 나타내는 요소입니다. <meta>가 제공하는 메타데이터는 다음의 네가지가 있습니다. name: 문서 전체에 영향을 주는 document-level metadata입니다.name=\"author\": 페이지를 작성한 개발자의 이름입니다.name=\"description\": 페이지에 대한 설명 정보로, 검색엔진이 사용자에게 결과 화면을 출력할 때 중요하게 고려되는 요소입니다.name=\"viewport\": 모바일에서 사용자 화면의 사이즈에 대한 값을 설정, 요즘엔 반드시 넣어주는 것이 권장됩니다.http-quiv: pragma directive(프라그마 지시문)이라고 합니다. 브라우저에 어떤 행동을 지시하려는 목적으로 사용됩니다.http-quiv=\"X-UA-Compatible\": IE에서 어떤 형식으로 렌더링할지 지정할 때 사용하며, content=\"IE=edge\"는 IE8 이상에서 항상 표준모드로 렌더링 되도록 합니다.charset: 문서의 문자 인코딩 상태를 의미하며, 보통 UTF-8로 설정해 전세계 모든 언어를 지원토록 합니다.itemprop: 유저가 정의한 메타데이터를 나타냅니다.예를 들어 썸네일 이미지를 표시하고 싶다면 Open Graph Image가 들어가도록 <meta property=\"og:image\" content=\"이미지/주소.png\">를 넣는 식입니다. name=\"author\": 페이지를 작성한 개발자의 이름입니다.name=\"description\": 페이지에 대한 설명 정보로, 검색엔진이 사용자에게 결과 화면을 출력할 때 중요하게 고려되는 요소입니다.name=\"viewport\": 모바일에서 사용자 화면의 사이즈에 대한 값을 설정, 요즘엔 반드시 넣어주는 것이 권장됩니다. http-quiv=\"X-UA-Compatible\": IE에서 어떤 형식으로 렌더링할지 지정할 때 사용하며, content=\"IE=edge\"는 IE8 이상에서 항상 표준모드로 렌더링 되도록 합니다. 예를 들어 썸네일 이미지를 표시하고 싶다면 Open Graph Image가 들어가도록 <meta property=\"og:image\" content=\"이미지/주소.png\">를 넣는 식입니다. 자주 쓰이는 메타데이터 <style> 문서 전체 혹은 일부의 스타일을 나타냅니다. 외부에서 불러온 CSS보다 <style>요소에 담긴 스타일이 우선적으로 적용됩니다. Sections <body> 사용자에게 보여지는 문서의 컨텐츠를 나타냅니다. <header> WHATWG 문서 특정 컨텐츠의 시작을 나타냅니다. 일반적으로 구역의 제목(Heading elements 혹은 <hgroup>)을 포함합니다. (꼭 있어야 하는건 아닙니다.) 페이지당 하나만 있어야 하는건 아니며, 각 <section>들도 <header>를 가질 수 있습니다. <h1> ~ <h6> Section Heading elements MDN 문서 heading 요소라고 부르며, <h1> ~ <h6>까지 중요도에 따라 제목을 지정하기 위해 사용됩니다. 순서를 잘 지켜서 사용해야 합니다. 해당 제목을 포함하는 익명 영역(Anonymous Section)을 암묵적으로 생성해 다음 heading 요소가 나올때까지가 해당 heading 요소의 공간이 됩니다. <h1>은 페이지당 한 번만 사용해야 합니다. 보통 로고나 브랜드명을 <h1>으로 감쌉니다. 이 블로그에서는 좌상단에 있는 Custardcream이 이 요소로 감싸져 있습니다. (제 닉네임,,,) <section>, <article> 문서의 구획을 나누고자 할 때 사용합니다. 둘은 아래의 차이점이 있습니다. <article>은 독립적으로 있을 수 있는 컨텐츠에 사용합니다. *다른 서비스에 가져다 놔도 어색하지 않은가?*를 기준으로 삼으면 됩니다. 날씨 위젯 등이 여기에 해당됩니다.<section>은 사이트 내의 다른 컨텐츠와 연관이 있습니다. heading 요소와 함께 사용하는 것을 권장하지만 필수는 아닙니다. <nav> 현재 페이지 내, 혹은 다른 페이지로의 링크를 보여주는 구획입니다. 보통 메뉴에 사용되며, 페이지 최상단에 오는 <nav>는 <header>에 넣습니다. <aside> 문서의 흐름과는 상관 없는 별개의 구획을 나타냅니다. 보통 각주나 광고 영역을 넣거나, 양쪽 사이드에 위치해야 하는 요소를 그룹지을 때 사용합니다. <footer> 페이지나 각 <section>의 최하단에 위치하는 요소로, 페이지 최하단에 위치한 경우 회사에 대한 정보나 저작권 관련 정보가 들어가는 부분입니다. <address> 가장 가까운 부모 <article>이나 <body> 요소의 연락처 정보를 나타냅니다. 전화번호, 메일 주소, 우편 주소 등이 올 수 있습니다. <a>로 넣을 경우 컨텐츠가 직접 정보를 나타낼 필요는 없습니다. <a href=\"mailto:custardcream@kakao.com\">메일 주소</a>같은 요소도 <address>의 자식이 될 수 있습니다. <small> 저작권 정보를 나타냅니다. Grouping content <main> 문서의 주요 콘텐츠를 의미합니다. 현재 페이지에서 유일한 내용이어야 하며, 다른 페이지 혹은 섹션에서 반복될 수 있는 정보(로고, 검색 폼, 저작권 정보 등)는 이 요소에 들어가지 않습니다. <div> 레이아웃을 나눌 때 사용하는 요소입니다. 컨텐츠의 형태를 바꾸지는 않지만 여러 요소들을 <div>로 묶어 스타일을 변경할 수 있습니다. <article>, <section>, <header>, <nav> 등은 기본적으로 <div>와 동일한 역할을 합니다. 단지 그 이름으로 Semantic하게 마크업을 할 수 있도록 정의된 요소들일 뿐입니다. 의미있는 마크업을 위해 가능하면 <div>를 남발하기 보다는 적합한 요소를 찾아 사용해야 합니다. <ol>, <ul>, <li> <ol>과 <ul>은 각각 Ordered List, Unordered List를 의미합니다. <li>는 이 요소들의 자식으로 오는 List Item을 뜻합니다. <ol>과 <ul>의 직계자식은 반드시 <li>만 올 수 있습니다. <dl>, <dt>, <dd> <ol>, <ul>, <li>처럼 목록을 정의할 때 사용하지만, 사전처럼 어떤 것을 정의할 때 쓰이는 목록입니다. <dl>은 Definition List, <dt>는 Definition Term, <dd>는 Definition Description을 의미합니다. 보통 <footer>에서 아래같은 부분을 <dl>, <dt>, <dd> 요소로 마크업합니다.  (실제 코드라이언 페이지 코드 보니까 ul li로 돼있긴 하지만... 이렇듯 마크업은 개발자의 생각에 따라 좌지우지되고 정답은 없습니다.) <figure>, <figcaption> 이미지에 캡션(설명)을 달 때 사용하는 요소입니다. <p> 문단을 의미합니다. 하나의 완결된 문단을 의미하므로 <p>가 <p>를 자식으로 가질수는 없습니다. 줄바꿈 용도로 써서도 안됩니다. <pre> HTML에 작성한 내용 그대로 표시하는 요소입니다. (정확히는 이 부분의 마크업에 있는 공백은 있는 그대로 표현해라 라는 뜻) 주로 코드를 표현할 때 사용합니다.  보시다시피 User Agent Stylesheet로 인해 기본적으로 고정폭 글꼴(fixed-width font)을 사용해 표현됩니다. <blockquote>, <q> <blockquote>는 블록으로 감싸는 인용구를, <q>는 짧은 인용구를 의미합니다. 본 블로그에서는 이게 <blockquote>입니다! <hr> 이야기의 장면 전환, 문단 안에서 주제가 바뀔 때 구별을 위해 사용합니다. 원래는 가로줄을 표현하기 위해 사용된 요소이지만 HTML5 이후로 의미가 생겼습니다. 단락을 구분한다는 의미이므로 <p> 요소 안에서 사용하는 것은 웹 표준에 어긋납니다. ",
    "date": "2022-09-07T12:06:00+09:00",
    "slug": "html-living-standard-part1",
    "title": "HTML Living Standard 1"
  },
  {
    "content": "Frontend 개발자가 되기 위해 기본기도 다지고, 앞으로 있을 기술 면접을 대비해 중요한 개념들을 질문, 답변의 형태로 정리했습니다. 질문들은 이 블로그를 참고했습니다. CS, JS, React, Frontend로 나뉘며 각 편은 계속해서 내용을 붙여나갈 예정입니다. 이 글은 그 중 CS 관련 내용을 정리한 글입니다. 브라우저 주소창에 주소를 입력하면 어떤 일이 일어나나요? 참고할만한 Web.dev 글 가장 먼저 웹사이트의 IP주소를 알아야 합니다. 이를 위해 첫째로 DNS Cache를 확인하고, 다음으로 로컬에 있는 hosts 파일을 확인하고, 마지막으로 DNS 서버에 질의합니다. IP주소를 획득하면 TCP연결을 먼저 진행합니다. TCP 연결이 성공하면 HTTP request가 나가서 response를 받게 됩니다. 이후 웹 브라우저의 렌더링 엔진이 이 응답을 브라우저상에 렌더링하게 됩니다. 렌더링 엔진에 대해 설명해주세요. 렌더링 엔진은 HTML, XML, 이미지 등 웹 서버로부터 받은 응답을 브라우저상에 보여주는 역할을 합니다. 예를 들어 HTML 문서를 응답받으면 렌더링 엔진의 HTML parser와 CSS parser를 이용해 파싱되고, DOM과 CSSDOM 트리로 변환되고, 렌더 트리로 결합합니다. 그 다음, 렌터 트리에 명시돼 있는 각 노드의 정확한 위치를 가지고 layout을 그린 후, 브라우저의 UI Backend Layer를 이용해 페인팅을 진행해 웹페이지를 화면에 표시합니다. 크롬은 Blink, 사파리는 Webkit을 사용하며 렌더링 엔진마다 CSS문법이 다르기도 합니다. URL과 URI는 어떻게 다른가요?  URI, Uniform Resource Identifier는 URL과 URN을 포함하는 개념입니다. URI는 인터넷에서 특정 아이템을 식별할 수 있는 string이며 URL이 이에 포함됩니다. URL(Uniform Resource Locator)은 특정 아이템의 identifier와 그 아이템으로 접근할 수 있는 방법(cheme)이 명시된 string입니다. 예를 들어, google.com은 URI이고, https://google.com은 URI이자 URL입니다. DNS에 대해 설명해주세요. DNS, Domain Name Service는 분산형 DB 구조를 가지고 있는 서버로, 도메인 네임을 가지고 Host의 IP를 찾아주는 역할을 합니다. Protocol이란 무엇인가요? 프로토콜이란 컴퓨터 사이 데이터 통신을 위한 규약을 말하는데, Application Layer, Transport Layer, Internet Layer, Network Interface Layer(Link Layer)의 네 스택으로 나뉩니다. HTTP에 대해 설명해주세요. HTTP, Hyper Text Transfer Protocol은 인터넷 프로토콜 중 하나입니다. HTTP는 Protocol의 네 레이어 중 Application Layer에 속합니다. HTTP는 세가지 특징이 있습니다. 클라이언트 서버 구조, 즉 서버에 요청을 보내고, 응답을 기다렸다가 서버로부터 응답을 받는 구조를 가지고 있습니다.서버가 프로토콜의 상태를 보존하지 않는 무상태 프로토콜입니다. 때문에 로그인처럼 상태를 유지할 필요가 있는 경우에는 쿠키나 세션 등을 이용해야 합니다.연결을 유지하지 않는 비연결성을 가지고 있습니다. HTTP 메세지는 Request와 Response로 구성되는데, 이는 각각 start-line, header, empty line, message body로 이뤄져 있습니다. 그 중 start-line만 설명하면 아래와 같습니다. Request Request-Line(Request): Method SP Request-URI SP HTTP-Version CRLFSP=공백, CRLF=줄바꿈Method 종류: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT SP=공백, CRLF=줄바꿈Method 종류: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT Status-Line(Response): HTTP-version SP Status-Code SP Reason-Phrase CRLFStatus-Code 종류1xx: Informational2xx: Success3xx: Redirection4xx: Client Error5xx: Server Error Status-Code 종류1xx: Informational2xx: Success3xx: Redirection4xx: Client Error5xx: Server Error 1xx: Informational2xx: Success3xx: Redirection4xx: Client Error5xx: Server Error TCP/IP 연결이란 무엇인가요? IP, Internet Protocol은 Internet Layer에 속하는 프로토콜로, 지정한 IP 주소에 패킷 단위로 데이터를 전달하는 프로토콜입니다. 패킷에는 출발지의 IP, 목적지의 IP, 전송할 데이터 등이 포함됩니다. 그러나 IP 프로토콜은 패킷을 받을 상대가 없거나, 중간에 패킷이 사라지거나, 같은 IP를 사용하는 여러 어플리케이션이 통신하면 구분할 수 있는 방법이 없다는 한계가 있습니다. 이를 해결하기 위해 TCP를 사용합니다 TCP, Transmission Control Protocol은 Transport Layer에 속하는 프로토콜로, 연결지향형 프로토콜입니다. 3-Way-Handshake, 데이터 전달의 보증, 순서를 보장한다는 특징이 있어 신뢰할 수 있는 프로토콜이라고 불립니다. 3-Way-Handshake는 먼저 클라이언트에서 서버로 TCP 연결 요청을 보내고, 서버에서 ACK, 즉 acknowledgment(확인) 응답을 보내면 다시 클라이언트에서 서버로 ACK 응답을 보내는 과정으로, 이를 통해 TCP는 연결을 보장해줍니다. REST API에 대해 설명해주세요. Redhat Docs REST API(=RESTful API)는 HTTP를 사용하는, REST 아키텍처 스타일을 지키는 어플리케이션 프로그래밍 인터페이스이자 가이드라인입니다. 다양한 포멧을 사용할 수 있지만 보통은 JSON 포멧을 사용합니다. REST API를 설계할 때는 HTTP Method에 맞게, 확장성을 지니도록 잘 설계해야 합니다. 객체 지향 프로그래밍이란 무엇인가요? OOP, Object Oriented Programming은 프로그래밍 패러다임중 하나로 컴퓨터 프로그램을 여러 객체들의 모임으로 만들고자 하는 것입니다. 각 객체가 서로 데이터를 주고받고 처리하며 프로그램이 작동합니다. 객체지향 프로그래밍은 프로그램의 확장성과 유지보수성에 좋은 영향을 주고, 객체를 재사용하기 용이하며, 강한 응집력과 약한 결합력을 유지하는 데 도움이 되기 때문에 많이 사용됩니다. 기본적으로 클래스, 객체, 메소드와 메세지로 구성됩니다. Class: 같은 종류로 분류될 수 있는 것들을 모아둔 것으로, 클래스 외부에 있는 요소들과 독립적으로 디자인됩니다. field와 method를 가집니다.Object: 클래스의 Instance로, 클래스에서 정의된 내용들을 사용할 수 있습니다.Method, Message: 클래스로부터 생성된 객체를 사용하는 방법으로, 메소드로는 객체의 속성을 조작하고 메세지로 객체간 통신이 이뤄집니다. OOP는 다음의 특징을 가지고 있습니다. 추상화: 실생활의 문제들처럼 객체를 추상화해 설계합니다.상속, 다중 상속: 새로운 클래스가 기존의 클래스를 상속받거나 파생될 수 있습니다. 하나의 클래스가 두개 이상의 클래스로부터 상속받을 수 있습니다. 코드의 재사용성와 유연성을 높여줍니다.다형성: 한 요소에 여러 개념을 넣어 놓을 수 있다는 의미로, 대표적으로 메소드 오버라이딩이나 오버로딩이 있습니다. 오버라이딩은 같은 이름의 메소드가 여러 클래스에서 각기 다른 기능을 하는 것을 말하고, 오버로딩은 같은 이름의 메소드가 인자의 개수나 자료형에 따라 다른 기능을 하는 것을 말합니다. 추가적으로 클래스 관점에서는 여러 클래스를 상속에 따라 한가지 이름으로 부를수도 있습니다. 이를 통해 객체간 관계를 조직적으로 나타낼 수 있습니다.캡슐화: 내부의 구현은 감추고, 모듈 내에서 응집도를 높이며 모듈간의 결합도를 떨어뜨립니다. 그러나 이같은 장점에도 처리 속도가 느리다는 단점이 있어 프로그램을 설계하는 데에 많이 신경써야 합니다. 최근에는 함수형 프로그래밍이라는 패러다임이 떠오르고 있는데, 함수형 프로그래밍은 프로그램을 상태값을 지니지 않는 함수값들의 연속으로 보는 관점입니다. Process와 Thread의 차이는 무엇인가요? 프로세스는 OS로부터 자원을 할당받는 작업의 단위이고, 스레드는 이렇게 할당 받은 자원을 이용해 실행하는 단위로 한 프로세스 내에 여러 스레드가 있을 수 있습니다. 어플리케이션 하나가 프로세스이고, 그 안에서의 처리가 스레드입니다. Multi Process와 Multi Thread에 대해 설명해주세요. Multi Process는 하나의 프로그램을 여러 개의 프로세스로 구성해 각 프로세스가 하나의 작업을 처리하는 것입니다. 이렇게 함으로서 하나의 프로세스에서 오류가 발생해도 프로그램은 계속해서 동작할 수 있다는 장점이 있으나 context switching을 하는 과정에서 비용이 발생합니다. Multi Thread는 프로그램을 여러 개의 스레드로 구성하고 각 스레드가 작업을 처리하는 것입니다. 상대적으로 속도가 빠르고 스레드간 자원을 공유할 수 있다는 장점이 있으나 디버깅이 어렵고, 동기화 관련한 이슈가 발생할 수 있으며 스레드 하나라도 오류가 발생하면 전체 프로세스에 문제가 생긴다는 단점이 있습니다. Thread Safe란 무엇인가요? Thread Safe는 여러 스레드가 동시에 사용돼도 안전하다는 것을 의미합니다. 더 자세히 말하면, 특정 함수 혹은 변수가 여러 스레드에서 호출돼도 하나의 스레드에서 호출됐을 때와 같은 결과가 보장되어야 한다는 의미입니다. 함수가 함수 바깥에 위치하는 전역 변수를 참조하면 Thread Safe하지 않을 수 있습니다. Context Switching이란 무엇인가요? CPU에서 여러 프로세스를 돌아가며 작업을 처리하는 과정을 뜻합니다. 동작중인 프로세스가 대기를 하면서 프로세스의 context 즉 상태를 보관하고 대기하다가 다시 실행할 때 복구에 걸리는 시간이 이 Context Switching에 들어가는 비용입니다. 동기(synchronous)와 비동기(asynchronous)에 대해 설명해주세요. 동기 방식은 하나의 스레드로 여러 요청을 순서대로 처리하는 방식이고, 비동기 방식은 스레드를 여러개 만들어 여러 요청을 번갈아가며 처리하는 방식입니다. 자바스크립트와 연결지어 설명을 이어나가보겠습니다. 먼저, JS는 싱글 스레드 언어입니다. 때문에 시간이 걸리는 작업을 하나 처리해야 할 때 다른 서비스들이 실행이 중단돼버립니다. 이는 웹페이지의 사용성에 치명적이므로 WebAPI에서는 비동기적 처리를 가능케 해줍니다. JS Engine(대표적으로 V8)에는 하나의 힙과 하나의 콜 스택이, JS 런타임 웹 브라우저의 WebAPI에는 이벤트 루프와 콜백 큐가 존재합니다. 이 call stack에 요청이 stack 형태로 쌓이고, Web API에서 이 코드에 대한 처리를 비동기로 처리합니다. 비동기 함수에는 setTimeout(), setInterval(), HTTP 요청, 이벤트 헨들러 등이 있으며 각 함수들은 callback pattern을 사용해 이 콜백 함수에 넣어준 내용이 각 함수의 실행이 끝날 때 실행됩니다. ",
    "date": "2022-08-20",
    "slug": "review-frontend-fundamentals-cs",
    "title": "Frontend 기본기 다지기 - CS편"
  },
  {
    "content": "댓글 컴포넌트를 리팩토링 하며 효율적인 컴포넌트 설계란 무엇인지 고민했습니다. 효율적인 컴포넌트 저는 효율적인 컴포넌트란 아래의 두가지를 만족하는 컴포넌트라고 생각합니다. 유지보수가 용이하고, 새로운 기능을 추가하기 좋은 컴포넌트재사용성이 좋아 공간 복잡도가 낮고, 리렌더링이 적어 시간 복잡도 또한 낮은 컴포넌트 각각 개발자와 유저의 관점에서 고려하면 좋을 포인트들입니다. 이번 포스트에서는 1번에 집중해 본 블로그의 댓글과 관련된 컴포넌트들을 리팩토링하며 어떻게 하면 이 목표들을 달성할 수 있을지 고민한 내용을 적어보겠습니다. 리팩토링 전 먼저 리팩토링 대상이 무엇인지 확인해보겠습니다.  리팩토링 전 컴포넌트의 모습입니다. 구조적으로는 댓글을 작성하는 폼과 댓글들을 포함하는 ol, 각 댓글 li들을 보여주는 카드 컴포넌트로 이뤄져 있습니다. 기능적으로는 폼의 댓글 작성 기능, 댓글 아이템의 수정 및 삭제 기능을 가지고 있습니다. 문제와 해결 각 문제 상황과 해결한 방법입니다. prop drilling 다음은 form과 ol, li를 모두 가지고 있는 Comments 컴포넌트입니다. 댓글 작성, 수정, 삭제시 firebase에서 docRef를 선언하기 위해 포스트 제목을 나타내는 title: string 값이 필요합니다. 이는 Commants 컴포넌트에서 받아 다시 CommentForm과 각 CommentCard에 prop으로 전달하고 있습니다. 댓글 리스트 데이터를 가지고 올 때 title 값을 사용하기 때문에 의미없이 자식으로 prop을 전달만 하고 있다고 볼순 없지만, 이게 과연 좋은 방법일지 고민됐습니다. 만약 여기서 CommentsList라는 depth를 추가하는 컴포넌트를 새로 만든다면, 이 컴포넌트는 title을 받아 또 다시 자식이 될 CommentCard로 넘겨줘야 할 것입니다. 이를 해결하기 위한 가장 간단한 방법으로 저는 Context API를 사용했습니다. prop으로 title을 받고 이를 context provider로 감싸주는 간단한 컴포넌트입니다. 댓글 컴포넌트를 리팩토링하면서 이렇게 Context API를 여러겹 사용했는데, 그럴 때마다 저는 provider 역할의 컴포넌트를 따로 선언해서 context 관리를 분리하고자 했습니다. 또, 아래와 같은 형식으로 context를 사용하는 커스텀 훅을 선언해, useContext의 직접적인 노출을 줄이고 더 명시적으로 context를 사용을 표현하고자 했습니다. React TypeScript에서 Children을 가지고 있는 컴포넌트의 타입 CommentPostTitleContextProvider 컴포넌트의 Prop 타입은 이렇게 선언했습니다. 이런 식으로 react 라이브러리에는 타입스크립트에서 유용하게 사용할 수 있는 타입을 다양하게 제공해줍니다. 이 cheet sheet를 참고해주세요. 구조 파악이 어려운 컴포넌트 Comments 컴포넌트 하나에는 section, form, ol 등 다양한 종류의 컴포넌트들이 모여있습니다. 때문에 사용할 때는 그냥 Comments 컴포넌트를 놓기만 하면 됩니다. 간단해서 좋긴 하지만, 저 한줄 안에 저 많은 컴포넌트들이 함축적으로 들어가는게 맞을까 하는 고민이 들었습니다. 댓글이라는 공통 관심사로 컴포넌트를 묶으면서도, 구조를 보여줄 수 있다면 컴포넌트의 구조를 Post 페이지 컴포넌트에서도 파악할 수 있게 만들 수 있지 않을까요? 이를 위해 컴파운드 컴포넌트 패턴을 사용해봤습니다. Comments를 하나의 객체로 보고 key, value로 자식이 될 컴포넌트들을 할당해, 이 컴포넌트를 사용하는 쪽에 마크업을 노출하도록 변경했습니다. 이 때, 앞서 만든 title provider를 Comments 컴포넌트에 할당해 자식 컴포넌트들이 title을 가지고 있는 context에 접근할 수 있습니다. 데이터는 따로 가지고 오기 위 변화와 더불어 댓글 데이터를 가지고 오는 로직의 위치를 바꿀 필요가 생겼습니다. 이제 CommentCard에 접근할 수 있는건 Comments가 아닌 이를 호출하는 Post 페이지 컴포넌트이기 때문입니다. 이를 위해 useComments 컴포넌트를 생성했습니다. 덕분에 자연스럽게 댓글 데이터를 가지고 오는 로직과, 댓글의 모습을 나타내는 UI를 분리하는 성과를 얻을 수 있었습니다. 이런 요소 하나 하나가 유지보수성을 높이는 데 큰 도움이 될겁니다. 복잡한 형태의 conditional rendering CommentCard 컴포넌트는 댓글을 나타내는것 뿐만 아니라, 댓글의 수정 및 삭제를 담당하고 있습니다. 그런데, 댓글을 삭제하거나 수정할 때는 댓글 작성시 입력된 비밀번호 확인이 필요합니다.  이를 위해 리팩토링 전 코드는 대략 이렇게 짜여 있었습니다. 실제 코드를 그대로 옮겨오면 너무 끔찍해서 많이 생략했는데도 이정도입니다. 러프하게 설명하면 이런 구조입니다. 댓글 수정 버튼이 눌리면 isEditing을 true로, 댓글 삭제 버튼이 눌리면 isDeleting을 true로 변경합니다. 둘 다 false라면 댓글 내용과 수정 및 삭제 버튼을 렌더링합니다.isEditing 혹은 isDeleting이 true라면 비밀번호 확인용 form 컴포넌트를 렌더링합니다.useEffect 훅을 활용해 isPasswordCorrect가 true로 바뀌었을 경우 isEditing이 true라면 댓글 수정용 form 컴포넌트를 렌더링하고, isDeleting이 true라면 댓글을 삭제합니다. 이 과정을 삼항 연산자로 표현하다보니 state가 과도하게 많이 사용됐고, 컴포넌트 로직 파악은 거의 불가능한 수준에 이르고 말았습니다. (실제 코드는 스타일을 제외하고도 120줄이 넘는 괴물 컴포넌트입니다.) 게다가, onClick, onChange, onSubmit 등 다양한 이벤트에 대한 핸들러를 상황에 따라 다르게 선언하지 않고 하나의 함수에서 모두 대응하고 있었습니다. 대표적으로 onClick 핸들러는 이렇게 생겼습니다. 이 함수 하나만으로 수정, 삭제, 취소의 세가지 로직을 처리하고 있는겁니다. 이런 구조때문에 로직을 파악하고 수정하기 매우 어려웠습니다. 이벤트의 종류에 따라 핸들링하면 복잡한 로직을 컨트롤하기 편할것이라고 생각했던 오판과, 컴포넌트가 비대해져도 분리하려고 하지 않았던 탓에 이런 결과가 이어졌습니다. 복잡한 형태의 conditional rendering이 필요할 경우 어떻게 하면 더 보기 좋게 처리할 수 있을까요? 이를 위해 먼저 CommentCard가 표현해야 하는 상태를 정리해봤습니다. default: 댓글을 나타냅니다. 수정 및 삭제 버튼은 노출되지 않은 상태입니다.option opened: 수정 및 삭제 버튼을 노출시킨 상태입니다.password: 댓글 수정 및 삭제 전 비밀번호를 입력받고, 통과 여부를 확인하는 form을 렌더링합니다.edit: 댓글을 수정할 수 있는 form을 렌더링합니다. 수정, 삭제 버튼이 모든 댓글에 항상 노출되는건 UX에 악영향을 준다고 생각해 리팩토링 하며 하나의 조건을 추가하기로 했습니다. 즉, 버튼들을 접았다 펼 수 있게 만들었습니다. 수정, 삭제 버튼을 담는 컴포넌트에서 상태별로 렌더링할 요소를 결정하는 것이 옳다고 판단했고, CommentEditorContainer라는 이름을 붙였습니다. 이 컴포넌트에선 현재 상태값을 기반으로 무엇을 렌더링할지 결정해야 합니다. 이런 conditional 로직은 보통 if문을 사용하거나 삼항 연산자를 쓰지만, 저는 좀 더 깔끔한 해결책을 고민했고 결국 이런 코드를 작성했습니다. 우선 현재 상태값을 Context API로 관리하고, 이 context를 useCommentEditState라는 커스텀 훅으로 사용합니다. 그리고 이 상태값에 맞는 컴포넌트를 commentEditorStateChildrenMap이라는 객체에서 찾아와 렌더링하도록 했습니다. JSX 문법을 사용할 수 있도록 State라는 대문자로 시작하는 변수를 거쳐 return합니다. 이제 state에 맞는 컴포넌트를 commentEditorStateChildrenMap에 넣어주면 됩니다. CheckPasswordState 컴포넌트의 재활용을 위해 비밀번호 확인이 수정을 위한 것인지 삭제를 위한 것인지를 나타내는 stateTo prop을 넘기도록 설계했습니다. 이제 각 컴포넌트에 수정, 삭제 등의 로직을 분리해 작성할 수 있게 됐습니다. 예를 들어 DefaultState 컴포넌트는 이런식입니다. 재사용성이 높은 버튼 컴포넌트 개발하기 블로그에는 텍스트가 가운데 위치하고 배경색이 들어가는 일반 버튼, 아이콘이 들어가는 아이콘 버튼 이렇게 두 종류가 존재하는데, 반복적으로 사용되므로 컴포넌트를 따로 분리하기로 했습니다. 그와 동시에 각 컴포넌트에는 일반적인 버튼 컴포넌트와 동일한 prop을 넘길 수 있도록 하고싶었습니다. 단순히 spread 문법으로 그대로 넘겨주는것 이상으로, 자동완성까지 가능하길 원했습니다. 로딩중 표현이 가능한 버튼 컴포넌트 특히 일반 버튼에 로딩중일 경우 로딩 인디케이터를 나타낼 수 있도록 한다면 멋진 버튼 컴포넌트가 될거라고 생각했습니다. 이를 위해 아래와 같은 컴포넌트를 만들었습니다. 우선 button 요소에 넘길 수 있는 prop을 가져오기 위해 react 라이브러리에서 제공하는 ComponentPropsWithoutRef 타입을 사용했습니다. 제네릭으로 \"button\"이라는 string을 넘기면 됩니다. 로딩중인지 여부를 확인하는 isLoading prop을 받아 true라면 Ring이라는 로딩 인디케이터를 렌더링합니다. onClick시 isLoading이 true라면 함수 동작을 막는 코드도 추가해 견고함을 더했습니다.  react-icons를 활용한 아이콘 컴포넌트 이번에는 아이콘을 가지고 있는 버튼 컴포넌트입니다. 로딩중 여부를 확인하는 등의 추가 기능이 있지는 않아서 특별할건 없지만, react-icons에서 가져온 컴포넌트를 prop으로 넘기는 방법을 고민했습니다. 이번에는 ref가 필요해서 forwardRef를 사용했습니다. react-icons 라이브러리에서는 아이콘 컴포넌트를 의미하는 IconType을 제공합니다. 이를 icon 이라는 이름의 prop으로 받고, 다시 JSX 문법을 사용해 렌더링하기 위해 const Icon = icon;이라는 코드를 통해 대문자로 시작하는 변수에 재할당합니다. 덕분에 이렇게 사용할 수 있게 됐습니다. Wrapup 너무 골치아파서 리팩토링을 미뤄왔던 컴포넌트를 드디어 건드렸네요. 처음 이 컴포넌트를 만들었을 때와는 달리 커스텀 훅이나 Context API를 적극적으로 사용할 수 있을 정도로 실력이 늘었다는게 뿌듯했습니다. 지금의 컴포넌트가 가장 좋은 설계라고 생각하진 않지만, 이 작업으로 많은 생각을 할 수 있었습니다. 특히, 복잡한 형태의 conditional rendering을 어떻게 설계하는게 좋을지 고민했던 과정이 재밌었습니다. 더 좋은 방법이 있다면 무엇일지 굉장히 궁금한 부분이기도 합니다. 이처럼 모든 부분에서 해결하고 충족되기만 하지는 않았습니다. 이번 리팩토링을 통해 이런 의문들을 가지게 됐습니다. Context Provider는 어떻게 배치하는게 좋을까?Compound Component와 Context Provider는 어떻게 하면 조화롭게 사용할 수 있을까?스타일 코드를 컴포넌트 로직과 같은 파일에 놓는것과 다른 파일로 분리하는것, 어느쪽이 더 좋은 방법일까?버튼이 눌릴 때마다 CSS Animation을 trigger 할 수 있는 더 깔끔한 방법은 뭘까?글에 적지는 못했지만 비밀번호 입력시 틀렸다면 에러 메세지를 흔드는 애니메이션을 trigger하기 위해 dummy boolean state를 사용했습니다. 글에 적지는 못했지만 비밀번호 입력시 틀렸다면 에러 메세지를 흔드는 애니메이션을 trigger하기 위해 dummy boolean state를 사용했습니다. 저는 컴포넌트 설계를 고민하고 개선해나가는 데에서 리액트의 매력을 느끼나봅니다. 이번에 새로 생긴 질문들에 대한 답을 꼭 찾을 수 있도록 더 많은 코드들을 찾아보고 직접 적용해보고 싶네요. ",
    "date": "2023-01-25",
    "slug": "refactor-comment-component",
    "title": "댓글 컴포넌트 리팩토링하기"
  },
  {
    "content": "HTML Living Standard를 확실히 공부해서 기본기를 다지는 시간 2탄!! Text-level semantics Text-level 요소는 요소 안의 컨텐츠의 크기만큼만 영역을 점유하고, 자식으로 Sections나 Grouping Contents를 배치할 수 없습니다. <br>, <wbr> <br>, <wbr> 모두 줄바꿈을 하는 요소입니다. <wbr> 태그는 텍스트 박스에서 한 줄로 모두 표시가 안될 때에만 줄바꿈이 일어나게 합니다.   <wbr> 요소는 이렇게 줄바꿈이 필요할 때(text가 overflow될 때) 자동으로 줄을 바꿔줍니다. CJK(Chinese, Japanese, Korean)의 기본적인 work-break property 값은 break-all로 되어있기 때문에 글자 한 자 한 자씩 끊어서 줄을 바꿉니다. white-space 줄바꿈에 관련된 property로는 또 white-space가 있습니다. nowrap, break-spaces, pre 등 다양한 value들이 있으며, 각각의 작동은 아래와 같이 달라집니다. (직접 버튼을 눌러서 어떻게 바뀌는지 확인해보세요!)  <a> <a> 요소는 링크, 즉 하이퍼 텍스트를 만들 때 사용하는 HTML(HyperText Markup Language)의 핵심적인 요소입니다. href(hyper reference) attribute의 값을 통해 경로를 지정할 수 있습니다. 자바스크립트로 경로를 지정할 수도 있지만 검색엔진 Agent들이 JS는 안읽고 HTML로만 문서를 판단하는 경우가 있으므로 웹 접근성에 위배되니 href attribute를 사용하는것이 좋습니다. 그래도 요즘은 다 JS까지 로드한 뒤에 데이터를 추출하긴 한다고 하네요! <a>는 예외적으로 Sections나 Grouping Contents들을 자식으로 가질 수 있습니다. 다만, <a>안에 <a>가 위치할 수는 없습니다! <b>, <strong> 둘 다 굵은 글씨(볼드체)를 표현하고 싶을 때 사용하지만, <strong> 요소는 더 나아가 '중요도'를 강조하는 의미를 가집니다. heading 요소를 사용하기 애매할 때 <strong> 요소를 사용합니다. 조직의 컨벤션에 따라 <b>는 아예 사용하지 않기도 합니다. <i>, <em> 둘 다 기울어진 글씨(이텔릭체)를 표현하고 싶을 때 사용하지만 아래과 같은 차이가 있습니다. <em> 요소는 강조의 의미를 가집니다.<i> 요소는 '주 언어와 다른 언어로 표현된 부분(주 언어는 한글인데 영어로 표기됐을 경우)', '소설 등의 작품에서 등장인물의 생각이 표기된 부분' 등 주위와 구분해야 하는 부분을 표현하기 위해 사용합니다. <dfn> 현재 문맥에서 정의하고 있는 용어를 의미합니다. 가장 가까운 부모가 <p> 또는 <dt>, <dd>쌍, <section>일 경우 그 컨텐츠가 <dfn>에서 정의하고자 하는 용어의 설명이 됩니다. <abbr> 줄임말을 나타내고 싶을 때 사용합니다.  이렇게 줄임말이라는 표시가 생깁니다. title attribute는 필수는 아닙니다. <sup>, <sub> 각각 윗첨자, 아랫첨자를 의미합니다. 단순히 작은 글자를 나타낼때 사용하면 안되고, 화학 기호나 수학 공식 등의 입력에만 사용합니다. 이외의 상황에서 위나 아래에 붙은 글자를 나타내고 싶다면 CSS에서 vertical-align property를 이용하면 됩니다. <time> 시간을 의미합니다. 컴퓨터가 알아듣기 어려운 형식일 경우 datetime attribute를 지정해줘야 합니다. datetime의 형식은 MDN 문서에서 확인할 수 있습니다. <cite> 책, 시, 노래, 영화 등 창작물 이름 등을 표현할 때 사용하는 요소로, 보통 이텔릭체로 렌더링됩니다. <span> 줄바꿈 없이 영역을 묶는 용도로 사용하는 요소로, 별다른 의미는 없습니다. <div>와 마찬가지로 남발하면 안됩니다. Embedded content <img> <img> 요소는 이미지를 삽입할 때 사용합니다. src (source): 필수 attribute로, 이미지 파일의 위치와 파일명을 알려줍니다. 이 때 경로는 절대경로 혹은 상대경로입니다.alt (alternative text): 이미지가 보이지 않을 때 이미지 대신 보여줄 텍스트입니다. 스크린리더같은 접근성을 위한 프로그램에 정보를 제공하기 위한 용도로도 사용되며, 이미지에 대한 정보를 브라우저에게 제공해 SEO에 도움을 주기도 합니다.<!-- 스크린 리더가 읽지 않습니다. --><img src=\"a.png\" alt=\"\" /><!-- 스크린 리더가 'a'를 읽습니다. --><img src=\"a.png\" /><!-- 스크린 리더가 '이미지'를 읽습니다. --><img src=\"a.png\" alt=\"이미지\" />경우에 따라서는 일부러 비워두기도 합니다.srcset (source set): 여러 해상도에 대응해 브라우저가 최상의 이미지를 로딩하는데 도움을 줄 수 있도록 하는 attribute입니다. 동일 이미지를 최소 2개 이상 가지고 있을 때 사용하며, 브라우저가 이미지를 선택합니다.아래는 제가 실제로 사용한 샘플 코드입니다.<img  class=\"title__img centering\"  srcset=\"./img/title_mobile.png 267w, ./img/title.png 564w\"  sizes=\"(max-width: 780px) 267px, 564px\"  src=\"./img/title.png\"  alt=\"1만 시간의 법칙\"/>srcset에서 이미지의 크기를 나타낼 수 있는 방법은 여러가지가 있는데, 여기에서는 x서술자, w서술자, sizes attribute라는 키워드만 언급하겠습니다. src (source): 필수 attribute로, 이미지 파일의 위치와 파일명을 알려줍니다. 이 때 경로는 절대경로 혹은 상대경로입니다. alt (alternative text): 이미지가 보이지 않을 때 이미지 대신 보여줄 텍스트입니다. 스크린리더같은 접근성을 위한 프로그램에 정보를 제공하기 위한 용도로도 사용되며, 이미지에 대한 정보를 브라우저에게 제공해 SEO에 도움을 주기도 합니다. 경우에 따라서는 일부러 비워두기도 합니다. srcset (source set): 여러 해상도에 대응해 브라우저가 최상의 이미지를 로딩하는데 도움을 줄 수 있도록 하는 attribute입니다. 동일 이미지를 최소 2개 이상 가지고 있을 때 사용하며, 브라우저가 이미지를 선택합니다. 아래는 제가 실제로 사용한 샘플 코드입니다. srcset에서 이미지의 크기를 나타낼 수 있는 방법은 여러가지가 있는데, 여기에서는 x서술자, w서술자, sizes attribute라는 키워드만 언급하겠습니다. <picture> <source>, <img> 요소를 통해 각 조건에 따라 맞는 이미지를 보여주는 요소입니다. <img>에서 srcset attribute를 사용하면 화면에 따른 이미지의 크기만 조절하지만, <picture> 요소를 사용하면 이미지의 포멧 자체를 바꿀 수 있습니다. type, media attribute의 값을 참고해 브라우저에 가장 알맞는 이미지 source를 자동으로 골라줍니다. 모든 <source> 요소의 이미지 사용이 불가하면 최후에 <img> 요소의 src를 이용합니다. 이런 방식의 크로스브라우징 기법을 점진적 향상기법(기본적으로 옛날 브라우저에서 작동할 수 있는 코드를 넣고, 최신 기술을 사용할 수 있는 환경에서는 최신 기술을 사용할 수 있도록 하는 기법)이라고 합니다. <source> 요소의 srcset attribute가 media attribute의 값을 참고해 <img>의 src attribute를 바꿔넣는 식으로 작동하므로 반드시 <img>요소는 있어야됩니다. 언제 srcset을 쓰고 언제 <picture> 요소를 쓸까? 해상도에 따라 '다른' 이미지(포멧이 달라도 다른 이미지입니다)를 보여주고 싶다면 <picture> 요소를, '같은' 이미지를 보여준다면 srcset을 이용합니다. <iframe> HTML 안에서 또 다른 HTML 페이지를 보여주고 싶을 때 사용하는 요소입니다. width, height attribute로 크기를 조절하며 따로 값을 안정하면 150px x 300px이 기본값이 됩니다. 본 블로그에서 포스트 중간 중간 보이는 HTML 실습 결과도 이미지가 아닌 <iframe> 요소입니다. 보통은 유튜브 영상을 불러올 때 많이 사용합니다. 웹사이트 안에서 다른 웹페이지를 또 불러오는 것이기 때문에 DBD(Drive By Download) 공격에 취약해질 수 있으므로 조심히 사용해야 합니다. DBD 공격이란 사용자의 의도와 무관하게 악성코드가 다운로드 및 실행되는 공격으로, 여기에서는 <iframe> 안에 위치한 JS 코드도 실행된다는 점을 악용한 공격입니다. <audio> 음악 컨텐츠를 재생하기 위한 요소로, 요즘엔 잘 안씁니다. <source> 요소를 자식으로 사용해 크로스브라우징을 위해 여러 포멧을 사용할 수도 있습니다. <video> 동영상 파일을 재생하기 위한 요소입니다. <source> 요소를 자식으로 사용해 크로스브라우징을 위해 여러 포멧을 사용할 수도 있습니다. <form> 정보를 입력하는 영역을 뜻합니다. <form>에 입력하고 제출(submit)하면 데이터는 서버로 전송되고, 그 데이터는 웹 서버가 처리하며 그 결과 페이지를 클라이언트에 전송합니다. <input> 사용자가 <form>에 입력할 수 있는 공간을 만들어 주고, 사용자에게 정보를 입력받습니다. 굉장히 많은 attribute와 type을 가지고 있습니다. <input>의 attribute들 type: <input> 요소의 모양을 다양하게 바꿀 수 있습니다.name: 요소의 이름을 지정합니다.readonly: 읽기 전용으로 합니다.maxlength, minlength: 최대, 최소 글자 수를 지정합니다.required: 필수적으로 입력해야 하는 값이 됩니다. 이 값을 채우지 않고 submit하면 에러를 띄우고 데이터가 전송되지 않습니다.autofocus: 웹 페이지가 로딩되면 이 요소로 포커스가 바뀝니다.placeholder: 입력할 값에 대한 힌트를 사용자에게 표시합니다.pattern: 정규표현식을 사용해 값의 유효성을 검사할 수 있습니다. 다양한 type들  <input type=\"hidden\">은 언제 사용하는걸까? hidden 타입은 서버로 넘길 데이터가 추가될 필요가 있을 때 사용합니다. 이 부분을 자바스크립트로 구현하려고 하면 굉장히 번거로우니, 꼭 hidden 타입을 잊지 말고 사용합시다!! 바퀴를 다시 발명하지 마라(Don't reinvent the wheel)라는 개발자 격언이 있다고 해요! <label> <input> 요소를 설명하는 텍스트를 의미하며, 웹 접근성에도 영향을 줄 수 있습니다. (시각 장애인들도 사용할 수 있도록 Semantic하게 사용해야 합니다.) 사용하는 방법은 두가지가 있습니다. <select>, <option> 드롭다운 리스트 박스를 생성하는 요소입니다. 아래처럼 사용합니다. <select>의 attribute들 multiple=\"multiple\": 사용자가 여러개의 <option> 요소를 선택할 수 있게 해줍니다. (컨트롤 or 커멘드 키 누르면서 눌러야 한다는 단점이 있음)size: 드롭다운 리스트에서 한번에 보여줄 수 있는 <option>의 개수를 정할 수 있습니다. <option>의 attribute들 value: 서버에 전송할 값을 정합니다.selected: 페이지가 로딩된 뒤 기본으로 선택되는 <option>을 지정합니다. 이 attribute가 사용되지 않았을 경우엔 기본적으로 첫번째 <option>이 선택됩니다. <fieldset> 자식 요소로 사용되는 form control들을 그룹화 할 수 있습니다. 폼 내용이 길어서 섹션을 나눌 필요가 있는 경우 유용하게 사용할 수 있습니다. 실제로 브라우저에서는 어떻게 구현되는지 보겠습니다.  <legend> <fieldset> 바로 아래에 위치하며, 폼 그룹의 목적을 나타내는 제목을 의미합니다. 반드시 <fieldset>의 첫번째 자식으로 사용해야 합니다. <button> 클릭 가능한 버튼을 나타내는 요소입니다. submit(default), reset, button 등의 type이 있습니다. <input type=\"submit\">과 <button>의 차이는 무엇일까요? <button> 요소는 <input> 요소보다 스타일을 적용하기 훨씬 쉽습니다. 또한 <input> 요소는 닫는 태그가 없어 value attribute에 텍스트밖에 넣을 수 없지만 <button>은 여러 자식 요소를 추가할 수 있는데다가, ::after나 ::before같은 CSS 가상 요소를 사용할수도 있습니다. 더 멋진 스타일이 필요하다면 <button> 요소를 쓰면 됩니다. <textarea> 여러 줄의 텍스트를 입력받을 수 있는 요소입니다. 본 블로그에서는 댓글 입력란이 <textarea> 요소입니다. cols attribute로 입력창의 넓이를, rows로 보여줄 입력 줄 수를 지정할 수 있습니다. <datalist> <select>와 <input> 요소의 역할을 섞어서 사용할 수 있도록 해주는 요소입니다. <input>요소의 list 속성을 이용해 <datalist> 요소의 id attribute와 연결해 사용합니다. 설명이 좀 복잡한데, 아래의 예시를 보면 이해됩니다.  보시다시피 option중 하나를 선택하거나, 직접 option을 추가할 수 있습니다. Tabular data 테이블은 글로만 읽어서는 익히기 어려운 개념이 많습니다. 직접 코드를 작성하고 결과를 보며 바꿔봐야 느낌이 옵니다. <table> 하나의 테이블을 정의하며, 컨테이너 요소입니다. <caption> 테이블의 제목, 설명을 의미하며 <table> 요소의 첫번째 자식으로 사용해야 합니다. <thead>, <tbody>, <tfoot> 각각 머리글, 본문, 바닥글을 의미하며 테이블의 레이아웃에 영향을 미치지 않습니다. 하지만 이렇게 묶어서 CSS를 사용해 스타일을 지정할 수 있습니다.  ",
    "date": "2022-09-07T17:09:00+09:00",
    "slug": "html-living-standard-part2",
    "title": "HTML Living Standard 2"
  },
  {
    "content": "CSS-in-JS와 서버 컴포넌트는 왜 공존하기 어려운지 알아보고, 이를 해결하기 위해 styled-components를 Tailwind CSS로 마이그레이션한 경험을 공유합니다. 이 글을 쓰게 된 계기 Next.js 13이 나온지도 벌써 11개월이 다 되어 갑니다. App Router가 정식으로 출시되면서 React 팀이 발표한 '서버 컴포넌트'를 손쉽게 사용해 볼 수 있게 됐습니다. 평소 개인 프로젝트에서 만큼은 프론트엔드 트렌드를 놓치지 않으려고 하기에, 이 블로그를 Next.js 13으로 올리면서 서버 컴포넌트를 적용해봤습니다. 마이그레이션 13으로의 마이그레이션을 처음 시도한 건 제 커밋 로그에 의하면 5월 말입니다. Next.js 12.2.4에서 13.4.3로 올렸네요. 사실 remote에 push만 안했을 뿐이지 그 전에도 수 차례 시도 했었는데, 그 때마다 실패했었습니다. 실패했던 가장 큰 이유는 '서버 컴포넌트'가 무엇인지 하나도 이해하지 못했기 때문이었습니다. 공식 문서를 조금 훑어보고 App Router의 Layout을 적용해 보고 싶어 /pages에 있던 파일을 막무가내로 /app으로 옮겨놓곤 '왜 안되지??' 하고 있었죠 😂 결국 한 방에 끝내려던 꿈은 접고 점진적 마이그레이션을 위해 Pages로 개발된 부분은 그대로 둔 채 App Router Incremental Adoption Guide를 따라 <Link />와 <Images />를 최신 API에 맞춰 바꿔주는 것부터 시작했습니다. (가이드가 정말 잘 되어 있으니 저 같은 상황을 겪고 계신 분들은 꼭 읽어보세요!) 그렇게 조금씩 조금씩 바꿔나갔습니다. 지금은 App Router로의 이주를 모두 마친 상태입니다. 마이그레이션과 그 이후 안정화까지, 5월 24일 ~ 6월 12일이니 총 3주 정도 걸렸네요. 다른 일은 아무것도 하고 있지 않던 때라 하루 종일 붙잡고 있었던 걸 감안하면 꽤 오래 걸린 것 같습니다. 마이그레이션 전이였던 지난 5월까지 제 블로그는 CSS-in-JS 스타일링 라이브러리 중 하나인 styled-components를 사용하고 있었습니다. _documents.tsx에서 커스텀 document를 정의해 서버 사이드에서 스타일시트를 생성해 내려주는 방식으로요. 이걸 그대로 App Router로 옮기려다 보니 문제가 많았습니다. 결국엔 Tailwind CSS로 스타일링 방법을 전면 교체하게 됐는데, 그런 결정에 도달하기까지 제가 알게된 내용들을 공유하고자 이 글을 쓰게 됐습니다. CSS-in-JS와 서버 컴포넌트 styled-components가 동작하는 과정 styled-components 라이브러리는 이런 과정을 거쳐서 동작합니다. styled.button이 호출되면 컴포넌트의 고유한 ID 를 생성합니다.const Button = styled.button`  padding: 0.5rem 1rem;  border-radius: 0.25rem;  color: white;  background-color: orange;  width: ${({ $buttonWidth }) => $buttonWidth}px;`;counter++;const componentId = hash(counter);Button의 tagged template을 평가합니다.const App = () => {  return <Button $buttonWidth={50}>버튼</Button>;};이 경우엔 $buttonWidth={50}을 줬으니 이렇게 될겁니다.const evaluatedCSS = `  padding: 0.5rem 1rem;  border-radius: 0.25rem;  color: white;  background-color: orange;  width: 50px;`;앞서 생성했던 컴포넌트 ID와 평가된 CSS를 가지고 해시를 생성합니다. 이 해시는 곧 className이 됩니다. 실제 구현 코드를 보면 djb2라는 hashing function을 쓰고 있습니다.const className = hash(componentId + evaluatedCSS);이렇게 생성된 className을 state로 저장합니다.const [generatedClassName, setGeneratedClassName] = useState(className);generatedClassName은 state이므로, 변경되면 바뀐 className을 가지고 컴포넌트가 리렌더링됩니다.stylis같은 CSS 프로세서를 사용해 스타일시트로 변환합니다.const styleSheet = stylis(`.${generatedClassName}`, evaluatedCSS);정확히 말하면 preprocessor인데, 이 친구 덕분에 nesting이나 vendor prefix 같은 기능을 사용할 수 있습니다.그 결과 styleSheet에는 이런 스트링이 들어갑니다./*  hashed-class에는 hash값이 들어갑니다.  여기에선 생략하도록 하겠습니다.*/.hashed-class {  padding: 0.5rem 1rem;  border-radius: 0.25rem;  color: white;  background-color: orange;  width: 50px;}생성된 스타일시트를 <style> 요소로 만들어 DOM에 주입(inject)합니다.<style data-styled-components>  .hashed-class {    padding: 0.5rem 1rem;    border-radius: 0.25rem;    /* ... */  }</style>마지막으로 generatedClassName을 가지고 컴포넌트를 렌더링합니다.const Button = ({ className, generatedClassName }) => {  return <button className={className + \" \" + generatedClassName}>버튼</button>;}; styled.button이 호출되면 컴포넌트의 고유한 ID 를 생성합니다. Button의 tagged template을 평가합니다. 이 경우엔 $buttonWidth={50}을 줬으니 이렇게 될겁니다. 앞서 생성했던 컴포넌트 ID와 평가된 CSS를 가지고 해시를 생성합니다. 이 해시는 곧 className이 됩니다. 실제 구현 코드를 보면 djb2라는 hashing function을 쓰고 있습니다. 이렇게 생성된 className을 state로 저장합니다. generatedClassName은 state이므로, 변경되면 바뀐 className을 가지고 컴포넌트가 리렌더링됩니다. stylis같은 CSS 프로세서를 사용해 스타일시트로 변환합니다. 정확히 말하면 preprocessor인데, 이 친구 덕분에 nesting이나 vendor prefix 같은 기능을 사용할 수 있습니다. 그 결과 styleSheet에는 이런 스트링이 들어갑니다. 생성된 스타일시트를 <style> 요소로 만들어 DOM에 주입(inject)합니다. 마지막으로 generatedClassName을 가지고 컴포넌트를 렌더링합니다. 많이 간추린 설명이지만, CSS-in-JS 라이브러리는 대략 이렇게 돌아갑니다. 이 모든 과정이 런타임때 이뤄지는 것이죠. CSS-in-JS와 서버 사이드 렌더링 다시 한번 정리하면, CSS-in-JS 라이브러리는 '클라이언트' 런타임에 스타일시트를 생성하고, <style> 요소로 DOM에 주입합니다. 이 방법을 서버 사이드 렌더링에 적용하려면 어떻게 해야 할까요? 일단 아무 생각 없이 그냥 적용하면 이런 문제가 발생할겁니다. 서버 사이드 렌더링이 일어나 마크업이 구성됩니다. 그러나, 스타일이 아직 생성되지 않은 상태입니다.클라이언트에서 서버로부터 SSR의 결과물을 받아 보여줍니다. 아직 스타일은 없고, 그저 마크업만 보여주고 있습니다.클라이언트에서 JS가 돌면서 런타임 스타일을 생성하고, DOM에 삽입됩니다. 이제서야 요소들이 스타일이 들어간 상태로 제대로 보이기 시작합니다. 즉, 2번과 3번 사이에서 이런 이상한 깜빡임이 발생하게 됩니다. 예전에 이 내용 이슈 해결 방법을 정리한 글을 올렸었는데, 그 글에 있던 이미지를 그대로가져왔습니다. 간단한 예시로 좀 더 보겠습니다. 주황색 박스를 하나 만들었습니다. 이대로 Next.js에서 돌리면 서버로부터 이런 HTML이 오게 됩니다. 서버사이드에서 렌더링은 되기 때문에(SSR) <div class=\"sc-beyTiQ bXfiY\"></div>가 들어가 있는게 보입니다. 그러나 스타일 코드는 없기 때문에 <div>에는 스타일이 적용되지 않은 상태입니다. 그 다음 클라이언트에서 JS가 돌면서 스타일이 생성되고, <style> 요소로 DOM에 들어갑니다. DEV 환경에서는 최종적으로 아래와 같은 형태가 됩니다. 이렇게 클라이언트 런타임을 통해 스타일이 주입돼 드디어 화면에 제대로 보이기 시작합니다. 스타일이 적용이 안되고 있다가, 코드가 돌고 스타일이 주입되면서 제대로 보이기 시작하니 위에서 보셨던 깜빡임이 발생하는 것입니다. Server Side Rendering때 style이 생성되지 않는 이유는 뭘까? 서버 사이드 렌더링때 마크업은 잘 만들어내면서, 스타일이 생성되지 않는 이유는 뭘까요? React.js를 이용한 SSR은 내부적으로 ReactDOMServer.renderToString을 사용합니다. 이 함수는 컴포넌트를 렌더링하고, 그 결과물을 문자열로 반환합니다. 최근엔 renderToPipableStream 같은 메서드로 바뀌긴 했는데, 이건 서버 컴포넌트와 관련된 얘기라 일단 넘어가겠습니다. 이 때, 헷갈리지 말아야 할 것은 ReactDOMServer.renderToString은 initial HTML을 생성한다는 점입니다. styled-components로 스타일이 생성되려면 1. DOM을 만들고 2. style을 inject하는 두 단계를 거쳐야 합니다. 그러나 ReactDOMServer.renderToString은 1번에서 멈추기 때문에 스타일이 생성되지 않는 것입니다. styled-components가 프로덕션 환경에서 스타일을 넣는 방법 이건 그냥 재밌는 사실이라 적어봤습니다. 이 글의 내용과는 관련 없습니다. 프로덕션 환경에선 클라이언트 사이드에서 JS가 실행된 후 이런 모습이 됩니다. 읭?? 스타일이 어디로 갔을까요? <style> 요소가 생기긴 했는데 내용물이 보이지 않습니다. Chrome Dev Tools로 확인해보면 분명히 저 스타일 요소로부터 스타일이 적용되고 있다고 하는데 말이죠. ??? 스타일이 적용되고 있긴 한데, 내용물이 보이지 않습니다. DEV 환경에서는 DOM API로 스타일 스트링을 주입하고, 프로덕션 환경에서는 CSSOM API로 스타일을 넣어서 그렇습니다. 이렇게 넣었던 스타일을 이런식으로 넣었다는 말입니다. 런타임 성능을 위해 최대한 압축하고자 이렇게 했다는데, 정말 성능 차이가 나는지는 모르겠지만 재밌는 방법인것 같아요. 실제 코드를 보고싶다면 여기 styled-components 스타일을 서버에서 미리 만들어 주면 안되나? 다시 서버 사이드 렌더링과 styled-components의 동작 과정에 대한 얘기로 돌아오겠습니다. 우리가 바라는 건 서버측에서 마크업을 만들면서 스타일도 같이 마크업에 담아주는 것입니다. 그래야 클라이언트에서 첫 DOM과 CSSOM 파싱을 할 때부터 스타일이 제대로 들어가 페이지가 깜빡이지 않을 테니까요. 물론 방법은 있습니다. 서버 사이드에서 미리 모든 스타일을 모아서 하나의 스타일시트를 만들고 SSR된 HTML에 쓱 껴넣어주면 됩니다. ServerStyleSheet는 collectStyles 메서드를 통해 서버사이드 렌더링이 진행될 때 스타일시트를 수집합니다. 이렇게 수집된 스타일시트는 getStyleElement 메서드를 통해 <style> 요소로 뽑아낼 수 있습니다. 이제 저 styleElement를 서버에서 넣어주도록 합니다. 이 방법을 Next.js에 적용한 예시는 링크를 참고해주세요. (이게 바로 제가 App Router로 마이그레이션 하기 전까지 사용하고 있던 방법입니다.) 그럼 바라던 대로 서버에서 이런 스타일 요소가 담긴 HTML을 보내줍니다. 참고로 이 경우엔 DEV 환경이든 프로덕션 환경이든 똑같습니다. 클라이언트측 런타임이 아니라 서버측 렌더링이 일어나는 시점에 스타일이 생성돼 initial HTML에 담아 주기 때문에, 이제 깜빡임 없이 페이지가 보이게 됩니다. hydration missmatch를 방지하기 위해 서버측 렌더링이 일어나는 시점에 생성되는 className은 클라이언트에서 렌더링을 했을 때 만들어내는 className과 같아야 합니다. 이를 보장하기 위해 styled-components에서 제공하는 babel plugin을 사용할 수 있습니다. 이 플러그인은 여러 환경에서 모두 같은 className hash가 생성되도록 도와줍니다. Server Component React.js 18 버전부터는 서버에서 async 컴포넌트를 만들어 쓸 수 있습니다. 즉, 클라이언트에서 백엔드 엔드포인트 등에 요청을 날려서 필요한 데이터를 받아오던 기존 방법 대신 서버에서 컴포넌트를 렌더링할 때 직접 데이터를 불러와 넣어줄 수 있게 되었습니다. 하지만 그렇다고 서버에서 데이터를 모두 불러올 때까지 기다릴 수는 없겠죠. 이 부분을 보완하기 위해 React는 서버에서 데이터를 불러오고 있는 컴포넌트에 대해서도 Suspense가 가능하게끔 구현됐습니다. 서버로부터 데이터를 stream으로 점진적으로 가져오는 건데, 일단 suspense된 부분을 fallback 컴포넌트로 채운 상태로 서버에서 먼저 보내주고, 데이터를 모두 불러왔다면 suspense된 부분을 갈아끼우는 <script> 요소를 보내주는 식으로 동작합니다. (앞서 잠깐 언급했던 renderToPipableStream 메서드가 이런 역할을 합니다.) 자세한 내용은 React 메인테이너의 discussion에 정말 잘 설명돼 있습니다. 클라이언트에서 데이터를 불러오는 것보다 서버에서 가져오는게 (구조에 따라 다르겠지만) 더 빠르고, 클라이언트가 다운로드 받아야 하는 JS 번들의 사이즈를 줄일 수 있는 등 서버 컴포넌트는 여러 장점을 가지고 있습니다. 서버 컴포넌트를 왜 써야 하는지에 대한 얘기는 이 정도로만 다루겠습니다. (더 많은 이야기는 이 글을 추천드립니다.) 한 편, 이런 특징 때문에 RSC(React Server Component)를 사용할 때는 몇가지 주의할 것이 있습니다. 서버 컴포넌트의 코드는 서버에만 머물고 클라이언트로 전달되지 않습니다. 따라서 클라이언트에서는 이 컴포넌트가 동작하지 않고, 이는 곧 클라이언트에서 리렌더링 되지 않는다는 의미가 됩니다. 클라이언트에서 리렌더링 되지 않는다는 부분 때문에 우리가 일반적으로 작성하던 컴포넌트들처럼 useState를 쓸 수 없고, useEffect도 쓸 수 없습니다. 뭐든 클라이언트에서 돌아가는 무언가가 있어야 한다면 쓸 수 없습니다. 심지어 이벤트 핸들러도 붙여주지 못합니다. 서버 컴포넌트는 이름 그대로 '서버에서만 돌아가는' 컴포넌트입니다. 반대로 우리가 기존에 사용하던 일반적인 컴포넌트는 '클라이언트 컴포넌트'라고 불리고 있습니다. 클라이언트 컴포넌트는 SSR 할 경우 서버에서도 돌아간다는 점을 생각해 보면 굉장히 헷갈리는 네이밍입니다. Server Component와 CSS-in-JS 여기까지 글을 읽어주신 분이라면 이제 제가 왜 styled-components를 비롯한 CSS-in-JS 라이브러리들이 서버 컴포넌트를 지원할 때까지 기다리지 않고 Tailwind CSS로 마이그레이션 할 수밖에 없었는지 감이 잡히실겁니다. styled-components는 런타임에 스타일을 생성하고, <style> 요소로 DOM에 삽입합니다. 이런 방식은 서버 컴포넌트와는 맞지 않습니다. 서버 컴포넌트는 클라이언트에서 돌아가는 어떤 것도 사용할 수 없기 때문입니다. CSS-in-JS는 서버 컴포넌트에서 동작하기엔 태생적인 문제를 가지고 있었던 것이죠. 이 문제때문에 잘 나가던 신흥 CSS-in-JS 라이브러리였던 Stitches가 maintain을 포기하기도 했습니다. And with React 18, the ecosystem has changed and made the future for runtime injection pretty murky. ...그리고 React 18에서 리액트 생태계가 바뀌면서 런타임 주입의 미래가 굉장히 불확실해졌습니다. - Stitches Issue #1144 중 한 술 더 떠서 styled-components는 스타일 테마를 주입하기 위해 내부적으로 React Context API를 사용하고 있습니다. ThemeProvider를 통해 주입된 테마를 styled.button의 tagged template에서 사용한 예시입니다. ThemeProvider의 실제 코드입니다. 간단하게 생겼죠? useContext 훅까지 써서 ThemeProvider를 여러 겹으로 쓸 수 있게 만들어 놓기도 했네요. 덕분에 테마가 바뀌어야 하는 곳에 대해 외부에서 편리하게 주입할 수 있는 구조를 가지고 있습니다. 서버 컴포넌트에서는 이 모든 기능을 사용할 수 없습니다. Context API 또한 클라이언트 런타임이 필요한 API이기 때문입니다. 대안은 없을까? 이 문제는 어떻게 해결할 수 있을까요? 답은 간단합니다. 런타임 이전에 스타일이 결정되면 됩니다. CSS Modules, Tailwind CSS, Utility Class Components Next.js 공식 문서에서는 CSS Modules와 Tailwind CSS 이렇게 두가지를 추천합니다. 제일 간단하고 빠르게 적용할 수 있는 방법입니다. 저는 제 개인적인 취향에 따라 Tailwind CSS를 선택했고, 조금이나마 편리하게 마이그레이션 하기 위해 styled-components와 최대한 비슷한 인터페이스를 가지도록 간단한 text concat 라이브러리를 직접 만들어 사용하고 있습니다. 그리고 styled-components를 사용하며 완전히 동적으로 스타일이 들어가던 부분은 모두 inline style로 바꿔주었습니다. Vanilla Extract, Panda CSS 등 CSS-in-JS의 장점을 가져가면서 정적(zero runtime)으로 스타일을 빌드하는 라이브러리들도 있습니다. 당근에서도 사용하고 있는 vanilla-extract나 chakra-ui 개발팀이 만든 panda 등이 가장 대표적입니다. 이 라이브러리들은 스타일 코드를 빌드타임에 생성합니다. 따라서 정적으로 빌드된 스타일을 HTML에 같이 넣어 클라이언트로 보내주기만 한다면 서버 컴포넌트에서도 충분히 사용할 수 있습니다. 아직 크게 주목받고 있진 못한 것 같지만, 서버 컴포넌트가 좀 더 많은 개발자에게 알려지고 사용된다면 국룰 스타일링 라이브러리 자리를 이 둘이 계승하지 않을까요? 😄 ",
    "date": "2023-09-26",
    "slug": "next-13-and-css-in-js",
    "title": "CSS-in-JS와 서버 컴포넌트"
  },
  {
    "content": "멋사 프론트엔드 스쿨에서 받은 과제를 어떻게 해결했는지 기록했습니다. 디자이너의 시안을 그대로 코드로 옮기는 실무에 가까운 일은 처음 해봤는데 정말 좋은 경험이었습니다. 1만 시간의 법칙 과제  디자이너가 작성해준 Figma 시안을 보고 반응형 웹을 구현하는 과제입니다. 혼자 구현해보고 멘토님의 피드백을 받아 고쳤는데 그 내용을 기록해보려고 합니다!! 레포지토리 결과물 (Github Pages로 배포됨) 결과물 전체적인 구조 HTML 우선 <head> 요소에서 <link rel=\"icon\" type=\"image/x-icon\" href=\"./img/favicon.ico\" />를 이용해 파비콘을 추가하고, 기본 PC 스타일, 모바일 환경을 위한 스타일을 따로 불러줍니다. <header>에는 <h1>이 들어가고, <body>는 세 개의 <section>들로 나눠줬습니다. modal 창을 위한 <div> 요소를 <footer> 요소 아래에 배치했습니다. 호준 강사님께서 추천하신 방법입니다. 마지막으로는 스크립트를 불러옵니다. CSS 전체적으로 스타일을 어떤식으로 구현해야 효율적일지 고민했습니다. 스타일링 수정이 편하도록 property를 적는 순서 컨벤션을 정해서 작성했습니다. 조금 귀찮은 컨벤션이지만 잘 정해서 작성하니 코드를 관리하는데에 큰 도움이 됐습니다.1. `position`, `display`, `align`, `visibility`2. `width`, `height`3. `margin`, `padding`, `border`, `box-sizing`4. `text-align`, `font`, `line-height`5. `color`, `background-color`6. `background-image`7. `animation`, `opacity` 등 기타CSS Selector를 어떤 식으로 작성할지 고민했는데, 일단 class 이름은 BEM을 따라서 정하기로 했습니다. 또한 단순히 class 이름만으로 요소를 선택하기 보다는 '어떤 요소에 대한 스타일인지' 추가적인 정보가 필요하다면 요소명을 붙여줬습니다. (예를 들어 .title 보다는 img.title을 사용하는 식)사용자의 선택에 따라 글씨 크기를 조정할 수 있도록 함과 동시에 유지보수성을 높이기 위해 font-size 등 일부 property는 px이 아닌 rem/em 단위를 사용했습니다.주요 색상을 CSS 변수로 선언해 추후 편리하게 색상을 변경할 수 있도록 했습니다.:root {  --main-color: #5b2386;  --second-main-color: #ffff;  --sub-color: #babcbe;  --point-color: #fcee21;  /* 위에서부터 차례로 보라색, 흰색, 회색, 노란색입니다. */} <body> 요소에 공통적인 스타일을 해주며 코드가 시작됩니다. CSS 파일 구조 index.css: PC 스타일을 주로 담으며, 모바일용 스타일시트를 제외한 다른 모든 스타일이 모이는 곳입니다.reset.css: User Agent Stylesheet를 리셋합니다.font.css: 웹폰트를 불러옵니다.tools.css: margin: auto;같이 자주 쓰이는 스타일을 class로 묶어둔 스타일시트입니다.general.css: <button>, <input> 요소처럼 컴포넌트 단위로 자주 쓰이는 스타일을 모은 곳입니다.mobile.css: 모바일용 스타일이 담깁니다. reset.css: User Agent Stylesheet를 리셋합니다.font.css: 웹폰트를 불러옵니다.tools.css: margin: auto;같이 자주 쓰이는 스타일을 class로 묶어둔 스타일시트입니다.general.css: <button>, <input> 요소처럼 컴포넌트 단위로 자주 쓰이는 스타일을 모은 곳입니다. 모바일용 스타일 코드는 대부분이 크기를 조절하거나 margin을 바꾸는 코드여서 여기에선 특별한 경우가 아니라면 설명하지 않겠습니다. 실제 코드를 더 자세히 보고싶다면 레포지토리를 확인해주세요! tools.css <header> 요소 <h1> 요소 구현 결과  HTML <img> 요소의 srcset, sizes attribute를 이용해 Viewport 크기에 따라 유동적으로 이미지를 로드하도록 구현했습니다. 타이틀 이미지의 alt를 \"1만 시간의 법칙 타이틀\"로 할지 \"1만 시간의 법칙\"으로 할지 고민하다가 스크린 리더를 감안해 이렇게 결정했습니다. 배경이 되는 clock.png를 담은 <img> 요소에는 alt를 비워서 스크린 리더가 무시하도록 했습니다. CSS 중첩은 이렇게 처리하고, 이미지의 가운데 정렬은 .centering { margin: 0 auto; }로 줬습니다. 타이틀 아래(under)에 위치하는 시계 이미지에 .img-flow-root { display: flow-root }를 줘서 Inline element로서 baseline에 영향받는 부분을 없앰과 동시에 .centering 스타일이 유효할 수 있도록 해줬고, 로고에 해당하는 .title__img는 position: absolute;에 .centering을 줘서 정렬했습니다. 이미지에 position: absolute;를 주면 display property는 자동으로 block으로 바뀝니다! 그래서 별다른 스타일을 추가로 주지 않아도 .centering에 영향받아 가운데 정렬이 가능한거죠. 멘토님 Feedback  A. srcset, sizes 사용하신 것과 alt를 \"1만 시간의 법칙\"로 설정하신 것 잘하셨습니다! \"1만 시간의 법칙\" 타이틀 이미지 뒤에 배치되는 시계 이미지는 img 태그가 아닌 h1의 background로 넣거나가상 요소를 통해 넣어도 될 것 같습니다. 시계 이미지가 어떤 정보를 주기 위한 요소라기 보단 디자인(스타일)적인요소로 존재하는 걸로 보이기 때문입니다 :) /> Q. 수업중에 호준님께서는 정적이지 않은 요소라고 보셨는데 (로고는 때에 따라 바꿀 수 있다고 생각하신것 같습니다) 그런 경우에도 background-image로 넣어도 될까요? /> A. 대표님이 말씀하신 것처럼 img 태그와 background 속성을 사용하는 기준을 이 이미지 요소가 동적이냐정적이냐로 나눌 수도 있습니다. 저는 정적, 동적도 고려하지만 이 이미지가 사용자에게 꼭 필요한 정보인가? 디자인적인 요소는아닌가?를 더 고려해서 작업하는 편입니다. 이 부분은 개인에 따라서 다를 수 있겠지만 저는 사용자에게 필요한 정보는 \"1만 시간의 법칙\" 타이틀이미지이고, 겹쳐진 시계 이미지는 정보를 준다기보다는 디자인적인 요소로 판단하여 말씀드렸습니다.ㅎㅎ (타이틀 이미지 -> img 태그 / 시계 이미지 -> background)  요약하면 로고 뒤의 시계 이미지를 background-image로 표현할지 제가 원래 했던 것처럼 <img> 요소를 중첩시켜 표현할지의 문제였습니다. 이호준 강사님: 로고 전체가 백엔드에서 조작이 가능한 동적인 요소로 만들어야 한다고 판단한다면 <img> 요소로 넣어야 한다는 의견김유진 멘토님: 사용자에게 필요하지 않은 정보로 보이는 부분은 background-image로 판단한다는 의견 개인적인 판단에는 로고가 바뀐다면 배경 이미지도 동시에 바뀔거라고 생각해 일단은 그대로 두었습니다. 실무였다면 디자인/PM과 의논해 해결할 수 있는 부분이라고 생각합니다. 아예 로고/배경을 두 파일로 나눠 넣지 말고, 배경 이미지까지 하나의 이미지로 합쳐서 로고로 넣는것도 깔끔한 해결책이 아닐까 생각합니다. <main> 요소 격언 <section> 구현 결과  HTML 우선 격언과 정의 부분을 하나의 섹션으로 봤습니다. 시멘틱을 위해 <h2>요소를 넣고 .blind 클래스로 가려줬습니다. 격언은 <blockquote> 요소로 처리했습니다. <p>요소 안에서는 1만 시간의 법칙을 설명하고 있으므로 <dfn> 요소를 한번 사용해봤습니다. 줄바꿈을 어떻게 처리하는게 좋을지 고민하다가 <br> 요소를 썼지만, 스타일을 통해 구현하는것도 좋은 방법이 될 것 같습니다. (그래서 아래에서 다른 방법을 사용해보기도 합니다.) CSS .quote-wisdom의 경우 수업중에는 폰트 로드 시간 문제로 많이 쓰이지 않는 폰트이니 이미지로 처리하는 것을 고려해봐야 한다 해주셨지만 우선은 폰트를 로드해 Text node로 구현했습니다. modal에서도 쓰이는 서체이므로 앞으로 더 사용될 수 있는 폰트라고 봤습니다. <blockquote>는 Block-level element이므로 .text-centering { text-align: center; }를 줘서 Text node의 가운데 정렬을 구현했습니다. p.rule-definition에서는 큰따옴표 이미지를 background-image로 표현했습니다. 입력 <section> 구현 결과  HTML 우선 두 <input> 요소들은 각각 한 줄씩 그 주위 텍스트들과 함께 <p> 요소로 묶었습니다. 둘 다 required attribute를 부여해서 반드시 입력해야 하게끔 유효성을 검사합니다. 몇 시간씩 훈련할지 입력하는 두번째 <input> 요소에는 pattern=\"[0-9]*\\.?[0-9]*.*\" attribute를 넣어서 시간이 제대로 입력됐는지 정규표현식으로 유효성을 확인하도록 했습니다. 모바일에서의 개행을 고려해 특정 Text node들은 <span>으로 묶었습니다. 노란 입력 제출 버튼은 페이지 내 로직의 작동을 일으키는 역할을 하므로 <button> 요소를 사용했습니다. (<button>의 default type은 submit이므로 타입을 따로 지정하지는 않았습니다.) 이 부분에서 손가락 이미지를 어떻게 구현할까 고민하다가 <button>과 <img>를 감싸는 <div>를 추가해 손가락 <img>에 position: absolute;를 부여, 위치를 조정하고자 했습니다. CSS CSS에서 복잡한 부분은 없었지만, .rule-form__btn과 .click-icon의 위치를 이렇게 표현하는게 과연 맞는 선택일까 고민이 됐습니다. 두가지 종류의 interactive element style 앞서 루트 요소에 색을 CSS 변수로서 선언한 점을 감안해 클래스명을 지었습니다. CSS (Mobile)  개행이 일어나는 부분 처리 앞서서는 <br> 요소로 개행을 구현했는데, <span>으로 묶은 요소에 display: block;을 줘 개행하는것도 좋은 방법인 것 같습니다. interactive elements들 스타일 모바일에서는 둥글둥글했던 interactive element가 네모난 모양으로 바뀌는데, 모바일용 스타일이 적용되는 클래스를 따로 정의해줬습니다. mobile.css가 더 나중에 로드되도록 <link> 요소를 배치하고 클래스를 미리 부여해서 break point를 넘어서면 모바일의 스타일이 적용됩니다. break point를 780px로 잡은 이유는 PC 화면에서 가장 width가 긴 부분이 약 760px정도 됐기 때문입니다. 멘토님 Feedback  A. 각 input에 label이 없습니다. 두번째 input은 type을 number가 아닌 text를 사용하신 이유가 있을까요? 숫자만 입력되도록수정하시거나 숫자가 아닌 다른 값이 입력되면 제출되지 않도록 하는 작업이 추가로 필요해보입니다.현재는 문자를 입력할 경우 오류가 발생합니다.(\"5시간\"과 같이 숫자가 앞으로 오는 경우는 됨.) 클릭 아이콘을 absoulte를 주기 위해서 div를 사용하신거라면 css에서 버튼의 가상요소로 넣는 방법도고려해 보시면 좋을 것 같네요. Q. label 요소로 넣을만한 내용이 무엇일지 고민되는데 label을 .blind 클래스 스타일로 가릴경우 스크린리더가읽을 때 이상하게 들릴 것 같은데 괜찮을까요?! /> A. 흠 확실히 스크린리더가 읽을 때 좀 이상하겠네요..^_ㅠ 각 p태그의 첫번째 자식으로 label을 넣어도 될것 같긴하지만,,이것도 좀 이상하게 들릴 수도 있을 것 같아요..! 이 피드백은 참고만 해주세요..ㅎㅎ  우선 <label>을 어떻게 넣을 것이냐...는 굉장히 까다로운 문제인 것 같습니다. 이렇게 <label>을 무엇으로 지정할지 명확하지 않은 상황에서는 어떤 방법이 좋을지 차차 고민해 봐야겠습니다. 우선은 스크린 리더로 테스트 해본 결과 (개인적인 생각에는) 그대로 가도 문제 없어보여서 건들지는 않았습니다. 두 번째 <input>의 type을 text로 한 이유는 예시가 '5시간' 이였기 때문입니다. 정규표현식으로 소수를 포함한 숫자만 빼오고 뒤에 위치하는 '시간' 텍스트는 무시하도록 했는데, 유진 멘토님께서 '시간5'처럼 텍스트를 앞에 쓸 경우엔 오류가 발생함을 짚어주셨습니다. 정규표현식은 공부를 더 열심히 해봐야겠습니다. .click-icon 부분은 구현을 너무 더럽게 한게 아닐까 고민이었는데 멘토님께서 딱 집어 좋은 대처방안을 제시해주셨습니다. Resolve 조언 주신대로 두 번째 <input>의 type을 number로 변경했습니다.<p class=\"rule-form__txt\">  <span>그래서 앞으로 매일 하루에</span  ><input    class=\"rule-form__input input-main-colored rule-form__input-hours-js\"    type=\"number\"    placeholder=\"예)5시간\"    required  />시간씩 훈련할 것이다.</p>클릭 아이콘을 CSS의 pseudo element로 변경했습니다.<button class=\"rule-form__btn btn-point-colored btn-squared-mobile\">  <span>나는 며칠 동안 훈련을 해야</span> 1만 시간이 될까?</button><!-- img 요소 삭제 --><!-- 손가락 모양은 CSS 가상 요소로 넣습니다. -->.rule-form__btn {  margin-top: 115px;  position: relative;}.rule-form__btn::after {  content: url(../img/click.png);  position: absolute;  left: calc(100% + 7px);  top: 14px;} 조언 주신대로 두 번째 <input>의 type을 number로 변경했습니다. 클릭 아이콘을 CSS의 pseudo element로 변경했습니다. 결과 확인 <section> 구현 결과  HTML <button>과 <a> 모두 Inline elements이므로 text-align: center;를 이용해 가운데 정렬하기 위한 <div> 요소를 추가했습니다. <button>들의 좌 우측에 각각 margin:auto;를 주는것도 방법이 될 수 있겠지만 이게 더 간편하다고 생각했습니다. 과제를 하면서 이렇게 CSS를 줄일지, 마크업을 줄일지 고민이 되는 부분이 많았습니다. \"훈련하러 가기\"는 modal 창을 띄우고, \"공유하기\"는 페이지의 URL을 복사하는 <button> 요소로 봤습니다. \"공유하기\" <button>에서는 data-copiedlink라는 data-* attribute를 추가해 URL을 넘기도록 했습니다. 이걸 JS에서 받아서 사용할겁니다. CSS section.result에서 line-height property의 값을 크게 줘서 사용자가 긴 목표를 입력했을 경우에도 적당한 줄간격을 가지도록 한 부분이 포인트입니다. .result__txt에 max-width를 준 부분도 눈여겨 볼만 합니다. 멘토님 Feedback  A. 버튼 정렬을 div로 묶어서 작업하신 것 잘하셨습니다! 저도 그렇게 묶었을 거에요! ㅎㅎ 편한 방법사용하십쇼  🙌🙌 좋은 선택이었던 것 같아요ㅎㅎ <footer> 요소 위니브 로고와 저작권 정보 부분 구현 결과  HTML CSS modal 창 구현 결과  뒷 배경에 블러처리를 해줬습니다! HTML .cheerup-modal__wrapper가 화면 전체를 뒤덮게 해서 거기에 블러처리를 하려고 했습니다. \"종료하고 진짜 훈련하러 가기\" <button> 요소가 위니브 홈페이지로 가는 링크라고 생각하고 뒷 배경을 누르면 modal 창이 닫히게 하려고 했는데, 모바일에서는 뒷배경이 거의 남지 않는 문제가 있어 modal창 자체를 누르면 닫히게 했습니다. 실무였다면 디자이너와 협의해 닫기 버튼을 추가하는 등의 시도를 해도 좋을 것 같습니다. CSS .cheerup-modal__wrapper가 화면 전체를 감싸도록 했으므로 .cheerup-modal에서는 position: fixed;와 top, left를 50%로 줘서 .cheerup-modal의 좌상단을 Viewport의 가운데로 맞춘 후, transform proprerty를 이용해 창 자체가 가운데로 올 수 있도록 합니다. JS에서 .activated 클래스를 부여하거나 삭제해 애니메이션을 구현하고자 했습니다. 멘토님 Feedback  디자이너와 협의해 닫기 버튼을 추가하는 등의 시도를 해도 좋을 것 같습니다. -> 좋은 방법입니다!- 실제 1만시간의 법칙 사이트에서는 \"종료하고 진짜 훈련하러 가기 GO!GO!\"가 닫기 버튼인데 다른링크를 연결하셨더라구요. 그래서 현재 닫기 버튼이 없는 상황인데 모달에 닫기 버튼을 추가하는 것 좋은방법인 것 같습니다. :)  멘토님 HTML, CSS 총평  A. 전체적으로 마크업 잘 작성하셨네요! ㅎㅎ 용도, 목적에 맞는 태그를 적절히 잘 사용하셨습니다 :) css도 정말 잘하셨어요! ㅎㅎ css에서는 적용된 속성 중 중복된 건 없는지 또는 동일한 동작을 다른 방법으로할 수는 없는지 고민해보면 더 공부가 될 것 같습니다. (예: text-align, transform 등의 속성을 사용해서 정렬하는 걸 flex를 사용해서 해보기)  JavaScript 로직이 필요한 부분의 구현을 위해 간단한 스크립트를 작성했습니다. 참고로 JS상에서 접근이 필요한 요소들에는 ~-js 클래스를 추가해 스타일을 위한 클래스명이 바뀌더라도 로직은 작동할 수 있도록 했습니다. 요소를 가져오기 지금 보니까 너무 부끄러운 코드인데,,, 우선 멘토님 피드백을 보겠습니다. 멘토님 Feedback  A. querySelector를 사용하면 배열 접근을 추가로 하지 않아도 되는데 getElementsByClassName를 사용하는이유가 궁금합니다.(이렇게 하면 안된다는 얘기는 아닙니다.)  실수노트에 추가한 내용... 처음에는 각 요소에 id를 부여해서 접근하고자 했기에 코드를 getElementById 메소드를 이용해 작성하고 있었는데 그걸 클래스로 접근해야겠다 생각하고 바꾸다가 비슷하게 생긴 getElementsByClassName에 꽂혀버렸기에 벌어진 일입니다. Resolve 아래 코드로 얼른 수정했습니다. EventListener 각종 이벤트 리스너들을 추가하는 부분입니다. $modalWrapper 요소에 PC와 모바일에서의 스크롤 이벤트를 방지하는 코드를 추가했습니다. modal 창을 뚫고 스크롤이 되면 안되니까요! 이벤트 버블링은 막았지만 캡처링을 건들지는 못해서 modal이 길어질 경우 modal 자체의 스크롤이 안됩니다. 추후 더 좋은 방법이 있을지 고민 해봐야겠습니다. 입력 <section>, 결과 <section> 멘토님 Feedback  A. 현재 페이지 접속시 처음부터 결과가 나오게 되어 있더라구요! 모달에서 display 속성을 사용했던것처럼 이 부분도 처음에는 안 보이도록 작업해주시면 좋을 것 같습니다. 보통 form에서 제공하는 기본적인 유효성 검사를 사용하더라도 js에서 추가적으로 유효성 검사가필요합니다. +) 추가로 제출 후 input이 초기화되면 좋을 것 같아요! ㅎㅎ  페이지 접속시에는 가렸다가 submit 이벤트가 유효성 검사를 통과했을 때 보이게 하는건 유진 멘토님께서 말씀하신 것처럼 추가로 구현하겠습니다. 유효성 검사는 HTML에서 하니 같은 로직을 JS에서도 구현하는건 너무 중복되는게 아닌가 고민됐습니다. 하지만 유진 멘토님 말씀대로 안정적인 서비스를 위해 '유효성 검사' 만큼은 여러번 해도 지나치지 않다고 생각을 바꾸려고 합니다. Resolve tools.css 아래에 나올 modal과 지금 수정하고 있는 결과 <section> 요소처럼 가려져 있다가 나타나는 요소들에 .transition 클래스를 부여한 후 .activated, .deactivated 클래스를 작동 상황에 따라 부여하겠습니다. 결과를 보여주는 <section>에 .deactivated 클래스가 부여돼 있다면 .activated로 toggle합니다.submit 이벤트가 일어나면 <input>을 비워주는 코드를 추가했습니다.openModal(), closeModal() 함수는 필요 없어졌으므로 삭제했습니다. modal 창 앞서 수정한 코드에 이어서 수정한 내용입니다. 간단하게 \"훈련하러 가기 GO!GO!\" 버튼 혹은 modal을 감싸고 있는 wrapper <div>를 누르면 toggleActivation($modalWrapper)를 호출하도록 해 구현했습니다. 결과 <section>에서 '공유하기' 버튼 Clipboard API는 이번에 처음 알게 됐는데 재밌었습니다ㅎㅎ 멘토님 Feedback  유진님 A. Clipboard API 사용하신 것 잘하셨습니다! 예외처리도 추가하면 좋을 것 같아요! 현재 url을 가져오는 방법이 있는데 dataset을 가져오는 방식으로 구현하신 이유가 궁금합니다. 물론이 방법도 괜찮습니다 :) 시우 A. 추후에 공유하기 버튼이 단순 URL을 복붙하기 보다 유저가 결과를 공유할수도 있게 하려면 어떻게해야할까를 고민하다가 그렇게 짜게 됐습니다,,ㅎㅎㅎ 유진님 A. 아하! 그러셨군요! 그럼 sns 공유, 이미지 공유 등 여러가지 공유하는 방법에 대해서알아보시는 것도 추천드려요! ㅎㅎ  dataset을 가져오는 방식이란 일종의 '커스텀 attribute'로, data-*꼴로 넣을 수 있습니다. 예를 들어 저는 1만 시간의 법칙 페이지에서 이런 코드를 사용했습니다. 유진님께서 피드백 주신대로 단순 링크 복사보다는 더 멋진 무언가를 구현하면 좋을 것 같아요. 이건 추후에 더 붙여보는걸로 하겠습니다! 멘토님 JS 총평  함수명을 봤을 때 어떤 역할을 하는지 명시적으로 알 수 있어서 좋습니다! 그리고 param을 사용해서주석을 잘 작성해줘서 흐름 파악하는데도 좋았습니다.:)  멘토님 보기 좋으시게 JSDoc을 약간 작성했는데 칭찬받아서 기분이 좋네요 😆 마무으리 멘트 이 글 처음 쓰기 시작했을 때는 이렇게 시간이 오래 걸릴줄 몰랐는데 생각보다 엄청 오래 걸렸네요 😅 그래도 처음으로 디자이너님의 시안을 바탕으로 웹페이지 개발을 해봤는데 너무너무 재밌었습니다. 멘토님의 코드리뷰를 받고 고쳐나가는 과정도 정말 좋았구요. 이렇게 열심히 정리하고 보니 뿌듯하기도 하고, 코딩 과정에서 어떤 부분이 미숙했는지도 다시 한번 곱씹어 볼 수 있었습니다! ",
    "date": "2022-09-15",
    "slug": "10000-hour-rule-responsive-web",
    "title": "1만 시간의 법칙 반응형 웹 개발 및 피드백"
  }
]
