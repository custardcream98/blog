---
title: "리액트 전역 상태 관리 라이브러리 개발해보기"
excerpt: "Context API와 전역 상태 관리 라이브러리에 대해 고찰해보고 직접 구현해봅니다."
date: "2023-11-19"
category: ["React.js"]
---

> Context API와 전역 상태 관리 라이브러리에 대해 고찰해보고 직접 구현해봅니다.

# 전역 상태 관리에 사용되는 여러 방법

리액트를 사용하다보면 상태를 전역적으로 관리해야하는 경우가 생깁니다. 이럴 때 사용할 수 있는 방법은 크게 두가지가 있습니다.

1. state, props, Context API 등의 internal store를 사용하는 방법
2. Redux, MobX 등의 external store를 사용하는 방법

## '전역 상태 관리'에 Context API를 사용하기 얼마나 까다로운가

Context API는 상태 관리를 위한 기능이라기 보다는 의존성 주입을 위한 API지만, 외부 라이브러리의 도움 없이 간단하게 전역(저는 전역보다는 '국지'라는 단어를 쓰고 싶습니다.) 상태 관리를 구현하기에 좋은 도구입니다.

```jsx
const DEFAULT_USER = {
  name: "unknown",
  age: 0,
};

const UserContext = React.createContext({
  ...DEFAULT_USER,
  setUser: () => void, // setter를 context에 담습니다.
});

const UserContextProvider = ({ children }) => {
  const [user, setUser] = React.useState(DEFAULT_USER);

  const value = {
    ...user,
    setUser,
  };

  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
};
```

위와 같이 Context Provider로 감싸진 컴포넌트는 Context를 통해 상태를 사용할 수 있습니다.

```jsx
const UserDisplay = () => {
  const { name, age, setUser } = React.useContext(UserContext);

  return (
    <div>
      <p>{name}</p>
      <p>{age}</p>
      <button onClick={() => setUser({ name: "John", age: 20 })}>Set User</button>
    </div>
  );
};
```

다만, Context API는 '잘 사용하려면' 약간 까다롭습니다. 위의 `UserContextProvider`에서 `value` 객체는 매 렌더링마다 새로 생성됩니다. Context Provider는 얕은 비교만 수행하기 때문에 해당 컨텍스트의 값이 바뀌지 않았더라도 컨텍스트를 참조하는 모든 컴포넌트가 리렌더링 됩니다. 따라서 `UserContextProvider`의 부모 컴포넌트가 리렌더링되면 관련 없는 컴포넌트의 불필요한 리렌더링이 발생할 수 있습니다.

이러한 이유로, Context Provider에 전달되는 값이 원시값이 아니라면 `React.useMemo`를 사용해 값을 캐싱하는 것이 좋습니다.

```jsx
const UserContextProvider = ({ children }) => {
  const [user, setUser] = React.useState(DEFAULT_USER);

  const value = React.useMemo(
    () => ({
      ...user,
      setUser,
    }),
    [user],
  );

  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;
};
```

또는 `React.memo`를 써서 Context Provider 자체의 리렌더링을 막는것도 방법입니다.

그러나 문제는 여기서 끝나지 않습니다. 앞서 언급한대로 Context API는 컨텍스트의 값이 바뀌면 해당 컨텍스트를 참조하는 모든 컴포넌트를 리렌더링 합니다. 그래서 컨텍스트의 값 중 일부 프로퍼티만을 사용하는 경우 그 프로퍼티의 값이 바뀌지 않아도 리렌더링은 피할 수 없습니다.

```jsx
const UserNameDisplay = () => {
  const { name } = React.useContext(UserContext);

  return (
    <div>
      <p>{name}</p>
    </div>
  );
};
```

위 컴포넌트는 `UserContext`에서 주는 값 중 `name`만을 사용하고 있음에도 불구하고, `age`만 변경되어도 리렌더링 됩니다.

따라서, Context API에 값이 바뀔 수 있는 object value를 사용할 경우 최대한 컨텍스트를 쪼개써야 합니다.

```jsx
const UserNameContext = React.createContext({
  name: "unknown",
});

const UserAgeContext = React.createContext({
  age: 0,
});

const UserSetterContext = React.createContext({
  setUser: () => void,
});
```

극단적으로 가면 이렇게도 쪼갤 수 있겠죠. 더 가면 원시값 자체만을 컨텍스트 값으로 쓸 수도 있을거고요.

이렇게 Context API만을 사용하여 '전역' 상태를 관리하는 데는 여러 제약이 있습니다. 그래서 대부분의 프로젝트는 Recoil이나 Redux, zustand 등의 외부 라이브러리를 사용합니다.

> 제 생각에 Context API는 이름 그대로 어떤 컴포넌트가 참조할 수 있는 컨텍스트라고 접근하는게 좋을 것 같습니다. 특정 상태나 값이 어떤 스코프로 제한되면서도, 그 스코프 안에서는 자유롭게 사용할 수 있는 값이라고 생각합니다. 해당 컴포넌트가 필요로 하는 의존성을 모아둘 수 있으므로 코드의 가독성이나 테스트 용이성을 높여주는 도구이기도 합니다.

# 전역 상태 관리 라이브러리를 직접 만들어보자

저는 항상 전역 상태 관리 라이브러리가 대체 어떻게 동작하는걸까 궁금했습니다. 그래서 이번 기회에 전역 상태 관리 라이브러리를 직접 구현해보면서 그 동작 원리를 이해하고자 했습니다. Recoil의 API와 코드를 참고했으며, 실제 동작 원리는 다를 수 있습니다.

이름은 `very-simple-store`입니다.

[구경하기](https://library.shiwoo.dev/)

이하의 내용은 실제 구현된 코드를 설명을 위해 단순화한 것입니다.

> 제가 이해한 만큼만을 가지고 개발한 라이브러리입니다. 혹시 잘못된 부분이 있다면 알려주시면 감사하겠습니다.

## 전역 상태를 어디에 어떻게 담고 관리할 것인가

전역 상태는 온전히 라이브러리에 의해서만 관리될 수 있어야 하므로, `useRef`를 사용해 리액트 외부에 위치하도록 합니다. 이 객체를 `store`라고 부르겠습니다.

```js
const store = React.useRef({
  state: new Map(),
});
```

이 `store`는 Context API를 통해 리액트 컴포넌트들이 공유할 수 있도록 합니다.

```jsx
const StoreContext = React.createContext(store);

const StoreRoot = ({ children }) => {
  const store = React.useRef({
    state: new Map(),
  });
  return <StoreContext.Provider value={store}>{children}</StoreContext.Provider>;
};
```

앱의 루트에 `StoreRoot`를 감싸주면 이 앱 어디에서든 접근할 수 있는 전역 상태가 준비됩니다.

```jsx
const App = () => {
  return <StoreRoot>{/* ... */}</StoreRoot>;
};
```

## 전역 상태가 바뀔 때 컴포넌트를 어떻게 리렌더링할 것인가

전역 상태가 바뀌면 그 상태를 사용하는 컴포넌트만을 리렌더링 해야합니다. 이를 위해서는 두 가지가 필요합니다.

1. 특정 전역 상태에 '구독'하는 기능
2. 특정 전역 상태가 바뀌었을 때 '구독'한 컴포넌트를 리렌더링하는 기능

### 특정 전역 상태에 '구독'하는 기능

`very-simple-store`에서는 각각의 전역 상태를 하나의 노드로 보고, `StoreNode`라는 이름을 붙였습니다.

구독하는 컴포넌트를 관리하기 위해 이런 프로퍼티들을 가지도록 했습니다.

```ts
type StoreNode<T> = {
  key: string;
  value: T;
  subscribers: Set<() => void>;
  subscribe: (callback: () => void) => () => void;
  emit: () => void;
};
```

이제 `StoreNode`를 생성하는 함수인 `addStoreNode`를 만들어봅시다.

```ts
const addStoreNode = <T>(key: string, initialValue: T): StoreNode<T> => {
  const subscribers = new Set<() => void>();
  const value = initialValue;

  const subscribe = (callback: () => void) => {
    subscribers.add(callback);

    return () => {
      subscribers.delete(callback);
    }; // unsubscribe 함수를 반환합니다.
  };

  const emit = () => {
    subscribers.forEach((callback) => callback());
  };

  return {
    key,
    value,
    subscribers,
    subscribe,
    emit,
  };
};
```

이렇게 하면 아래와 같이 간편한 API가 완성됩니다.

```ts
const storeNode = addStoreNode("userName", "Shi Woo, Park");

const callback = () => {
  console.log("userName이 바뀌었습니다.");
};

// 전역 상태에 구독하기
const unsubscribe = storeNode.subscribe(callback);

// 전역 상태 값 변경 후 구독자들에게 알리기
storeNode.emit();

// 구독 취소하기
unsubscribe();
```

### 특정 전역 상태가 바뀌었을 때 '구독'한 컴포넌트를 리렌더링하는 기능

리액트에서 리렌더링을 트리거하는 가장 간단한 방법은 `setState`를 호출하는 것입니다. 저는 제가 원하는 타이밍에 리렌더링을 일으키고자 하는 것이므로, 강제로 가짜 `setState`를 호출하는 Hook을 만들었습니다.

```ts
const useForceUpdate = () => {
  const [, setState] = React.useState({});
  return React.useCallback(() => setState({}));
};
```

> 대부분의 라이브러리는 사실 리액트에서 제공하는 `useSyncExternalStore` 훅을 사용하고 있습니다. 여기에서는 데이터 흐름을 직접 제어하며 원리를 이해하기 위해 강제로 리렌더링을 일으키는 훅을 사용합니다.

이제 저 훅을 사용해 `StoreNode`의 값을 사용하도록 도와주는 `useStoreNodeGetter`를 만들어봅시다.

```ts
const useStoreNodeGetter = <T>(storeNode: StoreNode<T>): T => {
  const forceUpdate = useForceUpdate();
  const storeRef = React.useContext(StoreContext); // 전역 상태가 담기는 객체 컨텍스트

  React.useEffect(() => {
    const store = storeRef.current;

    if (!store.state.has(storeNode.key)) {
      // 아직 전역 상태로 등록되지 않은 노드라면
      // 지금 추가해줍니다.
      store.state.set(storeNode.key, storeNode);
    }

    const unsubscribe = storeNode.subscribe(forceUpdate);

    return unsubscribe;
  }, [storeNode, forceUpdate, storeRef]);

  return storeRef.current.state.get(storeNode.key)?.value ?? storeNode.value;
};
```

`forceUpdate`가 실행되는 순간 이 Hook을 사용중인 컴포넌트는 리렌더링 됩니다. 19번째 줄에서 리턴되는 값은 리렌더링마다 다시 평가되므로 자연스럽게 최신 상태를 가져올 수 있습니다.

이번에는 `StoreNode`의 값을 변경하는 setter를 만들어주는 `useStoreNodeSetter`를 만들어봅시다.

```ts
const useStoreNodeSetter = <T>(storeNode: StoreNode<T>): ((newValue: T) => void) => {
  const storeRef = React.useContext(StoreContext);

  return React.useCallback(
    (newValue: T) => {
      const store = storeRef.current;

      if (!store.state.has(storeNode.key)) {
        store.state.set(storeNode.key, storeNode);
      }

      const existingNode = store.state.get(storeNode.key) as StoreNode<T>;

      existingNode.value = newValue;
      existingNode.emit(); // 구독자들에게 알립니다.
    },
    [storeNode, storeRef],
  );
};
```

## 구현된 추가 기능

이상으로 핵심 로직 설명을 마칩니다. `very-simple-store`에서 제공하는 기능은 이 외에도 조금 더 있습니다.

- `useStoreSelectorNode`: selector를 사용할 수 있도록 도와주는 Hook입니다. 의존하는 `StoreNode`가 바뀔때만 selector를 실행하고, 값이 변경되지 않으면 리렌더링하지 않는 간단한 최적화도 적용되어 있습니다.
- 비동기 selector: 위 Hook에 이어서 selector를 비동기 함수로 선언할 수도 있게끔 구현했습니다. `fetch` 등을 통해 외부 API를 호출하는 경우 유용하게 사용할 수 있습니다.
- `useCurrentStoreState`: 현재 store 객체 전체를 확인할 수 있는 Hook입니다. 이를 위해 store 자체에서도 subscribe 기능을 제공하도록 했습니다.
- 일부 코드의 고도화: `Store`와 관련된 로직은 모두 `Store` 객체 내부에 캡슐화 하고, `Store` 객체를 사용하는 컴포넌트들은 `Store` 객체의 메서드를 호출하는 방식으로 구현했습니다. 이렇게 하면 `Store` 객체의 내부 구현이 바뀌어도 사용자에게는 영향을 주지 않습니다.

실제 코드를 보고 싶으시다면 [여기](https://github.com/custardcream98/custard-library/tree/main/packages/very-simple-store)를 참고해주세요.
