---
layout: post
title: Jekyll 블로그에 검색기능 추가하기 2. 완성
image:
  path: /assets/img/devlog/fusejs.png
description: >
  블로그에 검색 기능을 추가하려고 합니다.
hide_description: true
category: devlog
tags: [jekyll, Github, Github Pages, Blogs, JavaScript, Fuzzy]
hide_last_modified: true
---

블로그 내 검색 기능을 구현했습니다.
{:.lead}

1. toc
{:toc}

# 검색 버튼 약간의 수정
~~~html
<!--file: "_includes/body/menu.html"-->
<button id="_search" class="nav-btn no-hover">
    <label class="sr-only" for="_search-input">Search</label>
    <span class="icon-search"></span>
</button>
<form id="_search-box">
    <div class="nav-btn"><span class="icon-search"></span></div>
    <input
      id="_search-input"
      type="search"
      class="nav-btn"
      placeholder="Type something…"
    />
    <button id="reset-btn" type="reset" class="nav-btn no-hover">
      <span class="sr-only">Close</span> <span class="icon-cross"></span>
    </button>
</form>
~~~

`_search-input-box`를 삭제하고, `_search-box`를 `form`태그로 바꿔서 조금 더 깔끔하게 만들었습니다.

~~~css
/*file: "_sass/my_style.scss"*/
#_search-input {
    height: 100%;
    flex: 1;
    padding-left: 3rem;
    padding-right: 3rem;
}

#_search-box>button[type=reset] {
    position: absolute;
    top: 0;
    right: 0;
    border: none;
}

#_search-box>div.nav-btn {
    position: absolute;
    top: 0;
    left: 0;
    border: none;
}
~~~

지난번과 조금 레이아웃을 다르게 바꿨습니다. 검색창 전부를 `input`으로 꽉차게 만들고, `padding`을 추가해 input값이 입력되는 공간을 아이콘 안쪽으로 오게끔 했습니다. 각 아이콘은 `absolute` position값을 부여해서 `input` 박스 위로 올라오게끔 했습니다. 양 끝에 붙게 되는데, `.nav-btn`클래스에서 마진을 적절히 부여하므로 이렇게 해도 됩니다.

완성된 검색바의 모습입니다.

![search-btn-made-2](/assets/img/devlog/search-btn-made-2.gif){:style="display:block; margin:auto;" width="90%"}

그리고, Javascript 코드도 바뀌었습니다.

~~~javascript
// file: "assets/searchBox.js
const ONOFF_SWITCH_CLASS = ".switch-button";
const SEARCH_INPUT_ID = "_search-input";

const searchInput = document.getElementById(SEARCH_INPUT_ID);

function searchBox(event) {
    const searchBox = document.getElementById(SEARCH_BOX_ID);
    const darkModeBtn = document.querySelector(ONOFF_SWITCH_CLASS);

    searchBox.classList.add(SHOW_BOX_CLASS);
    darkModeBtn.classList.add(HIDE_CLASS);
    searchInput.focus(); // move focus to input box
}
~~~

searchInput 추가, focus() method 호출
{:.figcaption}

지난번 코드에서는 검색 버튼을 누르면 검색창이 나오지만 포커스는 검색 버튼에 유지되는 문제점이 있었습니다. 찾아보니 focus()라는 메소드를 이용해 포커스를 이동시킬 수 있었습니다.

그리고 다크모드 OnOff 스위치의 클래스명이 잘못돼 수정했습니다.

# 검색 내용이 디스플레이될 div 추가

검색 내용이 입력될 때 찾은 글을 보여줄 공간이 필요합니다.

~~~html
<!--file: "_includes/body/menu.html"-->
<div id="_search-hits" class="hide"></div>
<template id="_search-item-template">
    <a id="_search-item" href="#">
        <img class="search-img" />
        <div class="search-text">
            <span class="search-text__title"></span>
            <small></small>
        </div>
    </a>
</template>
~~~

이런 div와 template를 추가해줬습니다. 검색 내용을 집어넣을 html fragment도 `tamplate`태그를 이용해 생성해봤습니다. `#_search-hits`는 처음에는 `.hide`클래스를 가지도록 해 가렸습니다. javascript를 이용해 `#_search-hits`에 `#_search-item`들을 넣어줄겁니다.

~~~css
/*file: "_sass/my_style.scss"*/
#_search-hits {
    background: var(--main-background-color);
    position: absolute;
    top: 3rem;
    left: 0;
    right: 0;
    display: inline-block;
    max-height: calc(100vh - 5rem);
    overflow-y: auto;
    overscroll-behavior-y: none;
    box-shadow: 0 0.5rem 5rem rgba(0,0,0,0.35);
    padding-bottom: 1rem;
}
~~~

`#_search-hits`의 색은 background color과 같게 하되, box-shadow를 부여했습니다. overflow-y는 추후 검색 내용의 양에 따라 스크롤바를 이용하기 위해 일단 넣었습니다. `display: inline-block`을 이용해 search item 양에 따라 유동적으로 `#_search-hits`의 height를 조정하되, 최대 크기는 지정해줬습니다.

~~~javascript
// file: "assets/searchBox.js
const SEARCH_HITS_ID = "_search-hits";
const searchHits = document.getElementById(SEARCH_HITS_ID);

const searchInput = document.getElementById(SEARCH_INPUT_ID);
searchInput.addEventListener("input", inputTyped);

function searchBoxHide(event) {
    const searchBox = document.getElementById(SEARCH_BOX_ID);
    const darkModeBtn = document.querySelector(ONOFF_SWITCH_CLASS);

    searchBox.classList.remove(SHOW_BOX_CLASS);
    darkModeBtn.classList.remove(HIDE_CLASS);
    searchHits.classList.add(HIDE_CLASS);
}

function inputTyped(event) {
    const input = event.target.value;
    const searchHits = document.getElementById(SEARCH_HITS_ID);
    searchHits.classList.remove(HIDE_CLASS);
}
~~~

`input`태그에 이벤트 리스너를 생성해서, 입력값이 있을때마다 inputTyped 함수를 실행하도록 했습니다. inputTyped()에서는 input값이 있으면 `#_search-hits`의 `.hide`클래스를 제거하고, 없으면 부여합니다.

X버튼을 눌렀을 때 `#_search-hits`를 가리는 코드도 추가했습니다.

아래는 구현된 내용의 작동 모습입니다.

![search-bar-hit](/assets/img/devlog/search-bar-hit.gif){:style="display:block; margin:auto;" width="90%"}

input값이 없으면 #_search-hits도 정상적으로 사라지는 것을 확인할 수 있습니다.
{:.figcaption}

# Fuzzy String Matching

'자바스크립트'라는 검색어를 입력한다면, 굳이 끝까지 다 입력하지 않고 '자바'까지만 입력하더라도 결과가 잘 보여야 합니다. 문자열을 비교해서 '애매하게 비슷'한 문자열까지 찾아주는 방법이 필요한건데, 딱 이런게 있습니다. 바로 퍼지 문자열 매칭(Fuzzy String Matching)입니다.

자세한 방법은 생각보다 심오하니 추후 자세한 포스팅을 남기기로 하고, 바로 실전으로 들어가보겠습니다.

퍼지 문자열 매칭 알고리즘을 사용할 수 있는 방법은 여러가지가 있습니다.

## fuse.js 이용하기

`fuse.js`는 `fuzzy search` 라이브러리로, 다른 라이브러리와 의존성이 없어 가볍게 사용하기에 좋습니다.

[fusejs.io](https://fusejs.io/)

먼저, 라이브러리를 가져옵니다.
~~~html
<!--file: "_includes/head/links-static.html"-->
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.5.3"></script>
~~~

그리고 `fuse.js`에서 제공하는 `Fuse().search()` 메소드를 사용하기 위해 블로그의 문서들을 json 형태로 바꾸는 작업이 필요합니다. Jekyll의 유용한 문법중 하나인 Liquid를 사용해 다음과 같은 json 파일을 생성하고, html에서 불러왔습니다.

~~~css
/*file: "assets/sitedata.json"*/
---
sitemap: false
---
data = {% assign pages = site.html_pages | where_exp:"page","page.sitemap != false" %}
{% assign docs = site.documents | where_exp:"doc","doc.sitemap != false and doc.layout == 'post'" %}
{
  "pages": [
    {% for page in pages %}{
      {% if page.image       %}"image": {{       page.image       | jsonify }},{% endif %}
      {% if page.title       %}"title": {{       page.title       | jsonify }},{% endif %}
      {% if page.description %}"description": {{ page.description | markdownify | strip_html | jsonify }},{% endif %}
      {% if page.content     %}"content": {{     page.content     | markdownify | strip_html | jsonify }},{% endif %}
      "url": {{                                  page.url         | jsonify }}
    }{% unless forloop.last %},{% endunless %}{% endfor %}
  ],
  "documents": [
    {% for doc in docs %}{
      {% if doc.image       %}"image": {{       doc.image       | jsonify }},{% endif %}
      {% if doc.title       %}"title": {{       doc.title       | jsonify }},{% endif %}
      {% if doc.date        %}"date": {{        doc.date        | jsonify }},{% endif %}
      {% if doc.description %}"description": {{ doc.description | markdownify | strip_html | jsonify }},{% endif %}
      {% if doc.content     %}"content": {{     doc.content     | markdownify | strip_html | jsonify }},{% endif %}
      {% if doc.categories  %}"categories": {{  doc.categories  | jsonify }},{% endif %}
      {% if doc.tags        %}"tags": {{        doc.tags        | jsonify }},{% endif %}
      {% if doc.keywords    %}"keywords": {{    doc.keywords    | jsonify }},{% endif %}
      "collection": {{                          doc.collection  | jsonify }},
      "url": {{                                 doc.url         | jsonify }},
    }{% unless forloop.last %},{% endunless %}{% endfor %}
  ]
}

~~~

겉보기에는 복잡해보이지만 아주 단순한 코드입니다. 이를 불러오면 `data` 안에 문서들이 객체 형태로 로드됩니다.

~~~html
<!--file: "_includes/head/links-static.html"-->
<script type="text/javascript" src="/assets/sitedata.json"></script>
~~~

이를 assets/searchBox.js에서 사용하도록 합니다.

~~~javascript
// file: "assets/searchBox.js
const ITEM_SUBTITLE_TAG = "small";
const options = {
    isCaseSensitive: false,
    includeScore: true,
    // 이것 외에도 사용할 수 있는 여러 option들이 있습니다.
    keys: [
        "image",
        "title",
        "date",
        "description",
        "content",
        "categories",
        "tags",
        "url"
    ]
};
const fuse_documents = new Fuse(data.documents, options);
const fuse_pages = new Fuse(data.pages, options);

function inputTyped(event) {
    searchHits.innerText = "";
    searchHits.classList.remove(HIDE_CLASS);

    const input = event.target.value;

    const [page_searched, document_searched] = fuse(input);
    // page_searched는 사용하지 않지만, 추후 확장성을 위해 만들어뒀습니다.

    document_searched.map(doc => {
        const item = itemTemplate.content.cloneNode(true).children[0];
        const item_img = item.querySelector(ITEM_IMG_CLASS);
        const item_title = item.querySelector(ITEM_TITLE_CLASS);
        const item_subtitle = item.querySelector();

        if (doc.item.image) item_img.setAttribute("src", doc.item.image.path);
        else item_img.setAttribute("src", "/assets/img/404.png");
        // 이미지가 없을 경우 404이미지를 넣습니다.

        item_title.textContent = doc.item.title;
        item.setAttribute("href", `https://custardcream98.github.io${doc.item.url}`);
        item_subtitle.textContent = doc.item.description;

        searchHits.append(item)
    })
}

function fuse(pattern) {
    return [fuse_pages.search(pattern), fuse_documents.search(pattern)];
}
~~~

이렇게 `fuse(input)`을 `console.log()`로 찍어보면 아래처럼 나옵니다.

![fusejs](/assets/img/devlog/fusejs.png){:style="display:block; margin:auto;" width="90%"}

검색 결과인 `item`과 점수(`score`)까지 잘 나옵니다. 점수가 낮을수록 검색어와 더 잘 매칭된 item이라는 뜻이라고 합니다.

그러나 여기에는 작은 문제가 있었습니다. '호빵'을 검색하고 싶다면 '호ㅃ'까지만 쳐도 나오는게 이상적이겠지만 `juse.js`에서는 한글의 초성, 중성, 종성을 지원하지 못해 글자를 제대로 완성하지 않으면 나오지 않습니다. 글자를 분해하는 코드를 이용해 수정하면 해결할 수 있지 않을까 싶은데, 이 부분은 향후 개선할 사항으로 남겨두겠습니다.

이제 자바스크립트로 만들어낸 `#_search-item`들의 css를 손봐줍니다.

~~~css
/*file: "_sass/my_style.scss"*/
#_search-item {
    height: 3.7rem;
    color: var(--main-text-color);
    padding-left: 1rem;
    padding-right: 1rem;
    margin-top: 1rem;
    display: flex;
    box-sizing: border-box;
}

.search-img {
    width: 20%;
    height: 2.9rem;
    object-fit: cover;
}

.search-text {
    margin-left: 2rem;
    margin-right: 3rem;
    width: 80%;
    display: inline-flex;
}

.search-text__title {
    width: 50%;
}

.search-text>small {
    width: 50%;
    margin-left: 2rem;
}
~~~

아래는 최종 결과물입니다.

![search-bar-hit-2](/assets/img/devlog/search-bar-hit-2.gif){:style="display:block; margin:auto;" width="90%"}