---
layout: post
title: Jekyll 블로그에 검색기능 추가하기 2. 완성
image:
  path: /assets/img/devlog/fusejs.png
description: >
  블로그에 검색 기능을 추가하려고 합니다.
hide_description: true
category: devlog
tags: [jekyll, Github, Github Pages, Blogs, JavaScript, Fuzzy]
hide_last_modified: true
---

블로그 내 검색 기능을 구현했습니다.
{:.lead}

1. toc
{:toc}

# 검색 버튼 약간의 수정
~~~html
<!--file: "_includes/body/menu.html"-->
<button id="_search" class="nav-btn no-hover">
    <label class="sr-only" for="_search-input">Search</label>
    <span class="icon-search"></span>
</button>
<form id="_search-box">
    <div class="nav-btn"><span class="icon-search"></span></div>
    <input
      id="_search-input"
      type="search"
      class="nav-btn"
      placeholder="Type something…"
    />
    <button id="reset-btn" type="reset" class="nav-btn no-hover">
      <span class="sr-only">Close</span> <span class="icon-cross"></span>
    </button>
</form>
~~~

`_search-input-box`를 삭제하고, `_search-box`를 `form`태그로 바꿔서 조금 더 깔끔하게 만들었습니다.

~~~css
/*file: "_sass/my_style.scss"*/
#_search-input {
    height: 100%;
    flex: 1;
    padding-left: 3rem;
    padding-right: 3rem;
}

#_search-box>button[type=reset] {
    position: absolute;
    top: 0;
    right: 0;
    border: none;
}

#_search-box>div.nav-btn {
    position: absolute;
    top: 0;
    left: 0;
    border: none;
}
~~~

지난번과 조금 레이아웃을 다르게 바꿨습니다. 검색창 전부를 `input`으로 꽉차게 만들고, `padding`을 추가해 input값이 입력되는 공간을 아이콘 안쪽으로 오게끔 했습니다. 각 아이콘은 `absolute` position값을 부여해서 `input` 박스 위로 올라오게끔 했습니다. 양 끝에 붙게 되는데, `.nav-btn`클래스에서 마진을 적절히 부여하므로 이렇게 해도 됩니다.

완성된 검색바의 모습입니다.

![search-btn-made-2](/assets/img/devlog/search-btn-made-2.gif){:style="display:block; margin:auto;" width="90%"}

그리고, Javascript 코드도 바뀌었습니다.

~~~javascript
// file: "assets/searchBox.js
const ONOFF_SWITCH_CLASS = ".switch-button";
const SEARCH_INPUT_ID = "_search-input";

const searchInput = document.getElementById(SEARCH_INPUT_ID);

function searchBox(event) {
    const searchBox = document.getElementById(SEARCH_BOX_ID);
    const darkModeBtn = document.querySelector(ONOFF_SWITCH_CLASS);

    searchBox.classList.add(SHOW_BOX_CLASS);
    darkModeBtn.classList.add(HIDE_CLASS);
    searchInput.focus(); // move focus to input box
}
~~~

searchInput 추가, focus() method 호출
{:.figcaption}

지난번 코드에서는 검색 버튼을 누르면 검색창이 나오지만 포커스는 검색 버튼에 유지되는 문제점이 있었습니다. 찾아보니 focus()라는 메소드를 이용해 포커스를 이동시킬 수 있었습니다.

그리고 다크모드 OnOff 스위치의 클래스명이 잘못돼 수정했습니다.

# 검색 내용이 디스플레이될 div 추가

검색 내용이 입력될 때 찾은 글을 보여줄 공간이 필요합니다.

~~~html
<!--file: "_includes/body/menu.html"-->
<div id="_search-hits" class="hide"></div>
<template id="_search-item-template">
    <a id="_search-item" href="#">
        <img class="search-img" />
        <div class="search-text">
            <span class="search-text__title"></span>
            <small></small>
        </div>
    </a>
</template>
~~~

이런 div와 template를 추가해줬습니다. 검색 내용을 집어넣을 html fragment도 `tamplate`태그를 이용해 생성해봤습니다. `#_search-hits`는 처음에는 `.hide`클래스를 가지도록 해 가렸습니다. javascript를 이용해 `#_search-hits`에 `#_search-item`들을 넣어줄겁니다.

~~~css
/*file: "_sass/my_style.scss"*/
#_search-hits {
    background: var(--main-background-color);
    position: absolute;
    top: 3rem;
    left: 0;
    right: 0;
    display: inline-block;
    max-height: calc(100vh - 5rem);
    overflow-y: auto;
    overscroll-behavior-y: none;
    box-shadow: 0 0.5rem 5rem rgba(0,0,0,0.35);
    padding-bottom: 1rem;
}
~~~

`#_search-hits`의 색은 background color과 같게 하되, box-shadow를 부여했습니다. overflow-y는 추후 검색 내용의 양에 따라 스크롤바를 이용하기 위해 일단 넣었습니다. `display: inline-block`을 이용해 search item 양에 따라 유동적으로 `#_search-hits`의 height를 조정하되, 최대 크기는 지정해줬습니다.

~~~javascript
// file: "assets/searchBox.js
const SEARCH_HITS_ID = "_search-hits";
const searchHits = document.getElementById(SEARCH_HITS_ID);

const searchInput = document.getElementById(SEARCH_INPUT_ID);
searchInput.addEventListener("input", inputTyped);

function searchBoxHide(event) {
    const searchBox = document.getElementById(SEARCH_BOX_ID);
    const darkModeBtn = document.querySelector(ONOFF_SWITCH_CLASS);

    searchBox.classList.remove(SHOW_BOX_CLASS);
    darkModeBtn.classList.remove(HIDE_CLASS);
    searchHits.classList.add(HIDE_CLASS);
}

function inputTyped(event) {
    const input = event.target.value;
    const searchHits = document.getElementById(SEARCH_HITS_ID);
    searchHits.classList.remove(HIDE_CLASS);
}
~~~

`input`태그에 이벤트 리스너를 생성해서, 입력값이 있을때마다 inputTyped 함수를 실행하도록 했습니다. inputTyped()에서는 input값이 있으면 `#_search-hits`의 `.hide`클래스를 제거하고, 없으면 부여합니다.

X버튼을 눌렀을 때 `#_search-hits`를 가리는 코드도 추가했습니다.

아래는 구현된 내용의 작동 모습입니다.

![search-bar-hit](/assets/img/devlog/search-bar-hit.gif){:style="display:block; margin:auto;" width="90%"}

input값이 없으면 #_search-hits도 정상적으로 사라지는 것을 확인할 수 있습니다.
{:.figcaption}

# Fuzzy String Matching

'자바스크립트'라는 검색어를 입력한다면, 굳이 끝까지 다 입력하지 않고 '자바'까지만 입력하더라도 결과가 잘 보여야 합니다. 문자열을 비교해서 '애매하게 비슷'한 문자열까지 찾아주는 방법이 필요한건데, 딱 이런게 있습니다. 바로 퍼지 문자열 매칭(Fuzzy String Matching)입니다.

자세한 방법은 생각보다 심오하니 추후 자세한 포스팅을 남기기로 하고, 바로 실전으로 들어가보겠습니다.

퍼지 문자열 매칭 알고리즘을 사용할 수 있는 방법은 여러가지가 있습니다.

## fuse.js 이용하기

`fuse.js`는 `fuzzy search` 라이브러리로, 다른 라이브러리와 의존성이 없어 가볍게 사용하기에 좋습니다.

[fusejs.io](https://fusejs.io/)

먼저, 라이브러리를 가져옵니다.
~~~html
<!--file: "_includes/head/links-static.html"-->
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.5.3"></script>
~~~

# Liquid로 검색에 사용할 .json 생성하기

그리고 `fuse.js`에서 제공하는 `Fuse().search()` 메소드를 사용하기 위해 블로그의 문서들을 json 형태로 바꾸는 작업이 필요합니다. Jekyll의 유용한 문법중 하나인 Liquid를 사용해 다음과 같은 json 파일을 생성하고, html에서 불러왔습니다.

{% raw %}
~~~css
/*file: "assets/sitedata.json"*/
---
sitemap: false
---
{% assign pages = site.html_pages | where_exp:"page","page.sitemap != false" %}
{% assign docs = site.documents | where_exp:"doc","doc.sitemap != false" | where_exp:"doc","doc.layout == 'post'" %}
{
  "pages": [
    {% for page in pages %}{
      {% if page.image       %}"image": {{       page.image       | jsonify }},{% endif %}
      {% if page.title       %}"title": {{       page.title       | jsonify }},{% endif %}
      {% if page.description %}"description": {{ page.description | markdownify | strip_html | jsonify }},{% endif %}
      {% if page.content     %}"content": {{     page.content     | markdownify | strip_html | jsonify }},{% endif %}
      "url": {{                                  page.url         | jsonify }}
    }{% unless forloop.last %},{% endunless %}{% endfor %}
  ],
  "documents": [
    {% for doc in docs %}{
      {% if doc.image       %}"image": {{       doc.image       | jsonify }},{% endif %}
      {% if doc.title       %}"title": {{       doc.title       | jsonify }},{% endif %}
      {% if doc.date        %}"date": {{        doc.date        | jsonify }},{% endif %}
      {% if doc.description %}"description": {{ doc.description | markdownify | strip_html | jsonify }},{% endif %}
      {% if doc.content     %}"content": {{     doc.content     | markdownify | strip_html | jsonify }},{% endif %}
      {% if doc.categories  %}"categories": {{  doc.categories  | jsonify }},{% endif %}
      {% if doc.tags        %}"tags": {{        doc.tags        | jsonify }},{% endif %}
      {% if doc.keywords    %}"keywords": {{    doc.keywords    | jsonify }},{% endif %}
      "collection": {{                          doc.collection  | jsonify }},
      "url": {{                                 doc.url         | jsonify }},
    }{% unless forloop.last %},{% endunless %}{% endfor %}
  ]
}
~~~
{% endraw %}

참고로 이부분 포스팅 과정에서 오류가 났는데, jekyll 엔진이 이부분을 파싱하면서 생긴 문제였습니다. Github Pages에 Liquid문법을 올릴 때는 raw, endraw Liquid Tag로 코드를 감싸줘야 합니다.
{:.figcaption}

겉보기에는 복잡해보이지만 아주 단순한 코드입니다. 이를 `assets/js/searchBox.js`에서 사용하도록 합니다.

# 검색 내용을 찾는 Javascript Code (using fuse.js)

~~~javascript
// file: "assets/js/searchBox.js
// 파일 디렉터리를 변경했습니다.
const ITEM_SUBTITLE_TAG = "small";
const options = {
    isCaseSensitive: false,
    includeScore: true,
    // 이것 외에도 사용할 수 있는 여러 option들이 있습니다.
    keys: [
        "image",
        "title",
        "date",
        "description",
        "content",
        "categories",
        "tags",
        "url"
    ]
};
const fuse_documents = new Fuse(data.documents, options);
const fuse_pages = new Fuse(data.pages, options);

function inputTyped(event) {
    searchHits.innerText = "";
    searchHits.classList.remove(HIDE_CLASS);

    const input = event.target.value;

    const [page_searched, document_searched] = fuse(input);
    // page_searched는 사용하지 않지만, 추후 확장성을 위해 만들어뒀습니다.

    document_searched.map(doc => {
        const item = itemTemplate.content.cloneNode(true).children[0];
        const item_img = item.querySelector(ITEM_IMG_CLASS);
        const item_title = item.querySelector(ITEM_TITLE_CLASS);
        const item_subtitle = item.querySelector();

        if (doc.item.image) item_img.setAttribute("src", doc.item.image.path);
        else item_img.setAttribute("src", "/assets/img/404.png");
        // 이미지가 없을 경우 404이미지를 넣습니다.

        item_title.textContent = doc.item.title;
        item.setAttribute("href", `https://custardcream98.github.io${doc.item.url}`);
        item_subtitle.textContent = doc.item.description;

        searchHits.append(item)
    })
}

function fuse(pattern) {
    return [fuse_pages.search(pattern), fuse_documents.search(pattern)];
}
~~~

이렇게 `fuse(input)`을 `console.log()`로 찍어보면 아래처럼 나옵니다.

![fusejs](/assets/img/devlog/fusejs.png){:style="display:block; margin:auto;" width="90%"}

검색 결과인 `item`과 점수(`score`)까지 잘 나옵니다. 점수가 낮을수록 검색어와 더 잘 매칭된 item이라는 뜻이라고 합니다.

그러나 여기에는 작은 문제가 있었습니다. '호빵'을 검색하고 싶다면 '호ㅃ'까지만 쳐도 나오는게 이상적이겠지만 `juse.js`에서는 한글의 초성, 중성, 종성을 지원하지 못해 글자를 제대로 완성하지 않으면 나오지 않습니다. 글자를 분해하는 코드를 이용해 수정하면 해결할 수 있지 않을까 싶은데, 이 부분은 향후 개선할 사항으로 남겨두겠습니다.

참고로, 실제로는 앞서 생성된 json파일을 불러오기 위해 json파일을 `fetch`로 불러오는 과정이 앞서 있습니다. 자세한 코드는 [깃헙](https://github.com/custardcream98/custardcream98.github.io/tree/main/assets/js/searchBox.js)을 참고해주세요.

이제 자바스크립트로 만들어낸 `#_search-item`들의 css를 손봐줍니다.

~~~css
/*file: "_sass/my_style.scss"*/
#_search-item {
    height: 3.7rem;
    color: var(--main-text-color);
    padding-left: 1rem;
    padding-right: 1rem;
    margin-top: 1rem;
    display: flex;
    box-sizing: border-box;
}

.search-img {
    width: 20%;
    height: 2.9rem;
    object-fit: cover;
}

.search-text {
    margin-left: 2rem;
    margin-right: 3rem;
    width: 80%;
    display: inline-flex;
}

.search-text__title {
    width: 50%;
}

.search-text>small {
    width: 50%;
    margin-left: 2rem;
}
~~~

아래는 최종 결과물입니다.

![search-bar-hit-2](/assets/img/devlog/search-bar-hit-2.gif){:style="display:block; margin:auto;" width="90%"}

# Github-Pages 로컬 환경에서 실행하기

저는 Github-Pages를 로컬에서 돌리는 설정을 따로 해놓지 않고 테스트를 진행했는데요, Github-Pages에서 지원하는 Jekyll 버전과 제 로컬 `Gemfile`에 명시된 Jekyll 버전이 달라 문제가 생긴 과정이 있었습니다.

[여기](#liquid로-검색에-사용할-json-생성하기)에서 Liquid Filter를 처음에는 이렇게 했었습니다.
{% raw %}
~~~css
/*file: "assets/sitedata.json"*/
{% assign docs = site.documents | where_exp:"doc","doc.sitemap != false and doc.layout == 'post'" %}
~~~
{% endraw %}
`site.documents` 중에서 `sitemap == false and layout == 'post'`인 `doc`만 가져오는 구문입니다.

그랬는데 분명 로컬에서는 잘 실행되던 코드가 이상하게 Github에 올리기만 하면 build가 안되는겁니다. 알고보니 Jekyll 버전 차이로 인해 잡아내지 못한 부분으로, Jekyll 4.1버전와 3.9버전의 차이 때문이었습니다. (정확하게 어느 부분이 달라졌는지는 모르겠지만, 소거법으로 그게 유일한 이유임을 알아냈습니다)

덕분에 정신차리고 `Gemfile`을 수정해서 로컬에서도 Github-Pages와 똑같은 환경으로 맞춰놓고 테스트를 할 수 있게 됐습니다. Jekyll을 이용해 깃헙 페이지를 운영하시는 분들은 꼭 아래를 참고해 `Gemfile`을 설정하세요.

~~~ruby
source "https://rubygems.org"

gem "jekyll", "= 3.9.0"

group :jekyll_plugins do
    gem 'github-pages'
    gem 'jekyll-include-cache'
    gem 'jekyll-compose'
end

gem 'wdm' if Gem.win_platform?
gem "tzinfo-data" if Gem.win_platform?

gem "webrick", "~> 1.7"
~~~

참고로 저 Jekyll 버전 문제는 `where_exp` 필터를 두 번 나눠 쓰는것으로 해결했습니다.

# 수정해야 할 부분
- [ ] 검색어 리스트가 모바일 화면에서는 제대로 나오지 않는 문제
- [ ] fuse.js의 한글 자소분리 문제

# 정리

직접 블로그에 HTML Component를 생성해 Search Bar를 구현했습니다. Jekyll 프레임워크, Liquid, JavaScript를 공부할 수 있는 좋은 기회였고, Fuzzy String Matching은 존재한다고만 알고 있었는데 직접 활용한 재밌는 과정이었습니다. 기본 중의 기본이라고 할 수 있는 검색창이 어떤 식으로 만들어지는지도 조금이지만 알 수 있었습니다.

별 건 아니지만 이런 Stack이 쌓이면 좋은 개발자가 될 수 있을거라고 믿습니다. 무튼 이제 블로그 기본적인 세팅은 끝난것같으니, [나머지 TODOs](https://custardcream98.github.io/devlog/2022-03-20-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%BB%A4%EC%8A%A4%ED%84%B0%EB%A7%88%EC%9D%B4%EC%A7%95/#TODOs)들은 나중에 시간 나는대로 조금씩 만들어나도록 하고, 우선은 당장 급한 django 공부부터 하겠습니다.